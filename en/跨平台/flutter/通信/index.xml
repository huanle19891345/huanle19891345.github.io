<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>通信 on 郑欢的学习总结</title>
    <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/</link>
    <description>Recent content in 通信 on 郑欢的学习总结</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language><atom:link href="https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MessageLoop</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/messageloop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/messageloop/</guid>
      <description>TaskRunners::TaskRunners(std::string label, fml::RefPtr&amp;lt;fml::TaskRunner&amp;gt; platform, fml::RefPtr&amp;lt;fml::TaskRunner&amp;gt; gpu, fml::RefPtr&amp;lt;fml::TaskRunner&amp;gt; ui, fml::RefPtr&amp;lt;fml::TaskRunner&amp;gt; io) : label_(std::move(label)), platform_(std::move(platform)), gpu_(std::move(gpu)), ui_(std::move(ui)), io_(std::move(io)) {} ThreadHost::ThreadHost /// The collection of all the threads used by the engine. ThreadHost enum Type { Platform = 1 &amp;lt;&amp;lt; 0, UI = 1 &amp;lt;&amp;lt; 1, GPU = 1 &amp;lt;&amp;lt; 2, IO = 1 &amp;lt;&amp;lt; 3, }; std::unique_ptr&amp;lt;fml::Thread&amp;gt; platform_thread; std::unique_ptr&amp;lt;fml::Thread&amp;gt; ui_thread; std::unique_ptr&amp;lt;fml::Thread&amp;gt; gpu_thread; std::unique_ptr&amp;lt;fml::Thread&amp;gt; io_thread; ThreadHost(std::string name_prefix, uint64_t type_mask); ThreadHost::ThreadHost(std::string name_prefix, uint64_t mask) { if (mask &amp;amp; ThreadHost::Type::Platform) { platform_thread = std::make_unique&amp;lt;fml::Thread&amp;gt;(name_prefix + &amp;#34;.</description>
    </item>
    
    <item>
      <title>MethodChannel</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/methodchannel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/methodchannel/</guid>
      <description>整体设计 graph LR subgraph DartVM Dart(DartFramework)--&amp;gt;|await|Engine(EngineC++) end subgraph Platform Engine--&amp;gt;|GetPlatformTaskRunner-&amp;gt;PostTask|PlatformC++--&amp;gt;PlatformJava PlatformJava--&amp;gt;PlatformC++ PlatformC++--&amp;gt;|ui_task_runner_-&amp;gt;PostTask|Engine--&amp;gt;Dart end 传递数据编解码设计 数据反向也是类似的编解码
graph LR subgraph Dart MethodCallDart(&amp;quot;MethodCall:StringMethodName,ObjectArguments&amp;quot;)--&amp;gt;|encode|ByteBufferDart(&amp;quot;ByteDataDart&amp;quot;) end ByteBufferDart--&amp;gt;Transport--&amp;gt;|decode|MethodCallNative subgraph native MethodCallNative end EngineUi线程接收消息模块设计 graph TB subgraph DartUiThreadNative ALooper_pollOnce--&amp;gt;MessageLoopAndroid::OnEventFired --&amp;gt;Engine::DispatchPlatformMessage--&amp;gt;RuntimeController::DispatchPlatformMessage --&amp;gt;PlatformConfiguration::DispatchPlatformMessage--&amp;gt;tonic::DartInvoke end subgraph DartUiThreadDart tonic::DartInvoke--&amp;gt;binding.dart--&amp;gt;platform_channel.dart--&amp;gt;callHandler end 类结构设计 MethodChannel classDiagram class MethodChannel { String name MethodCodec codec BinaryMessenger binaryMessenger } class MethodCodec { encodeMethodCall(MethodCall methodCall)ByteData decodeMethodCall(ByteData? methodCall)MethodCall decodeEnvelope(ByteData envelope)dynamic encodeSuccessEnvelope(dynamic result)ByteData encodeErrorEnvelope(String code, String? message, dynamic details)ByteData } class BinaryMessenger{ handlePlatformMessage(String channel, ByteData?</description>
    </item>
    
    <item>
      <title>Pigeon</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/pigeon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/pigeon/</guid>
      <description>https://github.com/flutter/packages/tree/master/packages/pigeon
Pigeon效果 graph LR subgraph Pigeon/message.dart HostApi(&amp;quot;@HostApi&amp;quot;) FlutterApi(&amp;quot;@FlutterApi&amp;quot;) Class(&amp;quot;Define Class&amp;quot;) configurePigeon end subgraph FlutterSideGeneratedCode FlutterApi--&amp;gt;GenerateFlutterApi(&amp;quot;abstract class FlutterApi:channel.setMessageHandler and delegate to FlutterApi&amp;quot;) GenerateCallHostApi(&amp;quot;class HostApi: wrap channel.send&amp;quot;)--&amp;gt;HostApi end subgraph AndroidSideGeneratedCode GenerateCallFullterApi(&amp;quot;classFlutterApi: wrap channel.send&amp;quot;)--&amp;gt;FlutterApi HostApi--&amp;gt;GenereateHostApi(&amp;quot;interface HostApi: channel.setMessageHandler and delegate to HostApi&amp;quot;) end Pigeon @async server端 sync时生成的server端handler直接代理到接口实现进行方法调用，无法异步，必须阻塞platform thread
RequestParams input = RequestParams.fromMap((Map&amp;lt;String, Object&amp;gt;)message); Resource output = api.request(input); wrapped.put(&amp;#34;result&amp;#34;, output.toMap()); reply.reply(wrapped); async时server端handler方法签名多一个参数Result，利用回调实现异步
public interface Result&amp;lt;T&amp;gt; { void success(T result); } RequestParams input = RequestParams.fromMap((Map&amp;lt;String, Object&amp;gt;)message); api.</description>
    </item>
    
  </channel>
</rss>
