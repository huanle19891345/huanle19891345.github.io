<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>技术探索总结 on 郑欢的学习总结</title>
    <link>https://huanle19891345.github.io/en/</link>
    <description>Recent content in 技术探索总结 on 郑欢的学习总结</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language><atom:link href="https://huanle19891345.github.io/en/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1ANRSystmHandle</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/anr/1anrsystmhandle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/anr/1anrsystmhandle/</guid>
      <description>ANR 设计原理 组件超时分类 Broadcast 超时原理举例 ANR Trace Dump流程 图解 sequenceDiagram SystemServer-&amp;gt;&amp;gt;SystemServer: AppNotResponding.run activate SystemServer Note right of SystemServer: 1.非异常场景下,统计进程信息,包括: Note right of SystemServer: 发生ANR的进程,SystemServer进程,SurfaceFligner进程,CPU占用高的5个进程 Note right of SystemServer: 2.打印ANR顶部信息 被统计的进程-&amp;gt;&amp;gt;被统计的进程: 虚拟机启动过程在SignalCatcher进行信号注册和监听(SIGQUIT) SystemServer-&amp;gt;&amp;gt;被统计的进程: 3.逐个向统计的进程发送SIGQUIT信号,通知dump进程信息 被统计的进程-&amp;gt;&amp;gt;被统计的进程: TheadList::DumpForSigQuit activate 被统计的进程 Note right of 被统计的进程: 遍历所有的Java线程和虚拟机线程,设置checkpoint,请求挂起suspend deactivate 被统计的进程 被统计的进程-&amp;gt;&amp;gt;被统计的进程: 所有线程挂起后，SignalCatcher线程开始遍历Dump各线程的堆栈和线程数据，结束之后再唤醒线程 SystemServer-&amp;gt;&amp;gt;SystemServer: 监听管道并读取管道内容,写入Trace文件 deactivate SystemServer 参考signalcatcher获取各线程信息的工作过程
Capture ANR ANR 信息写入 继续以广播接收为例，在上面介绍到当判定超时后，会调用系统服务 AMS 接口，搜集本次 ANR 相关信息并存档(data/anr/trace，data/system/dropbox)，入口如下。
进入系统服务 AMS 之后，AppError 先进行场景判断，以过滤当前进程是不是已经发生并正在执行 Dump 流程，或者已经发生 Crash，或者已经被系统 Kill 之类的情况。并且还考虑了系统是否正在关机等场景，如果都不符合上述条件，则认为当前进程真的发生 ANR。</description>
    </item>
    
    <item>
      <title>1BinderServiceManager</title>
      <link>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/binder/1binderservicemanager/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/binder/1binderservicemanager/</guid>
      <description>Sequence svclist frameworks/native/cmds/servicemanager/service_manager.c
service_manager.c(ServiceManger is single thread) main int main(int argc, char** argv) { struct binder_state *bs; union selinux_callback cb; char *driver; if (argc &amp;gt; 1) { driver = argv[1]; } else { driver = &amp;#34;/dev/binder&amp;#34;; } bs = binder_open(driver, 128*1024);//1  if (binder_become_context_manager(bs)) {//2  ALOGE(&amp;#34;cannot become context manager (%s)\n&amp;#34;, strerror(errno)); return -1; } binder_loop(bs, svcmgr_handler);//3  return 0; } binder_open
binder_become_context_manager
binder_loop
svcmgr_handler int svcmgr_handler(struct binder_state *bs, struct binder_transaction_data *txn, struct binder_io *msg, struct binder_io *reply) { switch(txn-&amp;gt;code) { case SVC_MGR_GET_SERVICE: case SVC_MGR_CHECK_SERVICE: s = bio_get_string16(msg, &amp;amp;len); handle = do_find_service(s, len, txn-&amp;gt;sender_euid, txn-&amp;gt;sender_pid); if (!</description>
    </item>
    
    <item>
      <title>1hotfixResearch</title>
      <link>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/1hotfixresearch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/1hotfixresearch/</guid>
      <description>价值 热修复的作用   可快速修复，避免线上Bug带来的业务损失，把损失降到最低。
  保证客户端的更新率，无须用户进行版本升级安装
  良好的用户体验，无感知修复异常。节省用户下载安装成本。
  分类 图解 graph LR subgraph dex插入到数组的最前 DexElements end subgraph env-&amp;gt;FromReflectedMethod得到方法对应的ArtMethod,对其所有成员进行修改 NativeHook end subgraph 避免类被加上ISPREVERIFIED 补丁dex end 代码修复--&amp;gt;NativeHook 代码修复--&amp;gt;DexElements DexElements--&amp;gt;补丁dex DexElements--&amp;gt;全量dex 代码修复--&amp;gt;混合优化 代码修复--&amp;gt;代码插桩和替换 各技术能力范围 https://github.com/Tencent/tinker/wiki
    Tinker QZone AndFix Robust     类替换 yes yes no no   So替换 yes no no no   资源替换 yes yes no no   全平台支持 yes yes yes yes   即时生效 no no yes yes   性能损耗 较小 较大 较小 较小   补丁包大小 较小 较大 一般 一般   开发透明 yes yes no no   复杂度 较低 较低 复杂 复杂   gradle支持 yes no no no   Rom体积 较大 较小 较小 较小   成功率 较高 较高 一般 最高    代码修复 代码插桩和替换/Java Hook Instant Run 原理 在第一次完整编译的时候给所有的类插桩（字节码操作），使它们的方法能被代理</description>
    </item>
    
    <item>
      <title>1manageMemory</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/1managememory/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/1managememory/</guid>
      <description>Overview of memory management Share memory 图解 graph LR shareMemory--&amp;gt;forksZygoteProcess--&amp;gt;frameworkCode forksZygoteProcess--&amp;gt;resources shareMemory--&amp;gt;mmapStaticData--&amp;gt;odex mmapStaticData--&amp;gt;appResourceTable mmapStaticData--&amp;gt;so shareMemory--&amp;gt;sharedMemoryRegions--&amp;gt;ashmem--&amp;gt;|betweenAppAndScreenCompositor|windowSurfaces ashmem--&amp;gt;|betweenContentProviderAndClient|cursorBuffers sharedMemoryRegions--&amp;gt;gralloc In order to fit everything it needs in RAM, Android tries to share RAM pages across processes. It can do so in the following ways:
 Each app process is forked from an existing process called Zygote. The Zygote process starts when the system boots and loads common framework code and resources (such as activity themes).</description>
    </item>
    
    <item>
      <title>1MediatorLiveData</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/2livedata/1mediatorlivedata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/2livedata/1mediatorlivedata/</guid>
      <description>原理图 graph LR MediatorLiveData--&amp;gt;|addSource|sourceLiveDataN subgraph SourceN,observeForever when mediatorLiveData acitve sourceLiveDataN--&amp;gt;|onChange|observerN end MediatorLiveData--&amp;gt;|addSource|sourceLiveData2 subgraph Source2,observeForever when mediatorLiveData acitve sourceLiveData2--&amp;gt;|onChange|observer2 end MediatorLiveData--&amp;gt;|addSource|sourceLiveData1 subgraph Source1,observeForever when mediatorLiveData acitve sourceLiveData1--&amp;gt;|onChange|observer1 end MutableLiveData public class MutableLiveData&amp;lt;T&amp;gt; extends LiveData&amp;lt;T&amp;gt; { /** * Creates a MutableLiveData initialized with the given {@code value}. * * @param value initial value */ public MutableLiveData(T value) { super(value); } /** * Creates a MutableLiveData with no value assigned to it. */ public MutableLiveData() { super(); } @Override public void postValue(T value) { super.</description>
    </item>
    
    <item>
      <title>1nativeCrash选型和整体流程</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/nativecrash/1nativecrash%E9%80%89%E5%9E%8B%E5%92%8C%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/nativecrash/1nativecrash%E9%80%89%E5%9E%8B%E5%92%8C%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B/</guid>
      <description>原理流程四个阶段 graph LR nativeCrashHappening--&amp;gt;systemHandle(1:SystemHandle)--&amp;gt;|debug|tombstoneFile(TombstoneFile) tombstoneFile--&amp;gt;symbolrecovery(3:SymbolRecovery)--&amp;gt;analysisRootCause(4:AnalysisRootCause) systemHandle--&amp;gt;|release|collectStack(2:CollectStack)--&amp;gt;|upload|tombstoneFile 处理流程 一个完整的 Native 崩溃从捕获到解析要经历哪些流程。
  编译端。编译 C/C++ 代码时，需要将带符号信息的文件保留下来。
  客户端。捕获到崩溃时候，将收集到尽可能多的有用信息写入日志文件，然后选择合适的时机上传到服务器。
  服务端。读取客户端上报的日志文件，寻找适合的符号文件，生成可读的 C/C++ 调用栈。
  现有的方案 对于很多中小型公司来说，我并不建议自己去实现一套如此复杂的系统，可以选择一些第三方的服务。目前各种平台也是百花齐放，包括腾讯的Bugly、阿里的啄木鸟平台、网易云捕、Google 的 Firebase 等等。
当然，在平台的选择方面，我认为，从产品化跟社区维护来说，Bugly 在国内做的最好；从技术深度跟捕获能力来说，阿里 UC 浏览器内核团队打造的啄木鸟平台最佳。
xCrash BreakPad https://chromium.googlesource.com/breakpad/breakpad/+/master
https://chromium.googlesource.com/breakpad/breakpad/+/master/docs/
https://chromium.googlesource.com/breakpad/breakpad/+/master/docs/getting_started_with_breakpad.md
https://github.com/google/breakpad
https://github.com/AndroidAdvanceWithGeektime/Chapter01
Google breakpad是一个跨平台的崩溃转储和分析框架和工具集合。
Breakpad由三个主要组件：
 client，以library的形式内置在你的应用中，当崩溃发生时写 minidump文件 symbol dumper, 读取由编译器生成的调试信息（debugging information），并生成 symbol file processor， 读取 minidump文件 和 symbol file ，生成可读的c/c++ Stack trace.  简单来说就是一个生成 minidump，一个生成symbol file，然后将其合并处理成可读的Stack trace。
bugly nativecrash模块+ setCrashHandleCallback监听上报到公司服务器</description>
    </item>
    
    <item>
      <title>1Space</title>
      <link>https://huanle19891345.github.io/en/android/art/alloc_gc/1space/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/alloc_gc/1space/</guid>
      <description>类设计 ART虚拟机提供了多种内存分配手段，它们分别由LargeObjectSpace、BumpPointerSpace、ZygoteSpace、RegionSpace、DlMallocSpace和RosAllocSpace六个类(叶子节点)来实现。ImageSpace用于.art文件的加载
classDiagram class Space { +GetNames() +Contains() +IsImageSpace() +IsMallocSpace() +isZygoteSpace() +isBumpPointerSpace() +IsRegionSpace() } class AllocSpace { +GetByteAllocated() +GetObjectsAllocated() +Alloc() +AllocThreadSafe() +Free() +FreeList() } Space &amp;lt;|-- ContinuousSpace ContinuousSpace &amp;lt;|-- MemMapSpace MemMapSpace &amp;lt;|-- ImageSpace MemMapSpace &amp;lt;|-- ContinuousMemMapAllocSpace AllocSpace &amp;lt;|-- ContinuousMemMapAllocSpace AllocSpace &amp;lt;|-- LargeObjectSpace Space &amp;lt;|-- DiscontinuousSpace DiscontinuousSpace &amp;lt;|-- LargeObjectSpace ContinuousMemMapAllocSpace &amp;lt;|-- BumpPointerSpace ContinuousMemMapAllocSpace &amp;lt;|-- RegionSpace ContinuousMemMapAllocSpace &amp;lt;|-- ZygoteSpace ContinuousMemMapAllocSpace &amp;lt;|-- MallocSpace MallocSpace &amp;lt;|-- DlMallocSpace MallocSpace &amp;lt;|-- RosAllocSpace LargeObjectSpace &amp;lt;|-- LargeObjectMapSpace LargeObjectSpace &amp;lt;|-- FreeListSpace SpaceBitmap space_bitmap(-inl).</description>
    </item>
    
    <item>
      <title>1startup</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/1startup/1startup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/1startup/1startup/</guid>
      <description>Flutter 安卓平台源码剖析
Flutter启动流程源码分析
深入理解Flutter引擎启动&amp;ndash;详细
Flutter作为一款跨平台的框架，可以运行在Android、iOS等平台，Android为例讲解如何从Android应用启动流程中衔接到Flutter框架，如何启动Flutter引擎的启动流程。 熟悉Android的开发者，应该都了解APP启动过程，会执行Application和Activity的初始化，并调用它们的onCreate()方法。那么FlutterApplication和FlutterActivity的onCreate()方法是连接Native和Flutter的枢纽。
 FlutterApplication.java的onCreate过程：初始化配置文件/加载libflutter.so/注册JNI方法； FlutterActivity.java的onCreate过程：创建FlutterView、Engine, Dart虚拟机、Isolate、taskRunner等对象，最终执行执行到Dart的main()方法，执行runApp(Widget app)来处理整个Dart业务代码。  深入理解Flutter应用启动&amp;ndash;runApp(Widget app)方法开始
runApp(MyApp)是flutter应用开始真正执行业务逻辑代码的起点，整个过程主要工作：
 WidgetsFlutterBinding初始化：这是一个单例模式，负责创建WidgetsFlutterBinding对象，WidgetsFlutterBinding继承抽象类BindingBase，并且附带7个mixin，初始化渲染、语义化、绘制、平台消息以及手势等一系列操作； attachRootWidget：遍历挂载整个视图树，并建立Widget、Element、RenderObject之间的连接与关系，此处Element的具体类型为RenderObjectToWidgetElement； scheduleWarmUpFrame：调度预热帧，执行帧绘制方法handleBeginFrame和handleDrawFrame。  从WidgetsFlutterBinding是单例模式，从小节[2.4]得WidgetsBinding的renderViewElement记录着唯一的RenderObjectToWidgetElement对象，从小节[2.3.2]可知RendererBinding的renderView记录着唯一的RenderView对象；也就是说每个flutter应用创建的Root Widget跟Element、RenderObject一一对应，且单例唯一。
MyApp是用户定义的根Widget，为了建立三棵树的关系，RenderObjectToWidgetAdapter起到重要的桥接功能，该类的createElement方法创建RenderObjectToWidgetElement对象，createRenderObject()方法获取的是RenderView。
 </description>
    </item>
    
    <item>
      <title>1xCrash原理</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/xcrash/1xcrash%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/xcrash/1xcrash%E5%8E%9F%E7%90%86/</guid>
      <description>xCrash 架构与实现 整体架构 xCrash 整体分为两部分：运行于崩溃的 APP 进程内的部分，和独立进程的部分（我们称为 dumper）。
1、APP 进程内 这部分可以再分为 Java 和 native 两个部分。
（1）Java 部分： ①Java 崩溃捕获。直接使用 JVM 提供的机制来完成，最后生成兼容 tombstone 格式的 dump 文件。
②Native 崩溃捕获机制的注册器。通过 JNI 激活 native 层的对应机制。
③Tombstone 文件解析器。可以将 tombstone 文件解析成 json 格式。
④Tombstone 文件管理器。可以检索设备上已经生成的 tombstone 文件。
（2）Native 部分： ①JNI Bridge。负责与 Java 层的交互。（传参与回调）
②Signal handlers。负责信号捕获，以及启动独立进程 dumper。
③Fallback mode。负责当 dumper 捕获崩溃信息失败时，尝试在崩溃进行的 signal handler 中收集崩溃信息。
2、Dumper 独立进程 这部分是纯 native 的实现： ①Process。负责崩溃进程中各个线程的控制（attach 和 detach），以及进程层面的信息收集，比如 FD 列表、logcat 等等。
②Threads。负责崩溃进程中的线程相关数据的收集，比如 registers、backtrace、stack 等等。</description>
    </item>
    
    <item>
      <title>1插件化面临的问题</title>
      <link>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/1%E6%8F%92%E4%BB%B6%E5%8C%96%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/1%E6%8F%92%E4%BB%B6%E5%8C%96%E9%9D%A2%E4%B8%B4%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>图解 graph LR subgraph 解决插件组件生命周期调用问题 插件生命周期 end subgraph 反射AssetManager.assetPath,再通过AssetManager来创建一个新的Resources对象 加载插件资源 end subgraph newDexClassLoader加载插件apk,从插件ClassLoader中load指定的插件Activity名字,newInstance之后强转为Activity类型使用 加载插件类 end subgraph 上下文如BaseContext,mResources,activityInfo在attach时反射替换为插件的 直接提供插件Activity给系统 end 插件生命周期--&amp;gt;启动插件Activity 启动插件Activity--&amp;gt;HookInstrumentation的execStartActivity 启动插件Activity--&amp;gt;|Shadow|更改启动Activity方式,调用自定义方法到插件进程,转成插代理Activity 插件生命周期--&amp;gt;AMS回到App端 AMS回到App端--&amp;gt;直接提供插件Activity给系统--&amp;gt;Hack修改宿主PathClassLoader 直接提供插件Activity给系统--&amp;gt;HackActivityThread主线程Handler AMS回到App端--&amp;gt;提供代理Activity给系统--&amp;gt;生命周期转发给插件Activity 提供代理Activity给系统--&amp;gt;|Shadow|生命周期转发给插件Activity,再转调回代理Activity 加载插件类 Shadow的全动态设计原理解析
Java还有两个和动态化相关的特性，一个是接口，另一个是向上转型。
Class&amp;lt;?&amp;gt; implClass = classLoader.loadClass(&amp;#34;com.xxx.AImpl&amp;#34;); Object implObject = implClass.newInstance(); A a = (A) implObject; 这里假设classLoader动态加载了一些Java类，其中就有一个类叫做com.xxx.AImpl，AImpl继承自A，或者AImpl实现了A接口。注意这里用了强制类型转换，是因为代码层面是将Object类型向下转型成了A。但实际上我们知道implObject的类型是AImpl，AImpl转换成A是一个向上转型。向上转型总是安全的。所以用这种方法总是可以先定义出接口，精心设计接口，让接口足够通用和稳定。只要接口不变，它的实现总是可以修改的。我们将接口打包在宿主中，接口就轻易不能更新了。但是它的实现总是可以更新的。
加载插件资源 传统方式 https://github.com/singwhatiwanna/dynamic-load-apk/
我们知道，activity的工作主要是由ContextImpl来完成的， 它在activity中是一个叫做mBase的成员变量。注意到Context中有如下两个抽象方法，看起来是和资源有关的，实际上context就是通过它们来获取资源的，这两个抽象方法的真正实现在ContextImpl中。也即是说，只要我们自己实现这两个方法，就可以解决资源问题了。
/** Return an AssetManager instance for your application&amp;#39;s package. */ public abstract AssetManager getAssets(); /** Return a Resources instance for your application&amp;#39;s package.</description>
    </item>
    
    <item>
      <title>1跨组件传递数据</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9E%B6%E6%9E%84/1%E8%B7%A8%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9E%B6%E6%9E%84/1%E8%B7%A8%E7%BB%84%E4%BB%B6%E4%BC%A0%E9%80%92%E6%95%B0%E6%8D%AE/</guid>
      <description>总览 InheritedWidget图解 graph TB parent(&amp;quot;parentInheritedWidget&amp;quot;)--&amp;gt;|_dependents:依赖我,的组件,也就是我的改变需要通知到的组件|child(&amp;quot;child.inheritFromWidgetOfExactType&amp;quot;) child--&amp;gt;|getParentInheritedWidget|parent child--&amp;gt;|useParentInheritedWidget|child 类设计 Element.mount @mustCallSuper void mount(Element parent, dynamic newSlot) { _updateInheritance();//main  } InheritedElement._updateInheritance @override void _updateInheritance() { assert(_active); final Map&amp;lt;Type, InheritedElement&amp;gt; incomingWidgets = _parent?._inheritedWidgets; if (incomingWidgets != null) _inheritedWidgets = HashMap&amp;lt;Type, InheritedElement&amp;gt;.from(incomingWidgets); else _inheritedWidgets = HashMap&amp;lt;Type, InheritedElement&amp;gt;(); _inheritedWidgets[widget.runtimeType] = this; } Element.inheritFromWidgetOfExactType /// Obtains the nearest widget of the given type, which must be the type of a  /// concrete [InheritedWidget] subclass, and registers this build context with  /// that widget such that when that widget changes (or a new widget of that  /// type is introduced, or the widget goes away), this build context is  /// rebuilt so that it can obtain new values from that widget.</description>
    </item>
    
    <item>
      <title>2Alloc</title>
      <link>https://huanle19891345.github.io/en/android/art/alloc_gc/2alloc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/alloc_gc/2alloc/</guid>
      <description>graph LR subgraph CollectorType kCollectorTypeCC kCollectorTypeMC kCollectorTypeSS kCollectorTypeGSS kCollectorTypeMS kCollectorTypeCMS end subgraph AllocatorType kCollectorTypeMS--&amp;gt;MallocSpace kCollectorTypeCMS--&amp;gt;MallocSpace kCollectorTypeCC--&amp;gt;RegionSpace kCollectorTypeMC--&amp;gt;BumpPointerSpace kCollectorTypeSS--&amp;gt;BumpPointerSpace kCollectorTypeGSS--&amp;gt;BumpPointerSpace MallocSpace--&amp;gt;|kUseRosAlloc|kAllocatorTypeRosAlloc MallocSpace--&amp;gt;kAllocatorTypeDlMalloc RegionSpace--&amp;gt;|use_tlab_|kAllocatorTypeRegionTLAB RegionSpace--&amp;gt;kAllocatorTypeRegion BumpPointerSpace--&amp;gt;|use_tlab_|kAllocatorTypeTLAB BumpPointerSpace--&amp;gt;kAllocatorTypeBumpPointer end heap.cc
Heap::ChangeCollector(CollectorType) void Heap::ChangeCollector(CollectorType collector_type) { /*CollectorType是一个枚举变量，用于定义不同的回收器类型。collector_type_是 Heap类的成员变量，描述当前设定的回收器类型。对笔者所搭建的模拟器而言，虚拟机使用的 回收器类型为kCollectorTypeCMS。CMS是ConcurrentMarkSweep的缩写。它是标记 清除垃圾回收算法的一种。本书后续章节会详细介绍它们。此处，读者仅作简单了解即可。 */ if (collector_type != collector_type_) { collector_type_ = collector_type;//设置垃圾回收器类型  ...... switch (collector_type_) { case kCollectorTypeCC: {//CC是Concurrent Copying的缩写  ..... if (use_tlab_) {//是否使用TLAB。本例中不使用它，所以use_tlab_为false  //ChangeAllocator函数将设置内存分配器的类型  ChangeAllocator(kAllocatorTypeRegionTLAB); } else { ChangeAllocator(kAllocatorTypeRegion); } break; } case kCollectorTypeMC://MC:Mark Compact  case kCollectorTypeSS://SS:Semi-space  //GSS:改进版的SS  case kCollectorTypeGSS:{ .</description>
    </item>
    
    <item>
      <title>2ANRMonitor_CollectInfo</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/anr/2anrmonitor_collectinfo/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/anr/2anrmonitor_collectinfo/</guid>
      <description>应用层如何判定 ANR Android M(6.0) 版本之后，应用侧无法直接通过监听 data/anr/trace 文件，监控是否发生 ANR，那么大家又有什么其它手段去判定 ANR 呢？下面我们简单介绍一下
站在应用侧角度来看，因为系统没有提供太友好的机制，去主动通知应用是否发生 ANR，而且很多信息更是对应用屏蔽了访问权限，但是对于三方 App 来说，也需要关注基本的用户体验，因此很多公司也进行了大量的探索，并给出了不同的解决思路，目前了解到的方案(思路)主要有下面 2 种：
 主线程 watchdog 机制  核心思想是在应用层定期向主线程设置探测消息，并在异步设置超时监测，如在规定的时间内没有收到发送的探测消息状态更新，则判定可能发生 ANR，为什么是可能发生 ANR？因为还需要进一步从系统服务获取相关数据(下面会讲到如何获取)，进一步判定是否真的发生 ANR。
 监听 SIGNALQUIT 信号  该方案在很多公司有应用，网上也有相关介绍，这里主要介绍一下思路。我们在上面提到了虚拟机是通过注册和监听 SIGNALQUIT 信号的方式执行请求的，而对于信号机制有了解的同学马上就可以猜到，我们也可以在应用层参考此方式注册相同信号去监听。不过要注意的是注册之后虚拟机之前注册的就会被覆盖，需要在适当的时候进行恢复，否则小心系统(厂商)找上门。
当接收到该信号时，过滤场景，确定是发生用户可感知的 ANR 之后，从 Java 层获取各线程堆栈，或通过反射方式获取到虚拟机内部 Dump 线程堆栈的接口，在内存映射的函数地址，强制调用该接口，并将数据重定向输出到本地。
该方案从思路上来说优于第一种方案，并且遵循系统信息获取方式，获取的线程信息及虚拟机信息更加全面，但缺点是对性能影响比较大，对于复杂的 App 来说，统计其耗时，部分场景一次 Dump 耗时可能要超过 10S。
应用层如何获取 ANR Info 上面提到无论是 Watchdog 还是监听信号的方式，都需要结论进一步过滤，以确保收集我们想要的 ANR 场景，因此需要利用系统提供的接口，进一步判定当前应用是否发生问题(ANR，Crash)；
与此同时，除了需要获取进程中各线程状态之外，我们也需要知道系统乃至其他进程的一些状态，如系统 CPU，Mem，IO 负载，关键进程的 CPU 使用率等等，便于推测发生问题时系统环境是否正常；
获取信息相关接口类如下：
通过该接口获取的相关信息，示意如下，其中下图红框选中的关键字，我们在后续 ANR 分析思路一章，会对其进行详细释义：
xcrashanr</description>
    </item>
    
    <item>
      <title>2BinderServer</title>
      <link>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/binder/2binderserver/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/binder/2binderserver/</guid>
      <description>Binder Native And Java Design classDiagram class IBinder { +queryLocalInterface(descriptor) +linkToDeath(recipient, cookie, flags) status_t +unlinkToDeath(recipient, cookie, flags, outRecipient) status_t +transact(code, data, reply, flags) status_t +localBinder() BBinder +remoteBinder() BpBinder } class BpBinder { } class BBinder { +transact(code, data, reply, flags) #onTransact(code, data, reply, flags) } class BnInterface~INTERFACE~ { +queryLocalInterface(_descriptor) IInterface +getInterfaceDescriptor() descriptor #onAsBinder() IBinder } class BnGraphicBufferProducer { +onTransact() status_t } class IInterface { +asBinder(IInterface*) IBinder } class IGraphicBufferProducer { +ipcMethod() } class BufferQueueProducer { +ipcMethod() } class JavaBBinder { +onTransact() } IBinder &amp;lt;|-- BpBinder IBinder &amp;lt;|-- BBinder BBinder &amp;lt;|-- BnInterface : native type server BBinder &amp;lt;|-- JavaBBinder : java type server BnInterface &amp;lt;|-- BnGraphicBufferProducer : BnInterface&amp;lt;IGraphicBufferProducer&amp;gt; IInterface &amp;lt;|-- IGraphicBufferProducer BnGraphicBufferProducer &amp;lt;|-- BufferQueueProducer IGraphicBufferProducer &amp;lt;|.</description>
    </item>
    
    <item>
      <title>2OOM</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/2oom/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/2oom/</guid>
      <description>OOM原因分析 要定位OOM问题，首先需要弄明白Android中有哪些原因会导致OOM，Android中导致OOM的原因主要可以划分为以下几个类型：
Android 虚拟机最终抛出OutOfMemoryError的代码位于/art/runtime/thread.cc。
void Thread::ThrowOutOfMemoryError(const char* msg) 参数 msg 携带了 OOM 时的错误信息 下面两个地方都会调用上面方法抛出OutOfMemoryError错误，这也是Android中发生OOM的主要原因。
堆内存分配失败 系统源码文件：/art/runtime/gc/heap.cc
void Heap::ThrowOutOfMemoryError(Thread* self, size_t byte_count, AllocatorType allocator_type) 抛出时的错误信息： oss &amp;lt;&amp;lt; &amp;#34;Failed to allocate a &amp;#34; &amp;lt;&amp;lt; byte_count &amp;lt;&amp;lt; &amp;#34; byte allocation with &amp;#34; &amp;lt;&amp;lt; total_bytes_free &amp;lt;&amp;lt; &amp;#34; free bytes and &amp;#34; &amp;lt;&amp;lt; PrettySize(GetFreeMemoryUntilOOME()) &amp;lt;&amp;lt; &amp;#34; until OOM&amp;#34;; 这是在进行堆内存分配时抛出的OOM错误，这里也可以细分成两种不同的类型：
 为对象分配内存时达到进程的内存上限。由Runtime.getRuntime.MaxMemory()可以得到Android中每个进程被系统分配的内存上限，当进程占用内存达到这个上限时就会发生OOM，这也是Android中最常见的OOM类型。 没有足够大小的连续地址空间。这种情况一般是进程中存在大量的内存碎片导致的，其堆栈信息会比第一种OOM堆栈多出一段信息：failed due to fragmentation (required continguous free “&amp;laquo; required_bytes &amp;laquo; “ bytes for a new buffer where largest contiguous free ” &amp;laquo; largest_continuous_free_pages &amp;laquo; “ bytes)”; 其详细代码在art/runtime/gc/allocator/rosalloc.</description>
    </item>
    
    <item>
      <title>2Provider</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9E%B6%E6%9E%84/2provider/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9E%B6%E6%9E%84/2provider/</guid>
      <description>总结 监听者_DefaultInheritedProviderScopeElement监听到回调通知后通过markNeedsBuild()进行rebuild,而Consumer会通过Provider.of获取到最新的model值
graph LR ChangeNotifierProvider(&amp;quot;ChangeNotifierProvider_T extends ChangeNotifier_&amp;quot;)--&amp;gt;|1:ListensTo|ChangeNotifier ChangeNotifier--&amp;gt;|2:notifyListeners|ChangeNotifierProvider--&amp;gt;|3:rebuildsAndNotifyDependentsDescendants|Consumer 类设计 在_InheritedProviderScopeMixin被unmount时，会通知ChangeNotifier进行dispose，可以用来进行结构化并发，取消异步数据请求。
ChangeNotifier Usage class Counter with ChangeNotifier { int value = 0; void increment() { value += 1; notifyListeners(); } } /// A class that can be extended or mixed in that provides a change notification /// API using [VoidCallback] for notifications. /// /// See also: /// /// * [ValueNotifier], which is a [ChangeNotifier] that wraps a single value. class ChangeNotifier implements Listenable { LinkedList&amp;lt;_ListenerEntry&amp;gt;?</description>
    </item>
    
    <item>
      <title>2startup_embedder_framwwork</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/1startup/2startup_embedder_framwwork/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/1startup/2startup_embedder_framwwork/</guid>
      <description>graph LR FlutterView--&amp;gt;|对应|DartVM--&amp;gt;|对应|Engine attachToFlutterEngine图解 分别由FlutterRenderer控制渲染flutter UI到platform侧的FlutterView，由AndroidTouchProcessor控制platform侧的FlutterView的touchEvent到flutter
graph LR FlutterView--&amp;gt;|attachToFlutterEngine|FlutterEngine FlutterView--&amp;gt;|interaction events to|FlutterEngine FlutterEngine--&amp;gt;|renderTo|FlutterView FlutterEngine--&amp;gt;FlutterRenderer--&amp;gt;|notify|FlutterJNI RenderSurface--&amp;gt;|nofity surface event|FlutterRenderer FlutterView--&amp;gt;|contains|RenderSurface FlutterEngine--&amp;gt;|contains|PlatformViewsController--&amp;gt;|contains|AndroidTouchProcessor--&amp;gt;|sendTouchEvent|Flutter 下述为flutter1.12版本时的源码研究，新版2.0设计上已经进行优化见上面的图解
1.12时在new FlutterView时进行Engine和DartVM的构造和初始化，而在2.0上功能分离到FlutterEngine这个java class中
FlutterApplication.onCreate /** * Flutter implementation of {@link android.app.Application}, managing * application-level global initializations. */ //FlutterApplication @CallSuper public void onCreate() { super.onCreate(); FlutterMain.startInitialization(this); } /** FlutterMain * Starts initialization of the native system. * @param applicationContext The Android application context. */ public static void startInitialization(@NonNull Context applicationContext) { if (isRunningInRobolectricTest) { return; } FlutterLoader.</description>
    </item>
    
    <item>
      <title>3ANRAnalysisRootCause</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/anr/3anranalysisrootcause/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/anr/3anranalysisrootcause/</guid>
      <description>Anr信息解释 &amp;#34;Signal Catcher&amp;#34; daemon prio=5 tid=6 Runnable | group=&amp;#34;system&amp;#34; sCount=0 dsCount=0 flags=0 obj=0x15b802d8 self=0x756d5cc2e000 | sysTid=7781 nice=0 cgrp=default sched=0/0 handle=0x756d5c9ffd50 | state=R schedstat=( 9996973 11775302 9 ) utm=0 stm=0 core=3 HZ=100 | stack=0x756d5c909000-0x756d5c90b000 stackSize=991KB | held mutexes= &amp;#34;mutator lock&amp;#34;(shared held) native: #00 pc 000000000048df0e /apex/com.android.runtime/lib64/libart.so (art::DumpNativeStack(std::__1::basic_ostream&amp;lt;char, std::__1::char_traits&amp;lt;char&amp;gt;&amp;gt;&amp;amp;, int, BacktraceMap*, char const*, art::ArtMethod*, void*, bool)+126) native: #01 pc 00000000005a77b3 /apex/com.android.runtime/lib64/libart.so (art::Thread::DumpStack(std::__1::basic_ostream&amp;lt;char, std::__1::char_traits&amp;lt;char&amp;gt;&amp;gt;&amp;amp;, bool, BacktraceMap*, bool) const+675) native: #02 pc 00000000005c49bb /apex/com.android.runtime/lib64/libart.so (art::DumpCheckpoint::Run(art::Thread*)+859) native: #03 pc 00000000005bcf18 /apex/com.</description>
    </item>
    
    <item>
      <title>3BinderClient</title>
      <link>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/binder/3binderclient/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/binder/3binderclient/</guid>
      <description>Data Flow graph LR parcel_data--&amp;gt;flat_binder_object flat_binder_object--&amp;gt;binder_transaction_data getService SystemServiceRegistry ContextImpl.getSystemService @Override public Object getSystemService(String name) { return SystemServiceRegistry.getSystemService(this, name); } registerServices /** * Manages all of the system services that can be returned by {@link Context#getSystemService}. Used by {@link ContextImpl}. */ static { ...... registerService(Context.ACTIVITY_SERVICE, ActivityManager.class, new CachedServiceFetcher&amp;lt;ActivityManager&amp;gt;() { @Override public ActivityManager createService(ContextImpl ctx) { return new ActivityManager(ctx.getOuterContext(), ctx.mMainThread.getHandler()); }}); ...... registerService(Context.DISPLAY_SERVICE, DisplayManager.class, new CachedServiceFetcher&amp;lt;DisplayManager&amp;gt;() { @Override public DisplayManager createService(ContextImpl ctx) { return new DisplayManager(ctx.</description>
    </item>
    
    <item>
      <title>3flutter_surface</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/1startup/3flutter_surface/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/1startup/3flutter_surface/</guid>
      <description>RenderSurface类设计图解 classDiagram class FlutterSurfaceView { -FlutterRenderer flutterRenderer -SurfaceHolder_Callback surfaceCallback } class FlutterTextureView { -FlutterRenderer flutterRenderer; -Surface renderSurface; } class FlutterImageView { -FlutterRenderer flutterRenderer; -ImageReader imageReader } TextureView&amp;lt;|--FlutterTextureView RenderSurface&amp;lt;|--FlutterTextureView SurfaceView&amp;lt;|--FlutterSurfaceView RenderSurface&amp;lt;|--FlutterSurfaceView View&amp;lt;|--FlutterImageView RenderSurface&amp;lt;|--FlutterImageView class FlutterView classDiagram class AndroidSurface { +SetNativeWindow(AndroidNativeWindow) } class AndroidSurfaceGL { fml::RefPtr&amp;lt;AndroidNativeWindow&amp;gt; native_window_; std::unique_ptr&amp;lt;AndroidEGLSurface&amp;gt; onscreen_surface_; std::unique_ptr&amp;lt;AndroidEGLSurface&amp;gt; offscreen_surface_; } GPUSurfaceSoftwareDelegate&amp;lt;|--AndroidSurfaceSoftware AndroidSurface&amp;lt;|--AndroidSurfaceSoftware AndroidSurface&amp;lt;|--AndroidSurfaceGL GPUSurfaceGLDelegate&amp;lt;|--AndroidSurfaceGL AndroidSurface&amp;lt;|--AndroidSurfaceVulkan GPUSurfaceVulkanDelegate&amp;lt;|--AndroidSurfaceVulkan class GPUSurfaceGL { GPUSurfaceGLDelegate* delegate_ sk_sp&amp;lt;SkSurface&amp;gt; onscreen_surface_ } Surface&amp;lt;|--GPUSurfaceGL class AndroidEGLSurface { const EGLSurface surface_; const EGLDisplay display_; const EGLContext context_; bool SwapBuffers(); } Flutter通过Surface自绘图解 graph LR subgraph Platform Surface end Surface--&amp;gt;|flutterRenderer.</description>
    </item>
    
    <item>
      <title>3Hprof_binary_dump_format</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/3hprof_binary_dump_format/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/3hprof_binary_dump_format/</guid>
      <description>JVM HPROF_查看_Binary Dump Format (format=b) graph LR STRING_IN_UTF8--&amp;gt;xxxx HEAP_DUMP_SEGMENT--&amp;gt;ROOT_UNKNOWN HEAP_DUMP_SEGMENT--&amp;gt;ROOT_JNI_GLOBAL HEAP_DUMP_SEGMENT--&amp;gt;...... HEAP_DUMP_SEGMENT--&amp;gt;CLASS_DUMP HEAP_DUMP_SEGMENT--&amp;gt;INSTANCE_DUMP HEAP_DUMP_SEGMENT--&amp;gt;OBJECT_ARRAY_DUMP HEAP_DUMP_SEGMENT--&amp;gt;PRIMITIVE_ARRAY_DUMP HEAP_DUMP_END--&amp;gt;xxx Binary Dump Format (format=b) The basic fields in the binary output are u1 (1 byte), u2 (2 byte), u4 (4 byte), and u8 (8 byte). An ID in this implementation is a u4, however the size of an ID is really determined by the &amp;ldquo;size of identifiers&amp;rdquo; field in the header.
WARNING: This format is still considered highly experimental, however, all attempts were made to match the format of past HPROF implementations.</description>
    </item>
    
    <item>
      <title>3异步_响应式_状态管理</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9E%B6%E6%9E%84/3%E5%BC%82%E6%AD%A5_%E5%93%8D%E5%BA%94%E5%BC%8F_%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9E%B6%E6%9E%84/3%E5%BC%82%E6%AD%A5_%E5%93%8D%E5%BA%94%E5%BC%8F_%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86/</guid>
      <description>状态管理 graph LR StateMangement--&amp;gt;BLOC/Stream+StreamBuilder/Rxdart StateMangement--&amp;gt;Redux StateMangement--&amp;gt;Provider/ScopedModel rxdart https://pub.dev/packages/rxdart
   Dart RxDart     Stream Observable   StreamController Subject    redux Flutter Fish Redux架构演进2.0
https://pub.dev/packages/flutter_redux
https://pub.dev/packages/fish_redux
StroreProver和ChangeNotifierProvider是基于InheritedWidget，而BlocProvider不是
Provider基于context.getElementForInheritedWidgetOfExactType&amp;lt;_DefaultInheritedProviderScope&amp;gt;跨组件获取数据
而BlocProvider是基于: BlocProviderprovider = context.ancestorWidgetOfExactType(type);跨组件获取数据
graph LR subgraph redux StoreProvider StoreConnector Store end StoreProvider--&amp;gt;|similar|ChangeNotifierProvider StoreConnector--&amp;gt;|similar|Consumer Store--&amp;gt;|similar|ChangeNotifier subgraph provider ChangeNotifierProvider Consumer ChangeNotifier end subgraph BLOC/Stream+StreamBuilder ChangeNotifierProvider--&amp;gt;|similar|BlocProvider ChangeNotifier--&amp;gt;|similar|XxxBloc Consumer--&amp;gt;|similar|BlocProvider.of end  state-mgmt https://flutter.dev/docs/development/data-and-backend/state-mgmt
https://flutter.dev/docs/development/data-and-backend/state-mgmt/options
ephemeral state and app state When asked about React’s setState versus Redux’s store, the author of Redux, Dan Abramov, replied:</description>
    </item>
    
    <item>
      <title>4BinderKernel</title>
      <link>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/binder/4binderkernel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/binder/4binderkernel/</guid>
      <description>图解binder_ioctl graph TB binder_ioctl--&amp;gt;|case BINDER_WRITE_READ|binder_ioctl_write_read binder_ioctl_write_read--&amp;gt;copy_from_user(&amp;quot;copy_from_user(&amp;amp;bwr, ubuf, sizeof(bwr));&amp;quot;) binder_ioctl_write_read--&amp;gt;|bwr.write_size &amp;gt; 0|binder_thread_write binder_ioctl_write_read--&amp;gt;|bwr.read_size &amp;gt; 0|binder_thread_read binder_ioctl_write_read--&amp;gt;copy_to_user(&amp;quot;copy_to_user(ubuf, &amp;amp;bwr, sizeof(bwr))&amp;quot;) binder_thread_write--&amp;gt;|拷贝用户空间的cmd命令|get_user(&amp;quot;get_user(cmd, (uint32_t __user *)ptr)&amp;quot;)--&amp;gt;|case BC_TRANSACTION:拷贝用户空间的binder_transaction_data|binder_transaction(&amp;quot;binder_transaction(proc, thread, &amp;amp;tr,cmd == BC_REPLY, 0)&amp;quot;)--&amp;gt;|handle=0则找到servicemanager实体|service_manager(&amp;quot;context-&amp;gt;binder_context_mgr_node&amp;quot;) subgraph 得到binder_node-&amp;gt;proc,也就是binder_proc*类型的target_proc binder_get_node_refs_for_txn end subgraph open系统调用时返回的fd信息的private_data里是binder_proc,而mmap过程会修改这个binder_proc的alloc字段信息,从而确保申请的内存位于target process对应的内核空间 binder_alloc_new_buf end service_manager--&amp;gt;binder_get_node_refs_for_txn(&amp;quot;binder_get_node_refs_for_txn(target_node, &amp;amp;target_proc,&amp;amp;return_error);&amp;quot;) subgraph 从rbTree中找到ref-&amp;gt;data.desc等于入参handle的binder_ref将其返回 binder_get_ref_olocked end binder_transaction--&amp;gt;|target.handle &amp;gt; 0|binder_get_ref_olocked(&amp;quot;binder_get_ref_olocked(proc, tr-&amp;gt;target.handle,true)&amp;quot;) binder_get_ref_olocked--&amp;gt;|传递ref-&amp;gt;node作为binder_node参数|binder_get_node_refs_for_txn binder_get_node_refs_for_txn--&amp;gt;binder_alloc_new_buf(&amp;quot;t-&amp;gt;buffer = binder_alloc_new_buf(&amp;amp;target_proc-&amp;gt;alloc,...&amp;quot;) subgraph queues a transaction to binder_proc, find a thread in binder_proc to handle the transaction and wake it up. If no thread is found, the work is queued to the proc waitqueue.</description>
    </item>
    
    <item>
      <title>4DumpHprof</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/4dumphprof/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/4dumphprof/</guid>
      <description>graph LR subgraph Visit runtime.VisitRoots runtime.heap.VisitObjectsPaused end subgraph suspend ScopedSuspendAll end subgraph Dump DumpHeapClass DumpHeapInstanceObject DumpHeapArray end hprof::DumpHeap--&amp;gt;ScopedSuspendAll hprof::DumpHeap--&amp;gt;runtime.VisitRoots--&amp;gt;Hprof::VisitRoot hprof::DumpHeap--&amp;gt;runtime.heap.VisitObjectsPaused--&amp;gt;DumpHeapObject DumpHeapObject--&amp;gt;obj.VisitReferences DumpHeapObject--&amp;gt;DumpHeapClass DumpHeapObject--&amp;gt;DumpHeapInstanceObject DumpHeapObject--&amp;gt;DumpHeapArray art/runtime/native/dalvik_system_VMDebug.cc
VMDebug_dumpHprofData /* * static void dumpHprofData(String fileName, FileDescriptor fd) * * Cause &amp;#34;hprof&amp;#34; data to be dumped. We can throw an IOException if an * error occurs during file handling. */ static void VMDebug_dumpHprofData(JNIEnv* env, jclass, jstring javaFilename, jint javaFd) { std::string filename; if (javaFilename !</description>
    </item>
    
    <item>
      <title>4startup_dart_framework</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/1startup/4startup_dart_framework/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/1startup/4startup_dart_framework/</guid>
      <description>类设计 runApp main.dart
void main() =&amp;gt; runApp(MyApp()); widgets/binding.dart
void runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() ..attachRootWidget(app) ..scheduleWarmUpFrame(); } WidgetsFlutterBinding.ensureInitialized() /// A concrete binding for applications based on the Widgets framework. /// This is the glue that binds the framework to the Flutter engine.  class WidgetsFlutterBinding extends BindingBase with GestureBinding, ServicesBinding, SchedulerBinding, PaintingBinding, SemanticsBinding, RendererBinding, WidgetsBinding { /// Returns an instance of the [WidgetsBinding], creating and  /// initializing it if necessary. If one is created, it will be a  /// [WidgetsFlutterBinding].</description>
    </item>
    
    <item>
      <title>5LeakCanary2</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/5leakcanary2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/5leakcanary2/</guid>
      <description>Procedure https://square.github.io/leakcanary/fundamentals-how-leakcanary-works/
graph TB Procedure--&amp;gt;|useReferenceQueue|Detect(Detecting retained objects.) Procedure--&amp;gt;|Debug.dump|Dump(Dumping the heap.) Procedure--&amp;gt;|Shark|Analyze(Analyzing the heap.) Procedure--&amp;gt;category(Categorizing leaks.) Module依赖 graph TB leakcanary-android-sample--&amp;gt;leakcanary-android leakcanary-android--&amp;gt;leakcanary-android-core </description>
    </item>
    
    <item>
      <title>6LeakCanary2Analyze</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/6leakcanary2analyze/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/6leakcanary2analyze/</guid>
      <description>Procedure graph TB subgraph binarySearch二分查找 SortedBytesMap end subgraph 广度优先遍历 State.findPathsFromGcRoots:BFS end HeapAnalyzer.analyze--&amp;gt;Hprof.open:HprofFile HeapAnalyzer.analyze--&amp;gt;HprofHeapGraph.indexHprof HeapAnalyzer.analyze--&amp;gt;FindLeakInput.analyzeGraph HprofHeapGraph.indexHprof--&amp;gt;reader.readHprofRecords--&amp;gt;|callback HprofRecord|indexBuilderListener.onHprofRecord--&amp;gt;UnsortedByteEntries(&amp;quot;UnsortedByteEntries,ScatterMap&amp;quot;) HprofHeapGraph.indexHprof--&amp;gt;indexBuilderListener.buildIndex--&amp;gt;|Sort entries by keys|SortedBytesMap--&amp;gt;HprofInMemoryIndex--&amp;gt;HprofHeapGraph FindLeakInput.analyzeGraph--&amp;gt;FindLeakInput.findLeaks FindLeakInput.findLeaks--&amp;gt;State.findPathsFromGcRoots:BFS--&amp;gt;|start by enqueueGcRoots|findObjectById(&amp;quot;graph.findObjectById&amp;quot;)--&amp;gt;readFieldsAndEnqueue Data Flow graph TB HprofFile--&amp;gt;HprofRecord HprofRecord--&amp;gt;UnsortedByteEntries(&amp;quot;UnsortedByteEntries(class,instance,objectArray,primitiveArray)&amp;quot;) UnsortedByteEntries--&amp;gt;|Sort entries by keys|SortedBytesMap(SortedBytesMap: get perform binarySearch) SortedBytesMap--&amp;gt;HprofInMemoryIndex SortedBytesMap--&amp;gt;|get return|ByteSubArray ByteSubArray--&amp;gt;|indexedObjectOrNull|IndexedObject IndexedObject--&amp;gt;|wrapIndexedObject|HeapObject HprofRecord--&amp;gt;ScatterMap(&amp;quot;ScatterMap(hprofStringCache, classNames)&amp;quot;) ScatterMap--&amp;gt;HprofInMemoryIndex HprofInMemoryIndex--&amp;gt;HprofHeapGraph LruCache:objectCache--&amp;gt;|cached when readObjectRecord|HprofHeapGraph //ScatterMap contains: classNames and hprofStringCache  // LRU cache size of 3000 is a sweet spot to balance hits vs memory usage.</description>
    </item>
    
    <item>
      <title>7KOOMSource</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/7koomsource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96/7koomsource/</guid>
      <description>Module Dependencies graph TB demo--&amp;gt;java-oom java-oom--&amp;gt;koom-kwailinker java-oom--&amp;gt;koom-xhook java-oom--&amp;gt;koom-shark LeakDetector Hierarchy graph TB LeakDetector--&amp;gt;ActivityLeakDetector LeakDetector--&amp;gt;NativeAllocationRegistryLeakDetector LeakDetector--&amp;gt;WindowLeakDetector LeakDetector--&amp;gt;BitmapLeakDetector LeakDetector--&amp;gt;FragmentLeakDetector HprofStrip Detail KOOM.init /** * KOOM entry point, make sure be called in the main thread! * * @param application application needed */ public static void init(Application application) { if (koom == null) { koom = new KOOM(application); } koom.start(); } private KOOM(Application application) { internal = new KOOMInternal(application); } public KOOMInternal(Application application) { KUtils.</description>
    </item>
    
    <item>
      <title>AllocRelated</title>
      <link>https://huanle19891345.github.io/en/android/art/alloc_gc/allocrelated/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/alloc_gc/allocrelated/</guid>
      <description>Instruction::NEW_INSTANCE ExecuteSwitchImplCpp template&amp;lt;bool do_access_check, bool transaction_active&amp;gt; void ExecuteSwitchImplCpp(SwitchImplContext* ctx) { switch (inst-&amp;gt;Opcode(inst_data)) { case Instruction::NEW_INSTANCE: { PREAMBLE(); ObjPtr&amp;lt;mirror::Object&amp;gt; obj = nullptr; ObjPtr&amp;lt;mirror::Class&amp;gt; c = ResolveVerifyAndClinit(dex::TypeIndex(inst-&amp;gt;VRegB_21c()), shadow_frame.GetMethod(), self, false, do_access_check); if (LIKELY(c != nullptr)) { if (UNLIKELY(c-&amp;gt;IsStringClass())) { gc::AllocatorType allocator_type = Runtime::Current()-&amp;gt;GetHeap()-&amp;gt;GetCurrentAllocator(); obj = mirror::String::AllocEmptyString&amp;lt;true&amp;gt;(self, allocator_type); } else { obj = AllocObjectFromCode&amp;lt;true&amp;gt;( c.Ptr(), self, Runtime::Current()-&amp;gt;GetHeap()-&amp;gt;GetCurrentAllocator()); } } if (UNLIKELY(obj == nullptr)) { HANDLE_PENDING_EXCEPTION(); } else { obj-&amp;gt;GetClass()-&amp;gt;AssertInitializedOrInitializingInThread(self); // Don&amp;#39;t allow finalizable objects to be allocated during a transaction since these can&amp;#39;t  // be finalized without a started runtime.</description>
    </item>
    
    <item>
      <title>AndFix</title>
      <link>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/andfix/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/andfix/</guid>
      <description>Foo.bar()这种直接调用与反射调用Foo.class.getDeclaredMethod(“bar”).invoke(null) 有什么区别吗？这个问题后续再谈
private native Object invoke(Object receiver, Object[] args, boolean accessible) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException; 这个invoke是一个native方法，它的native实现在 art/runtime/native/java_lang_reflect_Method.cc 里面，这个jni方法最终调用了 art/runtime/reflection.cc 的 InvokeMethod方法：
object InvokeMethod(const ScopedObjectAccessAlreadyRunnable&amp;amp; soa, jobject javaMethod, jobject javaReceiver, jobject javaArgs, bool accessible) { // 略...  mirror::ArtMethod* m = mirror::ArtMethod::FromReflectedMethod(soa, javaMethod); mirror::Class* declaring_class = m-&amp;gt;GetDeclaringClass(); } AndFix的实现里面，也正是使用这个 FromReflectedMethod 方法拿到Java层Method对应native层的ArtMethod指针，然后执行替换的
首先简单介绍下ART上的方法调用原理（本文不讨论解释模式，所有entrypoint均指compiled_code_entry_point)。在ART中，每一个Java方法在虚拟机（注：ART与虚拟机虽有细微差别，但本文不作区分，两者含义相同，下同）内部都由一个ArtMethod对象表示（native层，实际上是一个C++对象），这个native 的 ArtMethod对象包含了此Java方法的所有信息，比如名字，参数类型，方法本身代码的入口地址（entrypoint)等；暂时放下trampoline以及interpreter和jit不谈，一个Java方法的执行非常简单：
 想办法拿到这个Java方法所代表的ArtMethod对象 取出其entrypoint，然后跳转到此处开始执行  AndFix就是基于这个原理来做热修复的，Sophix 对这个方案做了一些改进，也即整体替换，不过原理上都一样。二者在替换方法之后把原方法直接丢弃，因此无法实现AOP
 《深入探索Android热修复技术原理》&amp;ndash;Sophix团队
两种情况不适用：
 引起原有类中发生结构变化的修改 修复了非静态方法会被反射调用  参考 ART深度探索开篇：从Method Hook谈起
我为Dexposed续一秒——论ART上运行时 Method AOP实现</description>
    </item>
    
    <item>
      <title>AndFixSource</title>
      <link>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/andfixsource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/andfixsource/</guid>
      <description>核心方法addReplaceMethod(Method src, Method dest)
AndFixManager.java fix public synchronized void fix(String patchPath) { fix(new File(patchPath), mContext.getClassLoader(), null); } //加载补丁包中所有类所有方法,如果拥有注解methodReplace，则触发replaceMethod public synchronized void fix(File file, ClassLoader classLoader, List&amp;lt;String&amp;gt; classes) { final DexFile dexFile = DexFile.loadDex(file.getAbsolutePath(), optfile.getAbsolutePath(), Context.MODE_PRIVATE); ClassLoader patchClassLoader = new ClassLoader(classLoader) {//以当前classLoader作为parentClassLoader优先查找 	@Override protected Class&amp;lt;?&amp;gt; findClass(String className) throws ClassNotFoundException { Class&amp;lt;?&amp;gt; clazz = dexFile.loadClass(className, this); if (clazz == null &amp;amp;&amp;amp; className.startsWith(&amp;#34;com.alipay.euler.andfix&amp;#34;)) { return Class.forName(className);// annotation’s class 	// not found 	} if (clazz == null) { throw new ClassNotFoundException(className); } return clazz; } }; Enumeration&amp;lt;String&amp;gt; entrys = dexFile.</description>
    </item>
    
    <item>
      <title>Android_N混合编译与对热补丁影响解析</title>
      <link>https://huanle19891345.github.io/en/android/art/2%E7%B1%BB%E5%8A%A0%E8%BD%BD/android_n%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AF%B9%E7%83%AD%E8%A1%A5%E4%B8%81%E5%BD%B1%E5%93%8D%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/2%E7%B1%BB%E5%8A%A0%E8%BD%BD/android_n%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91%E4%B8%8E%E5%AF%B9%E7%83%AD%E8%A1%A5%E4%B8%81%E5%BD%B1%E5%93%8D%E8%A7%A3%E6%9E%90/</guid>
      <description>Android_N混合编译与对热补丁影响解析.md
入口文件位于dex2oat.cc中，在这里并不想贴具体的调用函数，简单的描述一下流程：若dex2oat参数中有输入profile文件，会读取profile中的数据。与以往不同的是，这里不仅会根据profile文件来生成base.odex文件，同时还会生成称为app_image的base.art文件。与boot.art类似，base.art文件主要为了加快应用的对“热代码”的加载与缓存。
那么我们就剩下最后一个问题，app image文件是什么时候被加载，并且为什么它会影响热补丁的机制？
###App image文件的加载 在apk启动时我们需要加载应用的oat文件以及可能存在的app image文件，它的大致流程如下：
 通过OpenDexFilesFromOat加载oat时，若app image存在，则通过调用OpenImageSpace函数加载； 在加载app image文件时，通过UpdateAppImageClassLoadersAndDexCaches函数，将art文件中的dex_cache中dex的所有class插入到ClassTable，同时将method更新到dex_cache; 在类加载时，使用时ClassLinker::LookupClass会先从ClassTable中去查找，找不到时才会走到DefineClass中。   非常简单的说，app image的作用是记录已经编译好的“热代码”，并且在启动时一次性把它们加载到缓存。预先加载代替用时查找以提升应用的性能，到这里我们终于明白为什么base.art会影响热补丁的机制。
无论是使用插入pathlist还是parent classloader的方式，若补丁修改的class已经存在与app image，它们都是无法通过热补丁更新的。它们在启动app时已经加入到PathClassLoader的ClassTable中，系统在查找类时会直接使用base.apk中的class。
最后我们再来总结一下Android N混合编译运行的整个流程，它就像一个小型生态系统那样和谐。
##Android N上热补丁的出路 假设base.art文件在补丁前已经存在，这里存在三种情况：
 补丁修改的类都不app image中；这种情况是最理想的，此时补丁机制依然有效； 补丁修改的类部分在app image中；这种情况我们只能更新一部分的类，此时是最危险的。一部分类是新的，一部分类是旧的，app可能会出现地址错乱而出现crash。 补丁修改的类全部在app image中；这种情况只是造成补丁不生效，app并不会因此造成crash。  ###运行时替换PathClassLoader方案 事实上，App image中的class是插入到PathClassloader中的ClassTable中。假设我们完全废弃掉PathClassloader，而采用一个新建Classloader来加载后续的所有类，即可达到将cache无用化的效果。
实际代码对应AndroidNClassLoader中的findClass和findLibrary方法，通过调用super.findClass和super.findLibrary来避开调用原本应用PathClassLoader的find方法，原本的findClass方法会先查找classTable造成修复的class无法加载到</description>
    </item>
    
    <item>
      <title>AndroidPlugin</title>
      <link>https://huanle19891345.github.io/en/android/gradlejenkins/androidplugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/gradlejenkins/androidplugin/</guid>
      <description>调试android plugin源码 在buildSrc下的build.gradle中添加如下依赖，用来查看其源码并debug
dependencies { implementation(&amp;#34;com.android.tools.build:gradle:3.2.1&amp;#34;) } 源码为于External Libraries中:
Gradle: gradle-3.2.1 其META-INF中定义了多个android plugin的入口Class如com.android.application的入口com.android.build.gradle.AppPlugin
Gradle: gradle-api-3.2.1 AppExtension定义在这
Gradle: builder-3.2.1，d8,r8源码都在此处
调试gradle源码 而gradle源码(gradle/wrapper/gradle-wrapper.properties中定义的gradle版本)
distributionUrl=https\://services.gradle.org/distributions/gradle-5.6.4-all.zip 位于External Libraries中:
Gradle: gradle-api-5.6.4</description>
    </item>
    
    <item>
      <title>android代码自测</title>
      <link>https://huanle19891345.github.io/en/android/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/android%E4%BB%A3%E7%A0%81%E8%87%AA%E6%B5%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95/android%E4%BB%A3%E7%A0%81%E8%87%AA%E6%B5%8B/</guid>
      <description>TDD https://www.raywenderlich.com/7109-test-driven-development-tutorial-for-android-getting-started
Android应用功能测试 https://developer.android.com/training/testing/
编写自测代码的好处 Testing also provides you with the following advantages:
  Rapid feedback on failures.&amp;ndash;解放双手，提升测试效率
  Early failure detection in the development cycle. &amp;ndash;开发提前发现错误
  Safer code refactoring, letting you optimize code without worrying about regressions. &amp;ndash;保证重构不影响功能，很关键
  Stable development velocity, helping you minimize technical debt. &amp;ndash;提前发现错误漏洞，提前纠正不合理的设计
   测试驱动开发概念，迭代开发工作流 When developing a feature iteratively, you start by either writing a new test or by adding cases and assertions to an existing unit test.</description>
    </item>
    
    <item>
      <title>Android打包</title>
      <link>https://huanle19891345.github.io/en/android/gradlejenkins/android%E6%89%93%E5%8C%85/android%E6%89%93%E5%8C%85/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/gradlejenkins/android%E6%89%93%E5%8C%85/android%E6%89%93%E5%8C%85/</guid>
      <description>打包过程 aapt-&amp;gt;aidl -&amp;gt; javac-&amp;gt; dx(dex)-&amp;gt; apkbuilder-&amp;gt; jarsigner-&amp;gt; zipalign
步骤中提到的工具如下表：
   名称 功能介绍 在操作系统中的路径     aapt Android资源打包工具 ${ANDROID_SDK_HOME}/platform-tools/appt   aidl Android接口描述语言转化为.java文件的工具 ${ANDROID_SDK_HOME}/platform-tools/aidl   javac Java Compiler ${JDK_HOME}/javac或/usr/bin/javac   dex 转化.class文件为Davik VM能识别的.dex文件 ${ANDROID_SDK_HOME}/platform-tools/dx   apkbuilder 生成apk包 ${ANDROID_SDK_HOME}/tools/opkbuilder   jarsigner .jar文件的签名工具 ${JDK_HOME}/jarsigner或/usr/bin/jarsigner   zipalign 字节码对齐工具 ${ANDROID_SDK_HOME}/tools/zipalign    第一步：打包资源文件，生成R.java文件 编译R.java类需要用到AndroidSDK提供的aapt工具,aapt参数众多,以下是主要参数:
-d one or more device assets to include, separated by commas</description>
    </item>
    
    <item>
      <title>AnimatorSource</title>
      <link>https://huanle19891345.github.io/en/android/ui/%E5%8A%A8%E7%94%BB/animatorsource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/ui/%E5%8A%A8%E7%94%BB/animatorsource/</guid>
      <description>Animator类设计 插值器和估值器设计 参考doanimationframe
classDiagram class TimeInterpolator { +getInterpolation(float input) float } class BaseInterpolator { -int mChangingConfiguration } class LinearInterpolator { +getInterpolation(float input) float } class AccelerateDecelerateInterpolator { +getInterpolation(float input) float } TimeInterpolator&amp;lt;|--Interpolator Interpolator &amp;lt;|-- BaseInterpolator BaseInterpolator &amp;lt;|-- LinearInterpolator BaseInterpolator&amp;lt;|-- AccelerateDecelerateInterpolator class Keyframes{ setEvaluator(TypeEvaluator evaluator) } class FloatKeyframes{ getFloatValue(float fraction) float } class KeyframeSet { TypeEvaluator mEvaluator } class FloatKeyframeSet { getFloatValue(float fraction) float } class TypeEvaluator~T~{ +evaluate(float fraction, T startValue, T endValue) T } Keyframes&amp;lt;|--FloatKeyframes Keyframes&amp;lt;|--KeyframeSet KeyframeSet&amp;lt;|--FloatKeyframeSet KeyframeSet--*TypeEvaluator~T~ 图解 sequenceDiagram AnimatorSet-&amp;gt;&amp;gt;AnimatorSet: start participant Animator participant FloatPropertyValuesHolder activate AnimatorSet AnimatorSet-&amp;gt;&amp;gt;AnimationHandler: handler.</description>
    </item>
    
    <item>
      <title>app签名</title>
      <link>https://huanle19891345.github.io/en/android/%E5%AE%89%E5%85%A8/app%E7%AD%BE%E5%90%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E5%AE%89%E5%85%A8/app%E7%AD%BE%E5%90%8D/</guid>
      <description>ECDSA数字签名算法
Android N Signature Scheme v2 渠道打包
如果您使用 APK Signature Scheme v2 签署您的应用，并对应用进行了进一步更改，则应用的签名将无效。出于这个原因，请在使用 APK Signature Scheme v2 签署您的应用之前、而非之后使用 zipalign 等工具。 如需了解详细信息，请阅读相关的 Android Studio 文档，这些文档介绍了如何在 Android Studio 中签署应用以及如何使用 Android Plugin for Gradle 为签署应用配置构建文件。
APK文件格式 apk 本身是个 zip 格式, 格式可以参考http://blog.sina.com.cn/s/blog_4c3591bd0100zzm6.html.
apksigner https://www.jianshu.com/p/4a07d902066f
apksigner.bat sign &amp;ndash;ks 签名文件 &amp;ndash;ks-pass 密码 &amp;ndash;ks-key-alias 别名
Sdk\build-tools\28.0.3&amp;gt;apksigner.bat sign &amp;ndash;help
Sdk\build-tools\28.0.3\lib\apksigner.jar
–ks 你的jks路径 //jks签名证书路径
–ks-key-alias 你的alias //生成jks时指定的alias
–ks-pass pass:你的密码 //KeyStore密码
–key-pass pass:你的密码 //签署者的密码，即生成jks时指定alias对应的密码
–out output.apk //输出路径
input.apk //被签名的apk
示例：</description>
    </item>
    
    <item>
      <title>ART_Lock</title>
      <link>https://huanle19891345.github.io/en/android/art/art_lock/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/art_lock/</guid>
      <description>ObjectLock ObjectLock&amp;lt;mirror::Class&amp;gt; lock(self, klass); art/runtime/object_lock.cc
ObjectLock template &amp;lt;typename T&amp;gt; ObjectLock&amp;lt;T&amp;gt;::ObjectLock(Thread* self, Handle&amp;lt;T&amp;gt; object) : self_(self), obj_(object) { CHECK(object != nullptr); obj_-&amp;gt;MonitorEnter(self_); } ~ObjectLock template &amp;lt;typename T&amp;gt; ObjectLock&amp;lt;T&amp;gt;::~ObjectLock() { obj_-&amp;gt;MonitorExit(self_); } art/runtime/mirror/object-inl.h
MonitorEnter inline mirror::Object* Object::MonitorEnter(Thread* self) { return Monitor::MonitorEnter(self, this, /*trylock*/false); } art/runtime/monitor.cc
MonitorEnter mirror::Object* Monitor::MonitorEnter(Thread* self, mirror::Object* obj, bool trylock) { StackHandleScope&amp;lt;1&amp;gt; hs(self); Handle&amp;lt;mirror::Object&amp;gt; h_obj(hs.NewHandle(obj)); while (true) { // We initially read the lockword with ordinary Java/relaxed semantics. When stronger  // semantics are needed, we address it below.</description>
    </item>
    
    <item>
      <title>ART启动流程</title>
      <link>https://huanle19891345.github.io/en/android/art/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/art%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/art%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/</guid>
      <description>graph TB Init(&amp;quot;init进程通过解析配置脚本&amp;quot;)--&amp;gt;|fork子进程运行Zygote服务|AppProcess(&amp;quot;/system/bin/app_process:frameworks\base\cmds\app_process\app_main.cc&amp;quot;) AppProcess--&amp;gt;JniInvocation::Init AppProcess--&amp;gt;AndroidRuntime::StartVm AppProcess--&amp;gt;C调用Java层ZygoteInit的main方法 zygoteinit.main后续流程参考zygotesource
frameworks\base\cmds\app_process\app_main.cpp
int main(int argc, char* const argv[]) { if (zygote) { runtime.start(&amp;#34;com.android.internal.os.ZygoteInit&amp;#34;, args, zygote); } else if (className) { runtime.start(&amp;#34;com.android.internal.os.RuntimeInit&amp;#34;, args, zygote); } else { fprintf(stderr, &amp;#34;Error: no class name or --zygote supplied.\n&amp;#34;); app_usage(); LOG_ALWAYS_FATAL(&amp;#34;app_process: no class name or --zygote supplied.&amp;#34;); return 10; } void AndroidRuntime::start(const char* className, const Vector&amp;lt;String8&amp;gt;&amp;amp; options, bool zygote){ ...... JniInvocation jni_invocation; jni_invocation.Init(NULL);//1. 它将加载ART虚拟机的核心动态库。  JNIEnv* env; if (startVm(&amp;amp;mJavaVM, &amp;amp;env, zygote) !</description>
    </item>
    
    <item>
      <title>ASM访客者模式</title>
      <link>https://huanle19891345.github.io/en/android/aop/asm%E8%AE%BF%E5%AE%A2%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/aop/asm%E8%AE%BF%E5%AE%A2%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>ASM访客者 is = new FileInputStream(classFile); ClassReader classReader = new ClassReader(is); ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS); ClassVisitor classVisitor = new TraceClassAdapter(Opcodes.ASM5, classWriter); classReader.accept(classVisitor, ClassReader.EXPAND_FRAMES); is.close(); if (output.isDirectory()) { os = new FileOutputStream(changedFileOutput); } else { os = new FileOutputStream(output); } os.write(classWriter.toByteArray()); os.close(); classReader用来读取来自inputstream的class字节码，并在遍历到类和方法时分别调用到visit和visitMethod方法，参数为解析出的信息
graph LR FileInputStream--&amp;gt;classReader classReader--&amp;gt;ClassVisitor ClassVisitor--&amp;gt;ClassWriter ClassWriter--&amp;gt;FileOutputStream @Override public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) { 在方法开始处插桩AppMethodBeat.i(methodId)方法
@Override protected void onMethodEnter() { TraceMethod traceMethod = collectedMethodMap.</description>
    </item>
    
    <item>
      <title>BinderDeath</title>
      <link>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/binder/binderdeath/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/binder/binderdeath/</guid>
      <description>原理总结 Binder死亡通知机制之linkToDeath
UnlinkToDeath流程类似，参考上文，不做记录
死亡通知是为了让Bp端(客户端进程)进能知晓Bn端(服务端进程)的生死情况，当Bn端进程死亡后能通知到Bp端。
 定义：AppDeathRecipient是继承IBinder::DeathRecipient类，主要需要实现其binderDied()来进行死亡通告。 注册：binder-&amp;gt;linkToDeath(AppDeathRecipient)是为了将AppDeathRecipient死亡通知注册到Binder上。  Bp端只需要覆写binderDied()方法，实现一些后尾清除类的工作，则在Bn端死掉后，会回调binderDied()进行相应处理。
linkToDeath android_os_BinderProxy_linkToDeath static void android_os_BinderProxy_linkToDeath(JNIEnv* env, jobject obj, jobject recipient, jint flags) { //获取BinderProxy.mObject成员变量值, 即BpBinder对象  IBinder* target = (IBinder*)env-&amp;gt;GetLongField(obj, gBinderProxyOffsets.mObject); sp&amp;lt;JavaDeathRecipient&amp;gt; jdr = new JavaDeathRecipient(env, recipient, list); //建立死亡通知[见小节2.2]  status_t err = target-&amp;gt;linkToDeath(jdr, NULL, flags); }  获取DeathRecipientList: 其成员变量mList记录该BinderProxy的JavaDeathRecipient列表信息；  一个BpBinder可以注册多个死亡回调   创建JavaDeathRecipient: 继承于IBinder::DeathRecipient  linkToDeath status_t BpBinder::linkToDeath( const sp&amp;lt;DeathRecipient&amp;gt;&amp;amp; recipient, void* cookie, uint32_t flags) { IPCThreadState* self = IPCThreadState::self(); self-&amp;gt;requestDeathNotification(mHandle, this); self-&amp;gt;flushCommands(); } requestDeathNotification status_t IPCThreadState::requestDeathNotification(int32_t handle, BpBinder* proxy) { mOut.</description>
    </item>
    
    <item>
      <title>Binder原理</title>
      <link>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/binder/binder%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/binder/binder%E5%8E%9F%E7%90%86/</guid>
      <description>写给 android 应用工程师的 binder 原理剖析
架构设计分析（三）Android 9.0 Binder机制
彻底理解Android Binder通信架构 Android 6.0
Binder系列5—注册服务(addService)
Android IPC: Part 2 - Binder and Service Manager Perspective
深入理解Binder通信原理及面试问题
Binder | 内存拷贝的本质和变迁
Linux 背景知识 传统 IPC 通信原理 Binder IPC 原理 BinderProcedure flow struct binder_write_read transact total </description>
    </item>
    
    <item>
      <title>Bitmap</title>
      <link>https://huanle19891345.github.io/en/android/system/bitmap/bitmap/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/bitmap/bitmap/</guid>
      <description>Bitmap像素存储 03 | 内存优化（上）：4GB内存时代，再谈内存优化
Android Bitmap变迁与原理解析（4.x-8.x）
Bitmap: 从出生到死亡
Bitmap创建 Java 层的创建 Bitmap 的所有 API 进入到 Native 层后，全都会走如下这四个步骤。
 ==资源转换== - 这一步将 Java 层传来的不同类型的资源转换成解码器可识别的数据类型 ==内存分配== - 分配内存时会考虑是否复用 Bitmap、是否缩放 Bitmap 等因素 ==图片解码== - 实际的解码工作由第三方库完成，解码结果填在上一步分配的内存中。注，Bitmap.createBitmap() 和 Bitmap.copy() 创建的 Bitmap 不需要进行图片解码 ==创建对象== - 这一步将包含解码数据的内存块包装成 Java 层的 android.graphics.Bitmap 对象，方便 App 使用  1. 资源转换 2. 内存分配 3. 图片解码 创建Java对象 Bitmap销毁 Bitmap.recycle() 自动释放：NativeAllocationRegistry NativeAllocationRegistry 用于将 native 内存跟 Java 对象关联，并将它们注册到 Java 运行时。注册 Java 对象关联的 native 内存有几个好处：
 Java 运行时在 GC 调度时可考虑 native 内存状态 Java 运行时在 Java 对象变得不可达时可以使用用户提供的函数来自动清理 native 内存  当 Java 层 Bitmap 对象不可达后关联的 native 内存会由 nativeGetNativeFinalizer() 指定的方法来回收</description>
    </item>
    
    <item>
      <title>BitmapSource</title>
      <link>https://huanle19891345.github.io/en/android/system/bitmap/bitmapsource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/bitmap/bitmapsource/</guid>
      <description>类设计 NativeAllocationRegistry procedure ART reclaim NativeAllocationRegistry procedure(only object which will be reclaim(GC not reachable) would be enqueued)
graph TB ReferenceQueueDaemon.runInernal--&amp;gt;ReferenceQueue.enqueuePending ReferenceQueue.enqueuePending--&amp;gt;ReferenceQueue.enqueueLocked ReferenceQueue.enqueueLocked--&amp;gt;Cleaner.clean Cleaner.clean--&amp;gt;CleanerChunk.run CleanerChunk.run--&amp;gt;NativeAllocationRegistry.applyFreeFunction ImageDecoder decodeDrawable public static Drawable decodeDrawable(@NonNull Source src, @NonNull OnHeaderDecodedListener listener) throws IOException { return decodeDrawableImpl(src, listener); } decodeDrawableImpl private static Drawable decodeDrawableImpl(@NonNull Source src, @Nullable OnHeaderDecodedListener listener) throws IOException { ImageDecoder decoder = src.createImageDecoder() decoder.mSource = src; decoder.callHeaderDecoded(listener, src); Bitmap bm = decoder.decodeBitmapInternal(); return new BitmapDrawable(res, bm); } decodeBitmapInternal private Bitmap decodeBitmapInternal() throws IOException { checkState(); return nDecodeBitmap(mNativePtr, this, mPostProcessor !</description>
    </item>
    
    <item>
      <title>BlockingQueue</title>
      <link>https://huanle19891345.github.io/en/java/blockingqueue/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/java/blockingqueue/</guid>
      <description>https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/BlockingQueue.html
BlockingQueue methods come in four forms, with different ways of handling operations that cannot be satisfied immediately, but may be satisfied at some point in the future:
 one throws an exception, the second returns a special value (either null or false, depending on the operation), the third blocks the current thread indefinitely until the operation can succeed, and the fourth blocks for only a given maximum time limit before giving up.</description>
    </item>
    
    <item>
      <title>Compose</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/compose/compose/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/compose/compose/</guid>
      <description>Jetpack Compose Beta 版现已发布！
https://developer.android.google.cn/jetpack/compose/documentation
https://github.com/android/compose-samples
深入详解 Jetpack Compose | 实现原理
jetpack compse原理解析
View 嵌套太深会卡？来用 Jetpack Compose，随便套
State In Compose @Composable fun HelloScreen() { var name by rememberSaveable { mutableStateOf(&amp;#34;&amp;#34;) } HelloContent(name = name, onNameChange = { name = it }) } @Composable fun HelloContent(name: String, onNameChange: (String) -&amp;gt; Unit) { Column(modifier = Modifier.padding(16.dp)) { Text( text = &amp;#34;Hello, $name&amp;#34;, modifier = Modifier.padding(bottom = 8.dp), style = MaterialTheme.typography.h5 ) OutlinedTextField( value = name, onValueChange = { onNameChange(it) }, label = { Text(&amp;#34;Name&amp;#34;) } ) } } Compose和DataBinding State对应 graph TB subgraph DataBinding ViewAttribute--&amp;gt;|event|BackData BackData--&amp;gt;|state|ViewAttribute end subgraph Compose HelloContent--&amp;gt;|event|HelloScreen HelloScreen(&amp;quot;HelloScreen(stateful)&amp;quot;)--&amp;gt;|state|HelloContent(&amp;quot;HelloContent(stateless)&amp;quot;) end Key Point: When hoisting state, there are three rules to help you figure out where state should go:</description>
    </item>
    
    <item>
      <title>ComposeSource</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/compose/composesource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/compose/composesource/</guid>
      <description>View层次结构 graph TB contentFrameLayout--&amp;gt;ComposeView--&amp;gt;AndroidComposeView--&amp;gt;ViewLayerContainer ViewLayerContainer--&amp;gt;ViewLayer1 ViewLayerContainer--&amp;gt;ViewLayer2 ViewLayerContainer--&amp;gt;ViewLayer3 ViewLayerContainer--&amp;gt;ViewLayer... View类继承结构 classDiagram class ComposeView { -val content } class AndroidComposeView { +onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) } class OwnedLayer { &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; +resize(size: IntSize) +drawLayer(canvas: Canvas) +updateDisplayList() +invalidate() } class GraphicLayerInfo { &amp;lt;&amp;lt;interface&amp;gt; +layerId: Long } View&amp;lt;|--ViewGroup ViewGroup&amp;lt;|--AbstractComposeView AbstractComposeView&amp;lt;|--ComposeView ViewGroup&amp;lt;|--AndroidComposeView ViewGroup&amp;lt;|--ViewLayerContainer View&amp;lt;|--ViewLayer OwnedLayer&amp;lt;|--ViewLayer OwnedLayer&amp;lt;|--RenderNodeLayer GraphicLayerInfo&amp;lt;|--OwnedLayer 图解 sequenceDiagram ComposeView-&amp;gt;&amp;gt;ComposeView: onAttachedToWindow activate ComposeView ComposeView-&amp;gt;&amp;gt;ComposeView: ensureCompositionCreated activate ComposeView deactivate ComposeView ComposeView-&amp;gt;&amp;gt;ComposeView: setOnViewTreeOwnersAvailable{闭包} activate ComposeView Note right of ComposeView: AndroidComposeView.</description>
    </item>
    
    <item>
      <title>Coroutines</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/coroutines/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/coroutines/</guid>
      <description>https://developer.android.com/topic/libraries/architecture/coroutines
理解协程、livedata 和 flow
协程 flow 最佳实践 | 基于 android 开发者峰会应用
如果您想将一个基于回调的流 API 转换为使用 Flow，您可以使用 channelFlow 函数 (当然也可以使用 callbackFlow，它们都基于相同的实现)。
  Flow 非常适合需要开始/停止数据的产生来匹配观察者的场景。
  如果生产者和消费者的生命周期不同或者彼此完全独立运行时，请使用 BroadcastChannel。
  架构思考 graph LR archetecture--&amp;gt;|Async|Scope subgraph AutoCancel Scope--&amp;gt;StructuredConcurrency end archetecture--&amp;gt;|LiveData|UnMutableLiveDataExposeToView--&amp;gt;LiveDataCoroutine archetecture--&amp;gt;|EmitMultiData|Flow oneshot--&amp;gt;suspendCancellableCoroutine multishots--&amp;gt;callbackFlow lifecycle 从 API 1 开始，处理 Activity 的生命周期 (lifecycle) 就是个老大难的问题，基本上开发者们都看过这两张生命周期流程图:
△ Activity 生命周期流程图
随着 Fragment 的加入，这个问题也变得更加复杂:
△ Fragment 生命周期流程图
而开发者们面对这个挑战，给出了非常稳健的解决方案: 分层架构。
分层架构 △ 表现层 (Presentation Layer)、域层 (Domain Layer) 和数据层 (Data Layer)</description>
    </item>
    
    <item>
      <title>Databinding</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/databinding/databinding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/databinding/databinding/</guid>
      <description>类设计 在liveData数据变化回调onChanged之后，触发requestRebind,在executeBindings时根据dirtyFlags通过BindingAdapter方法刷新View属性
基于androidx.databinding:databinding-runtime:4.0.1
DataBindingUtil private static DataBinderMapper sMapper = new DataBinderMapperImpl(); private static DataBindingComponent sDefaultComponent = null; setContentView public static &amp;lt;T extends ViewDataBinding&amp;gt; T setContentView(@NonNull Activity activity, int layoutId) { return setContentView(activity, layoutId, sDefaultComponent); } public static &amp;lt;T extends ViewDataBinding&amp;gt; T setContentView(@NonNull Activity activity, int layoutId, @Nullable DataBindingComponent bindingComponent) { activity.setContentView(layoutId); View decorView = activity.getWindow().getDecorView(); ViewGroup contentView = (ViewGroup) decorView.findViewById(android.R.id.content); return bindToAddedViews(bindingComponent, contentView, 0, layoutId); } bindToAddedViews private static &amp;lt;T extends ViewDataBinding&amp;gt; T bindToAddedViews(DataBindingComponent component, ViewGroup parent, int startChildren, int layoutId) { final int endChildren = parent.</description>
    </item>
    
    <item>
      <title>dex2oat</title>
      <link>https://huanle19891345.github.io/en/android/art/1%E7%B1%BB%E7%BC%96%E8%AF%91/dex2oat/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/1%E7%B1%BB%E7%BC%96%E8%AF%91/dex2oat/</guid>
      <description>dex2oat原理图 sequenceDiagram installd-&amp;gt;&amp;gt;dex2oat: main activate dex2oat dex2oat-&amp;gt;&amp;gt;dex2oat: art:dex2oat() activate dex2oat dex2oat-&amp;gt;&amp;gt;dex2oat: Setup() Note right of dex2oat: MethodVerified回调时deVirtual deactivate dex2oat activate dex2oat dex2oat-&amp;gt;&amp;gt;dex2oat: CompileImage() Note right of dex2oat: 三种编译处理模式:dex2dex,jni,dex2Native activate dex2oat dex2oat-&amp;gt;&amp;gt;dex2oat: LoadClassProfileDescriptors() deactivate dex2oat activate dex2oat dex2oat-&amp;gt;&amp;gt;dex2oat: Compile() dex2oat-&amp;gt;&amp;gt;CompilerDriver: CompileAll CompilerDriver-&amp;gt;&amp;gt;CompilerDriver: PreCompile activate CompilerDriver Note right of CompilerDriver: Resolve,Verify,InitializeClasses deactivate CompilerDriver activate CompilerDriver CompilerDriver-&amp;gt;&amp;gt;CompilerDriver: Compile() activate CompilerDriver CompilerDriver-&amp;gt;&amp;gt;CompilerDriver: CompileDexFile() Note right of CompilerDriver: 多线程编译,传递dex中的class_ids索引 activate CompilerDriver CompilerDriver-&amp;gt;&amp;gt;CompilerDriver: CompileClassVisitor activate CompilerDriver CompilerDriver-&amp;gt;&amp;gt;CompilerDriver: CompileMethod() Note right of CompilerDriver: AddCompiledMethod to CompilerDriver deactivate CompilerDriver deactivate CompilerDriver deactivate CompilerDriver deactivate CompilerDriver deactivate dex2oat deactivate dex2oat deactivate dex2oat dex2oat-&amp;gt;&amp;gt;dex2oat: WriteOatFiles() Note right of dex2oat: 输出.</description>
    </item>
    
    <item>
      <title>dex2oat介绍</title>
      <link>https://huanle19891345.github.io/en/android/art/1%E7%B1%BB%E7%BC%96%E8%AF%91/dex2oat%E4%BB%8B%E7%BB%8D/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/1%E7%B1%BB%E7%BC%96%E8%AF%91/dex2oat%E4%BB%8B%E7%BB%8D/</guid>
      <description>pre-compilation的好处 graph LR AOT--&amp;gt;Fast AOT--&amp;gt;cleanMemory Code pre-compilation: We pre-compile all the hot code. When the apps execute, the most important parts of the code are already optimized and ready to be natively executed. The app no longer needs to wait for the JIT compiler to kick in.
The benefit is that the code is mapped as clean memory (compared to the JIT dirty memory) which improves the overall memory efficiency. The clean memory can be released by the kernel when under memory pressure while the dirty memory cannot, lessening the chances that the kernel will kill the app.</description>
    </item>
    
    <item>
      <title>Dex文件格式</title>
      <link>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/dex%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/dex%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/</guid>
      <description>Dex文件格式 https://source.android.com/devices/tech/dalvik/dex-format
File layout
   名称 格式 说明     header header_item 标头   string_ids string_id_item[] 字符串标识符列表。这些是此文件使用的所有字符串的标识符，用于内部命名（例如类型描述符）或用作代码引用的常量对象。此列表必须使用 UTF-16 代码点值按字符串内容进行排序（不采用语言区域敏感方式），且不得包含任何重复条目。   type_ids type_id_item[] 类型标识符列表。这些是此文件引用的所有类型（类、数组或原始类型）的标识符（无论文件中是否已定义）。此列表必须按 string_id 索引进行排序，且不得包含任何重复条目。   proto_ids proto_id_item[] 方法原型标识符列表。这些是此文件引用的所有原型的标识符。此列表必须按返回类型（按 type_id 索引排序）主要顺序进行排序，然后按参数列表（按 type_id 索引排序的各个参数，采用字典排序方法）进行排序。该列表不得包含任何重复条目。   field_ids field_id_item[] 字段标识符列表。这些是此文件引用的所有字段的标识符（无论文件中是否已定义）。此列表必须进行排序，其中定义类型（按 type_id 索引排序）是主要顺序，字段名称（按 string_id 索引排序）是中间顺序，而类型（按 type_id 索引排序）是次要顺序。该列表不得包含任何重复条目。   method_ids method_id_item[] 方法标识符列表。这些是此文件引用的所有方法的标识符（无论文件中是否已定义）。此列表必须进行排序，其中定义类型（按 type_id 索引排序）是主要顺序，方法名称（按 string_id 索引排序）是中间顺序，而方法原型（按 proto_id 索引排序）是次要顺序。该列表不得包含任何重复条目。   class_defs class_def_item[] 类定义列表。这些类必须进行排序，以便所指定类的超类和已实现的接口比引用类更早出现在该列表中。此外，对于在该列表中多次出现的同名类，其定义是无效的。   call_site_ids call_site_id_item[] 调用站点标识符列表。这些是此文件引用的所有调用站点的标识符（无论文件中是否已定义）。此列表必须按 call_site_off 以升序进行排序。   method_handles method_handle_item[] 方法句柄列表。此文件引用的所有方法句柄的列表（无论文件中是否已定义）。此列表未进行排序，而且可能包含将在逻辑上对应于不同方法句柄实例的重复项。   data ubyte[] 数据区，包含上面所列表格的所有支持数据。不同的项有不同的对齐要求；如有必要，则在每个项之前插入填充字节，以实现所需的对齐效果。   link_data ubyte[] 静态链接文件中使用的数据。本文档尚未指定本区段中数据的格式。此区段在未链接文件中为空，而运行时实现可能会在适当的情况下使用这些数据。    Dalvik-Bytecode https://source.</description>
    </item>
    
    <item>
      <title>DI</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/di/di/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/di/di/</guid>
      <description>依赖注入进化过程 graph LR HardCode(HardCodeDependency)--&amp;gt;|进化|ServiceLocator HardCode--&amp;gt;|进化|ManualDI--&amp;gt;|进化|Dagger subgraph AutomatedDI Dagger--&amp;gt;Hilt end Dependency injection in Android Dependency injection (DI) is a technique widely used in programming and well suited to Android development. By following the principles of DI, you lay the groundwork for good app architecture.
Implementing dependency injection provides you with the following advantages:
 Reusability of classes and decoupling of dependencies: It&amp;rsquo;s easier to swap out implementations of a dependency. Code reuse is improved because of inversion of control, and classes no longer control how their dependencies are created, but instead work with any configuration.</description>
    </item>
    
    <item>
      <title>ELF文件结构</title>
      <link>https://huanle19891345.github.io/en/android/ndk/elf%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/ndk/elf%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</guid>
      <description>文件结构 &amp;laquo;深入理解Android：Java虚拟机ART&amp;raquo;&amp;ndash;elf章的内容
As you can see from the description above, an ELF file consists of two sections – an ELF header, and file data. The file data section can consist of a program header table describing zero or more segments, a section header table describing zero or more sections, that is followed by data referred to by entries from the program header table, and the section header table. ==Each segment contains information that is necessary for run-time execution of the file, while sections contain important data for linking and relocation==.</description>
    </item>
    
    <item>
      <title>Engine</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/engine/engine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/engine/engine/</guid>
      <description>window.dart lib/ui
/// Requests that, at the next appropriate opportunity, the [onBeginFrame]  /// and [onDrawFrame] callbacks be invoked.  ///  /// See also:  ///  /// * [SchedulerBinding], the Flutter framework class which manages the  /// scheduling of frames.  void scheduleFrame() native &amp;#39;PlatformConfiguration_scheduleFrame&amp;#39;; lib/ui/window/platform_configuration.cc
PlatformConfiguration void PlatformConfiguration::RegisterNatives( tonic::DartLibraryNatives* natives) { natives-&amp;gt;Register({ {&amp;#34;PlatformConfiguration_defaultRouteName&amp;#34;, DefaultRouteName, 1, true}, {&amp;#34;PlatformConfiguration_scheduleFrame&amp;#34;, ScheduleFrame, 1, true}, {&amp;#34;PlatformConfiguration_sendPlatformMessage&amp;#34;, _SendPlatformMessage, 4, true}, {&amp;#34;PlatformConfiguration_respondToPlatformMessage&amp;#34;, _RespondToPlatformMessage, 3, true}, {&amp;#34;PlatformConfiguration_render&amp;#34;, Render, 2, true}, {&amp;#34;PlatformConfiguration_updateSemantics&amp;#34;, UpdateSemantics, 2, true}, {&amp;#34;PlatformConfiguration_setIsolateDebugName&amp;#34;, SetIsolateDebugName, 2, true}, {&amp;#34;PlatformConfiguration_reportUnhandledException&amp;#34;, ReportUnhandledException, 2, true}, {&amp;#34;PlatformConfiguration_setNeedsReportTimings&amp;#34;, SetNeedsReportTimings, 2, true}, {&amp;#34;PlatformConfiguration_getPersistentIsolateData&amp;#34;, GetPersistentIsolateData, 1, true}, {&amp;#34;PlatformConfiguration_computePlatformResolvedLocale&amp;#34;, _ComputePlatformResolvedLocale, 2, true}, }); } void ScheduleFrame(Dart_NativeArguments args) { UIDartState::ThrowIfUIOperationsProhibited(); UIDartState::Current()-&amp;gt;platform_configuration()-&amp;gt;client()-&amp;gt;ScheduleFrame(); } runtime/runtime_controller.</description>
    </item>
    
    <item>
      <title>Epoll</title>
      <link>https://huanle19891345.github.io/en/android/system/handler/epoll/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/handler/epoll/</guid>
      <description>原理总结 graph LR epoll_create--&amp;gt;|1创建|fileNode(&amp;quot;创建并初始化eventpoll结构体ep,将ep放入file-&amp;gt;private,并返回fd&amp;quot;) epoll_create--&amp;gt;|1创建|RBTree(&amp;quot;红黑树用于存储以后epoll_ctl传来的fd&amp;quot;) epoll_create--&amp;gt;|1创建|epitems(&amp;quot;链表,用于存储准备就绪的事件&amp;quot;) epoll_ctl--&amp;gt;|2 fd对应到|RBTree epoll_ctl--&amp;gt;|2 注册回调ep_poll_callback,回调时将fd对应的epitem实例放入就绪链表并唤醒进程|RBTree epoll_wait--&amp;gt;|3 ep_poll观察是否有数据|epitems--&amp;gt;|3|isEvent{是否有数据?}--&amp;gt;|3有|返回数据 isEvent--&amp;gt;|3否|sleepTimeoutThenReturn--&amp;gt;被唤醒后从队列中移除wait,再传输就绪事件到用户空间 epoll使用RB-Tree红黑树去监听并维护所有文件描述符，RB-Tree的根节点。调用epoll_create时，内核除了帮我们在epoll文件系统里建了个file结点，在内核cache里建了个 红黑树 用于存储以后epoll_ctl传来的socket外，还会再建立一个list链表，用于存储准备就绪的事件.当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。而且，通常情况下即使我们要监控百万计的句柄，大多一次也只返回很少量的准备就绪句柄而已，所以，epoll_wait仅需要从内核态copy少量的句柄到用户态而已.
那么，这个准备就绪list链表是怎么维护的呢？
当我们执行epoll_ctl时，除了把socket放到epoll文件系统里file对象对应的红黑树上之外，还会给内核中断处理程序注册一个回调函数，告诉内核，如果这个句柄的中断到了，就把它放到准备就绪list链表里。所以，当一个socket上有数据到了，内核在把网卡上的数据copy到内核中后就来把socket插入到准备就绪链表里了。
epoll相比于select并不是在所有情况下都要高效，例如在如果有少于1024个文件描述符监听，且大多数socket都是出于活跃繁忙的状态，这种情况下，select要比epoll更为高效，因为epoll会有更多次的系统调用，用户态和内核态会有更加频繁的切换。
epoll高效的本质在于：
 减少了用户态和内核态的文件句柄拷贝 减少了对可读可写文件句柄的遍历 mmap 加速了内核与用户空间的信息传递，epoll是通过内核与用户mmap同一块内存，避免了无谓的内存拷贝 IO性能不会随着监听的文件描述的数量增长而下降 使用红黑树存储fd，以及对应的回调函数，其插入，查找，删除的性能不错，相比于hash，不必预先分配很多的空间  fs/eventpoll.c
epoll_create // /usr/include/x86_64-linux-gnu/sys/epoll.h  /* Creates an epoll instance. Returns an fd for the new instance. The &amp;#34;size&amp;#34; parameter is a hint specifying the number of file descriptors to be associated with the new instance. The fd returned by epoll_create() should be closed with close().</description>
    </item>
    
    <item>
      <title>EventChannel</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/eventchannel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/eventchannel/</guid>
      <description>技术依赖 graph TB EventChannel--&amp;gt;|baseOn|MethodChannel EventChannel--&amp;gt;|baseOn|Stream 核心原理 sequenceDiagram rect rgb(199, 237, 204) Dart-&amp;gt;&amp;gt;Dart: stream.listen activate Dart Dart-&amp;gt;&amp;gt;Platform: methodChannel.invokeMethod(listen) deactivate Dart activate Platform Platform-&amp;gt;&amp;gt;Platform: onListen activate Platform Platform-&amp;gt;&amp;gt;Platform: handler.onListen(EventSink) deactivate Platform deactivate Platform end rect rgb(199, 237, 204) Platform-&amp;gt;&amp;gt;Platform: eventSink.success activate Platform Platform-&amp;gt;&amp;gt;Dart: messenger.send deactivate Platform activate Dart Dart-&amp;gt;&amp;gt;Dart: StreamController.add(T event) deactivate Dart end Usage Dart StreamBuilder Use demo参考/Users/qianpianpian/git/flutter/samples/platform_channels/lib/src/event_channel_demo.dart
使用StreamBuilder包裹stream
child: StreamBuilder&amp;lt;AccelerometerReadings&amp;gt;( stream: Accelerometer.readings,//stream  builder: (context, snapshot) { if (snapshot.hasError) { return Text((snapshot.</description>
    </item>
    
    <item>
      <title>FFmpegDebug</title>
      <link>https://huanle19891345.github.io/en/%E6%96%B9%E5%90%91%E5%92%8C%E8%B6%8B%E5%8A%BF/%E9%9F%B3%E8%A7%86%E9%A2%91/ffmpeg/ffmpegdebug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E6%96%B9%E5%90%91%E5%92%8C%E8%B6%8B%E5%8A%BF/%E9%9F%B3%E8%A7%86%E9%A2%91/ffmpeg/ffmpegdebug/</guid>
      <description>How to debug The small program uses the mac machine. First complete the preparation of FFmpeg source code download and compilation.
(0)Download FFmpeg source code&amp;ndash;success  git clone git://source.ffmpeg.org/ffmpeg.git ffmpeg
 As for the tools used to open these source files, readers should consider tools that are suitable for them and suitable for large projects, such as sourceinsight, sublime, vim, emacs, xcode, Android Studio, etc.
(1) Compile FFmpeg&amp;ndash;success #实际操作的命令 brew install yasm brew install automake fdk-aac git lame libass libtool libvorbis libvpx \ opus sdl shtool texi2html theora wget x264 x265 xvid nasm .</description>
    </item>
    
    <item>
      <title>FlutterBoost</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/flutterboost/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/flutterboost/</guid>
      <description>BoostFlutterActivity.onCreate BoostFlutterActivity implements FlutterActivityAndFragmentDelegate.Host { private FlutterActivityAndFragmentDelegate delegate; public static class NewEngineIntentBuilder { public Intent build(@NonNull Context context) { SerializableMap serializableMap = new SerializableMap(); serializableMap.setMap(params); return new Intent(context, activityClass) .putExtra(EXTRA_BACKGROUND_MODE, backgroundMode) .putExtra(EXTRA_DESTROY_ENGINE_WITH_ACTIVITY, false) .putExtra(EXTRA_URL, url) .putExtra(EXTRA_PARAMS, serializableMap); } @Override public String getContainerUrl() { if (getIntent().hasExtra(EXTRA_URL)) { return getIntent().getStringExtra(EXTRA_URL); } } @Override protected void onCreate(@Nullable Bundle savedInstanceState) { delegate = new FlutterActivityAndFragmentDelegate(this); delegate.onAttach(this); setContentView(createFlutterView()); } FlutterActivityAndFragmentDelegate implements IFlutterViewContainer { protected IOperateSyncer mSyncer; FlutterActivityAndFragmentDelegate(@NonNull Host host) { this.</description>
    </item>
    
    <item>
      <title>FlutterBoost3</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/flutterboost3/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/flutterboost3/</guid>
      <description>Native层设计 FlutterBoostPlugin类设计 FlutterBoost.setup 1. initialize default engine public void setup(Application application, FlutterBoostDelegate delegate, Callback callback, FlutterBoostOptions options) { // 1. initialize default engine  FlutterEngine engine = FlutterEngineCache.getInstance().get(ENGINE_ID); if (engine == null) { if (options == null) options = FlutterBoostOptions.createDefault(); engine = new FlutterEngine(application, options.shellArgs()); engine.getNavigationChannel().setInitialRoute(options.initialRoute()); engine.getDartExecutor().executeDartEntrypoint(new DartExecutor.DartEntrypoint( FlutterMain.findAppBundlePath(), options.dartEntrypoint())); if(callback != null) callback.onStart(engine); FlutterEngineCache.getInstance().put(ENGINE_ID, engine); } // 2. set delegate  getPlugin().setDelegate(delegate); //3. register ActivityLifecycleCallbacks  setupActivityLifecycleCallback(application); } 2. setDelegateToPlugin public FlutterEngine(@NonNull Context context, @Nullable String[] dartVmArgs) { this(context, /* flutterLoader */ null, new FlutterJNI(), dartVmArgs, true);//最后的参数true表示automaticallyRegisterPlugins } public FlutterEngine( @NonNull Context context, @Nullable FlutterLoader flutterLoader, @NonNull FlutterJNI flutterJNI, @Nullable String[] dartVmArgs, boolean automaticallyRegisterPlugins) { this( context, flutterLoader, flutterJNI, new PlatformViewsController(), dartVmArgs, automaticallyRegisterPlugins); } //最终在FlutterEngine构造方法结尾进行如下操作  if (automaticallyRegisterPlugins) { registerPlugins(); } //反射调用自动生成的注册类的注册方法  private void registerPlugins() { try { Class&amp;lt;?</description>
    </item>
    
    <item>
      <title>FlutterEngineCache</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/engine/flutterenginecache/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/engine/flutterenginecache/</guid>
      <description>BaseOnFlutter2.0
FlutterEngineCache public class FlutterEngineCache { private static FlutterEngineCache instance; private final Map&amp;lt;String, FlutterEngine&amp;gt; cachedEngines = new HashMap&amp;lt;&amp;gt;(); } FlutterEngineInit graph LR FlutterApplication--&amp;gt;|after onCreate|flutterLoader.startInit--&amp;gt;similarToFlutter1.12 FlutterEngine--&amp;gt;initAssetManager FlutterEngine--&amp;gt;initDartExecutor FlutterEngine--&amp;gt;initMultipleChannels FlutterEngine--&amp;gt;flutterLoader.startInitAndBlockUtilComplete FlutterEngine--&amp;gt;flutterJNI.attachToNativeShell/Engine--&amp;gt;similarToFlutter1.12WhenConstuctFlutterView FlutterEngine--&amp;gt;initFlutterRendererAndPlatformViewsController FlutterEngine--&amp;gt;automaticallyRegisterPlugins FlutterEngine Constructor public FlutterEngine(@NonNull Context context, @Nullable String[] dartVmArgs) { this(context, /* flutterLoader */ null, new FlutterJNI(), dartVmArgs, true); } /** Fully configurable {@code FlutterEngine} constructor. */ public FlutterEngine( @NonNull Context context, @Nullable FlutterLoader flutterLoader, @NonNull FlutterJNI flutterJNI, @NonNull PlatformViewsController platformViewsController, @Nullable String[] dartVmArgs, boolean automaticallyRegisterPlugins, boolean waitForRestorationData) { AssetManager assetManager; try { assetManager = context.</description>
    </item>
    
    <item>
      <title>FlutterEngineDebug环境搭建</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/engine/flutterenginedebug%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/engine/flutterenginedebug%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>FlutterEngine开发环境 https://github.com/flutter/flutter/wiki/Setting-up-the-Engine-development-environment
Editor autocomplete support VSCode with C/C++ Intellisense VSCode can provide some IDE features using the C/C++ extension. It will provide basic support on install without needing any additional configuration. There will probably be some issues, like header not found errors and incorrect jump to definitions.
Intellisense can also use our compile_commands.json for more robust functionality. Either symlink src/out/compile_commands.json to the project root at src/flutter or provide an absolute path to it in the c_cpp_properties.</description>
    </item>
    
    <item>
      <title>FlutterEngineGroup</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/engine/flutterenginegroup/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/engine/flutterenginegroup/</guid>
      <description>FlutterEngineGroup构造 public class FlutterEngineGroup { final List&amp;lt;FlutterEngine&amp;gt; activeEngines = new ArrayList&amp;lt;&amp;gt;(); /** Create a FlutterEngineGroup whose child engines will share resources. */ public FlutterEngineGroup(@NonNull Context context) { this(context, null); } /** * Create a FlutterEngineGroup whose child engines will share resources. Use {@code dartVmArgs} to * pass flags to the Dart VM during initialization. */ public FlutterEngineGroup(@NonNull Context context, @Nullable String[] dartVmArgs) { FlutterLoader loader = FlutterInjector.instance().flutterLoader(); if (!loader.initialized()) { loader.</description>
    </item>
    
    <item>
      <title>GC</title>
      <link>https://huanle19891345.github.io/en/android/art/alloc_gc/gc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/alloc_gc/gc/</guid>
      <description>类设计 runtime.cc
Runtime::VisitRoots void Runtime::VisitRoots(RootVisitor* visitor, VisitRootFlags flags) { /*RootVisitor是一个纯虚类，其定义了几个函数，供root访问时调用。参数flags有一个默认 值，为kVisitRootFlagAllRoots，表示要访问所有的root。*/ VisitNonConcurrentRoots(visitor); VisitConcurrentRoots(visitor, flags); } Runtime::VisitNonConcurrentRoots void Runtime::VisitNonConcurrentRoots(RootVisitor* visitor) { //1：调用所有Thread对象的VisitRoots函数  thread_list_-&amp;gt;VisitRoots(visitor); VisitNonThreadRoots(visitor);//接着看该函数的代码 } Thread::VisitRoots void Thread::VisitRoots(RootVisitor* visitor) { /*GetThreadId返回的是Thread tlsPtr_ thin_lock_thread_id thin_lock_id。 我们在12.2.1节中介绍过它。该id并不是代表操作系统里线程的tid，而是由虚拟机自己维护的用 于线程同步的id。*/ const uint32_t thread_id = GetThreadId(); //tlsPtr_opeer指向一个Java层Thread对象，它是一个mirror Thread对象在Java层  //的对应物。这类根对象的类型为kRootThreadObject  visitor-&amp;gt;VisitRootIfNonNull(&amp;amp;tlsPtr_.opeer, RootInfo(kRootThreadObject, thread_id)); /*tlsPtr_ exception指向一个Java异常对象。注意，GetDeoptimizationException返 回的值非常特殊（为-1）。所以，它并不是一个真正的Java异常对象，只是用-1来表示和 HDeoptimize有关的处理（详情可参考10.4节的内容） */ if (tlsPtr_.exception != nullptr &amp;amp;&amp;amp; tlsPtr_.exception != GetDeoptimizationException()) { //使用kRootNativeStack作为tlsPtr_ exception的root类型  visitor-&amp;gt;VisitRoot(reinterpret_cast&amp;lt;mirror::Object**&amp;gt;( &amp;amp;tlsPtr_.exception), RootInfo(kRootNativeStack, thread_id)); } //tlsPtr_ monitor_enter_object指向用于monitor-enter的那个Java对象。详情可参考  //12.</description>
    </item>
    
    <item>
      <title>GC1_MS_CMS</title>
      <link>https://huanle19891345.github.io/en/android/art/alloc_gc/gc1_ms_cms/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/alloc_gc/gc1_ms_cms/</guid>
      <description>MarkSweep类家族 表14-1　MarkSweep类家族GetGcType取值情况
集合Live和集合Mark构成 CMS时Heap space相关成员变量取值情况 CMS时Heap位图相关成员变量取值情况 图14-7　CMS时Heap位图相关成员变量取值情况
一个HeapBitmap对象可以管理多个ContinuousSpace的某一种位图对象
CMS时Heap mark_stack_等成员变量的情况 MarkSweep::MarkSweep MarkSweep::MarkSweep(Heap* heap, bool is_concurrent, const std::string&amp;amp; name_prefix) : GarbageCollector(heap, name_prefix + (is_concurrent ? &amp;#34;concurrent mark sweep&amp;#34;: &amp;#34;mark sweep&amp;#34;)), current_space_bitmap_(nullptr), mark_bitmap_(nullptr), mark_stack_(nullptr), ..... is_concurrent_(is_concurrent),...... { /*MarkSweep构造函数并不复杂，此处先介绍下它的几个成员变量（其作用留待后续代码分析时时再详细讲解）： current_space_bitmap_：类型为ContinuousSpaceBitmap*。 mark_bitmap_：类型为HeapBitmap*。 mark_stack_：类型为ObjectStack*。 */ ..... /*下面的代码行将创建一个内存映射对象。ART内部大量使用内存映射对象。下面的 sweep_array_free_buffer_mem_map_的用法需要到介绍StickyMarkSweep时才能见到。总之，读者将它看作一块内存即可。*/ MemMap* mem_map = MemMap::MapAnonymous(......); sweep_array_free_buffer_mem_map_.reset(mem_map); ..... } MarkSweep::RunPhases 图解 graph TB IsConcurrent{IsConcurrent}--&amp;gt;|yes|MarkingPhaseC(MarkingPhase) MarkingPhaseC--&amp;gt;pauseC(pause) pauseC--&amp;gt;PausePhaseC(&amp;quot;PausePhase_reMark&amp;quot;) PausePhaseC--&amp;gt;RevokeAllThreadLocalBuffers RevokeAllThreadLocalBuffers--&amp;gt;ReclaimPhase ReclaimPhase--&amp;gt;FinishPhase IsConcurrent--&amp;gt;|no|pause pause--&amp;gt;MarkingPhase MarkingPhase--&amp;gt;PausePhase PausePhase--&amp;gt;RevokeAllThreadLocalBuffers void MarkSweep::RunPhases() { Thread* self = Thread::Current(); //初始化MarkSweep类的几个成员变量。其中，MarkSweep的mark_bitmap_将设置为Heap的成员变量mark_bitmap_（读者可回顾图14-7）  InitializePhase(); if (IsConcurrent()) {//if条件为true，则是CMS的行为  .</description>
    </item>
    
    <item>
      <title>GC2_ConcurrentCopying</title>
      <link>https://huanle19891345.github.io/en/android/art/alloc_gc/gc2_concurrentcopying/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/alloc_gc/gc2_concurrentcopying/</guid>
      <description>ConcurrentCopying virtual GcType GetGcType() const OVERRIDE { //ConcurrentCopying仅支持kGcTypePartial，也就是不扫描ImageSpace和  //ZygoteSpace（除了那些有dirty card的对象）  return kGcTypePartial; } virtual CollectorType GetCollectorType() const OVERRIDE { return kCollectorTypeCC;//返回回收器类型 } void SetRegionSpace(space::RegionSpace* region_space) { //region_space_是ConcurrentCopying的成员变量  //ConcurrentCopying要回收的垃圾对象就在这个region_space_中  region_space_ = region_space; } RunPhases void ConcurrentCopying::RunPhases() { is_active_ = true; Thread* self = Thread::Current(); thread_running_gc_ = self; { ReaderMutexLock mu(self, *Locks::mutator_lock_); InitializePhase();//①初始化阶段  } FlipThreadRoots();//②完成半空间Flip工作  { ReaderMutexLock mu(self, *Locks::mutator_lock_); MarkingPhase();//③标记  } ...... { ReaderMutexLock mu(self, *Locks::mutator_lock_); ReclaimPhase();//④回收  } FinishPhase();//收尾工作，非常简单，请读者自行阅读  is_active_ = false; thread_running_gc_ = nullptr; } InitializePhase void ConcurrentCopying::InitializePhase() { .</description>
    </item>
    
    <item>
      <title>GC3_MarkCompact</title>
      <link>https://huanle19891345.github.io/en/android/art/alloc_gc/gc3_markcompact/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/alloc_gc/gc3_markcompact/</guid>
      <description>mark_compact.h/cc virtual GcType GetGcType() const OVERRIDE { return kGcTypePartial;//MarkCompact不处理ImageSpace和ZygoteSpace } virtual CollectorType GetCollectorType() const OVERRIDE { return kCollectorTypeMC; } void MarkCompact::SetSpace(space::BumpPointerSpace* space) { space_ = space;//space_是MarkCompact成员变量 } RunPhases void MarkCompact::RunPhases() { Thread* self = Thread::Current(); /* InitializePhase非常简单，其中需要注意的是MarkCompact下面两个成员变量的设置： (1) mark_stack_ = heap_-&amp;gt;GetMarkStack(); (2) mark_bitmap_ = heap_-&amp;gt;GetMarkBitmap(); */ InitializePhase(); { ScopedPause pause(this);//MarkCompact是stop-the-world类型的回收器  ...... MarkingPhase();//①标记阶段，详情见下文分析  ReclaimPhase();//②回收阶段，详情见下文分析  } ...... FinishPhase();//收尾工作，非常简单，读者可自行阅读 } MarkingPhase void MarkCompact::MarkingPhase() { Thread* self = Thread::Current(); /*MarkCompact基于Mark-Compact回收原理，所以它也需要标记能搜索到的对象。不过，由于 BumpPointerSpace空间对象不包含位图对象，所以下面将为space_（指向一个 BumpPointerSpace空间）创建一个位图对象objects_before_forwarding。它用于记录 搜索到的对象。*/ objects_before_forwarding_.</description>
    </item>
    
    <item>
      <title>GC4_Semi_Space</title>
      <link>https://huanle19891345.github.io/en/android/art/alloc_gc/gc4_semi_space/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/alloc_gc/gc4_semi_space/</guid>
      <description>collector_type.h文件中关于枚举值kCollectorTypeSS有这样一句注释来介绍它：&amp;ldquo;Semi-space/mark-sweep hybrid，enables compaction.&amp;quot;。其含义是SemiSpace综合了Semi-space（即Copying Collector）和Mark-Sweep方法，同时还支持压缩。而kCollectorTypeGSS则是支持分代回收的SS方法。
纵观SemiSpace，它的GC逻辑无非就是如下两点。
 对GSS而言，from_space_中能搜索到的对象将被“提升”到promo_dest_space_空间中。对SS而言，from_space_中能搜索到的对象拷贝到to_space_中。GC之后，from_space_的空间被回收。 其他空间的处理和MarkSweep的类似，按照集合Live和集合Mark来找到和释放垃圾对象即可。SemiSpace在ART中的作用很重要，我们下文介绍应用程序退到后台后，虚拟机为减少内存碎片而做的内存压缩时就会用到它。  semi_space.cc
RunPhases void SemiSpace::RunPhases() { Thread* self = Thread::Current(); InitializePhase();//①回收器初始化  //if为true，说明mutator线程已被暂停。这种情况的出现和SemiSpace的用法有关，  //我们暂且不用考虑这些  if (Locks::mutator_lock_-&amp;gt;IsExclusiveHeld(self)) { MarkingPhase();//②标记工作  ReclaimPhase();//回收工作，非常简单，留给读者自行研究  } else { //如果mutator未暂停，则SemiSpace只有标记阶段需要暂停mutator  { ScopedPause pause(this);//暂停mutator  MarkingPhase();//标记工作  } {//mutator恢复运行，可同时开展回收工作  ReaderMutexLock mu(self, *Locks::mutator_lock_); ReclaimPhase(); } } FinishPhase(); } </description>
    </item>
    
    <item>
      <title>GradleDebug</title>
      <link>https://huanle19891345.github.io/en/android/gradlejenkins/gradledebug/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/gradlejenkins/gradledebug/</guid>
      <description>Gradle构建源码断点调试配置 (本方式也支持build.gradle中设置的断点调试)
1 buildSrc配置 项目根目录下添加文件夹buildSrc,内部添加文件build.gradle:
repositories { mavenLocal() jcenter() google() } dependencies { //配置任意插件地址  implementation &amp;#39;com.android.tools.build:gradle:3.2.1&amp;#39; implementation &amp;#34;com.tencent.matrix:matrix-gradle-plugin:0.6.5.1&amp;#34; } 这样配置之后，在android studio的project视图下就能够在External Liberaries中看到Android Build Tool的源码，之后可以通过搜索需要调试的类和方法进行断点调试，目的是让IDE链接到gradle build tool 或各种自定义插件的源代码。(有时无法debug是因为该次build没有走断点处流程，先clean确保会走流程)
2 gradlew command gradlew :app:compileDebugAidl -Dorg.gradle.daemon=false -Dorg.gradle.debug=true 也就是在需要debug的gradle语句后添加-Dorg.gradle.daemon=false -Dorg.gradle.debug=true。
之后可以看到Terminal中执行被阻塞，并输出如下：
To honour the JVM settings for this build a new JVM will be forked. Please consider using the daemon: https://docs.gradle.org/4.6/userguide/gradle_daemon.html. \&amp;gt; Starting Daemon 这里如果想每次执行命令，即使不设置后面的-Dorg.gradle.daemon=false -Dorg.gradle.debug=true信息，也默认执行断点调试，可以配置环境变量，方法如下:
在系统环境变量里面添加：
GRADLE_OPTS 值为:
-Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005
3 配置remote debug Android Studio中按照如下步骤操作：</description>
    </item>
    
    <item>
      <title>GradlePlugin</title>
      <link>https://huanle19891345.github.io/en/android/gradlejenkins/gradleplugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/gradlejenkins/gradleplugin/</guid>
      <description>gradle plugin的两种方式  脚本插件模式：apply from: &amp;lsquo;xx.gradle&amp;rsquo; 标准插件模式：apply plugin: &amp;lsquo;xxx&amp;rsquo;  脚本插件模式转换为标准插件模式 直接在apply(Project project)回调时将之前的脚本插件代码copy过来即可，这里的上下文会缺少project，因此需要用project.with{}包裹原本的脚本代码
gradle plugin执行流程 两种gradle plugin的都是相当于动态替换插件代码在apply的地地方，也就apply plugin时直接调用到apply(Project project)
针对build.gradle从上到下执行的过程就是evaluate过程
使用标准插件时拓展参数的执行流程
 接入的gradle，apply plugin时，在插件内部回调方法apply(Project project)中进行拓展的定义：  mProject.extensions.create(&amp;#39;tinkerPatch&amp;#39;, TinkerPatchExtension) 接入的gradle文件，配置拓展参数信息 插件代码中before/afterEvaluate在闭包中获取用户配置信息  mProject.afterEvaluate { def configuration = mProject.tinkerPatch } /** * 由于一般方式配置拓展的方式，应用端配置的参数只能在afterEvaluate方法中获取配置的参数值，而此时已经无法在进行buildConfig配置tinkerEnable * 因此使用ext的拓展方式替代本拓展方式:*/ ext { tinkerPatchEnable = true appKey = &amp;#39;xxx&amp;#39; } apply plugin: &amp;#39;com.xh.xhcore.plugin&amp;#39; apply plugin方式插件编写流程  项目new android library module 只留下src/main和build.gradle，其他的文件全部删除 注册插件信息，在src/main/resources/META-INF/gradle-plugins/${pluginName}.properties moudule 进行 apply plugin: &amp;ldquo;${pluginName}&amp;rdquo;  插件内部包裹嵌套其他插件 root project的blueScript中配置的classPath的被嵌套的插件仅仅参与本项目的编译，并不会打包在发布的插件里，因此需要在插件build.</description>
    </item>
    
    <item>
      <title>Gradle打包过程</title>
      <link>https://huanle19891345.github.io/en/android/gradlejenkins/gradle%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/gradlejenkins/gradle%E6%89%93%E5%8C%85%E8%BF%87%E7%A8%8B/</guid>
      <description>gradle时序 graph LR init --&amp;gt;configure--&amp;gt;executeTasks executeTasks graph LR transform --&amp;gt; packageDebug(packageDebug: 将intermediates中的产物打包成apk) --&amp;gt; assembleDebug 自定义task http://blog.csdn.net/liuhongwei123888/article/details/50542104
assets的注入 packageApplication之后assemble之前可以进行assets的注入
removeUnusedResourcesTask.dependsOn variant.packageApplication variant.assemble.dependsOn removeUnusedResourcesTask assets位于build下的如下目录:
build\intermediates\merged_assets\debug\mergeDebugAssets\out</description>
    </item>
    
    <item>
      <title>Graphics</title>
      <link>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/graphics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/graphics/</guid>
      <description>Graphics https://source.android.com/devices/graphics/index.html
Android graphics components No matter what rendering API developers use, everything is rendered onto a &amp;ldquo;surface.&amp;rdquo; The surface represents the producer side of a buffer queue that is often consumed by SurfaceFlinger. Every window that is created on the Android platform is backed by a surface. All of the visible surfaces rendered are composited onto the display by SurfaceFlinger.
The following diagram shows how the key components work together:</description>
    </item>
    
    <item>
      <title>HiltSource</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/di/hiltsource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/di/hiltsource/</guid>
      <description>Hilt Usage  Annotate the Application class with @HiltAndroidApp Annotate the Activity class with @AndroidEntryPoint Annotate the ViewModel class with @HiltViewModel and @Inject constructor Annotate the Repository class with @Singleton and @Inject constructor  ViewModel注入过程 以LoginActivity为例
@HiltViewModel class LoginViewModel @Inject constructor( application: Application, private val savedStateHandle: SavedStateHandle, private val userRepository: UserRepository ) : LoginViewModel by viewModels() @MainThread inline fun &amp;lt;reified VM : ViewModel&amp;gt; ComponentActivity.viewModels( noinline factoryProducer: (() -&amp;gt; Factory)? = null ): Lazy&amp;lt;VM&amp;gt; { val factoryPromise = factoryProducer ?</description>
    </item>
    
    <item>
      <title>Hook</title>
      <link>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/hook/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/hook/</guid>
      <description>Hook机制之动态代理 动态代理 传统的静态代理模式需要为每一个需要代理的类写一个代理类，如果需要代理的类有几百个那不是要累死？为了更优雅地实现代理模式，JDK提供了动态代理方式，可以简单理解为JVM可以在运行时帮我们动态生成一系列的代理类，这样我们就不需要手写每一个静态的代理类了。依然以购物为例，用动态代理实现如下：
public static void main(String[] args) { Shopping women = new ShoppingImpl(); // 正常购物  System.out.println(Arrays.toString(women.doShopping(100))); // 招代理  women = (Shopping) Proxy.newProxyInstance(Shopping.class.getClassLoader(), women.getClass().getInterfaces(), new ShoppingHandler(women)); System.out.println(Arrays.toString(women.doShopping(100))); } 动态代理主要处理InvocationHandler和Proxy类；完整代码可以见github
代理Hook 我们知道代理有比原始对象更强大的能力，比如飞到国外买东西，比如坑钱坑货；那么很自然，如果我们自己创建代理对象，然后把原始对象替换为我们的代理对象，那么就可以在这个代理对象为所欲为了；修改参数，替换返回值，我们称之为Hook。
下面我们Hook掉startActivity这个方法，使得每次调用这个方法之前输出一条日志；（当然，这个输入日志有点点弱，只是为了展示原理；只要你想，你想可以替换参数，拦截这个startActivity过程，使得调用它导致启动某个别的Activity，指鹿为马！）
首先我们得找到被Hook的对象，我称之为Hook点；什么样的对象比较好Hook呢？自然是容易找到的对象。什么样的对象容易找到？静态变量和单例；在一个进程之内，静态变量和单例变量是相对不容易发生变化的，因此非常容易定位，而普通的对象则要么无法标志，要么容易改变。我们根据这个原则找到所谓的Hook点。
然后我们分析一下startActivity的调用链，找出合适的Hook点。我们知道对于Context.startActivity（Activity.startActivity的调用链与之不同），由于Context的实现实际上是ContextImpl;我们看ConetxtImpl类的startActivity方法：
@Override public void startActivity(Intent intent, Bundle options) { warnIfCallingFromSystemProcess(); if ((intent.getFlags()&amp;amp;Intent.FLAG_ACTIVITY_NEW_TASK) == 0) { throw new AndroidRuntimeException( &amp;#34;Calling startActivity() from outside of an Activity &amp;#34; \+ &amp;#34; context requires the FLAG_ACTIVITY_NEW_TASK flag.&amp;#34; \+ &amp;#34; Is this really what you want?</description>
    </item>
    
    <item>
      <title>IOC</title>
      <link>https://huanle19891345.github.io/en/%E6%80%9D%E6%83%B3/ioc/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E6%80%9D%E6%83%B3/ioc/</guid>
      <description>graph TB 依赖者--&amp;gt;|依赖|被依赖者 变为
graph TB 被依赖者--&amp;gt;|提前注入接口实现|接口注入管理模块 依赖者--&amp;gt;|使用已经注入好了的接口实现|接口注入管理模块 参考 控制反转（IoC）与依赖注入（DI）
对象A获得依赖对象B的过程,由主动行为变为了被动行为，控制权颠倒过来了，这就是“控制反转”这个名称的由来。</description>
    </item>
    
    <item>
      <title>java_jni方法调用原理</title>
      <link>https://huanle19891345.github.io/en/android/art/jni/java_jni%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/jni/java_jni%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E5%8E%9F%E7%90%86/</guid>
      <description>Method Execute Flow graph TB PerformCall(PerformCall)--&amp;gt;|Interpreter|ArtInterpreterToInterpreterBridge(interpreter::ArtInterpreterToInterpreterBridge) ArtInterpreterToInterpreterBridge--&amp;gt;ExecuteSwitchImplCpp(interpreter::ExecuteSwitchImplCpp) ExecuteSwitchImplCpp--&amp;gt;DoInvoke(case Instruction::xxx: interpreter::DoInvoke, find called ArtMethod) DoInvoke--&amp;gt;DoCallCommon(interpreter::DoCallCommon, prepare shadow frame) DoCallCommon--&amp;gt;PerformCall ArtMethod::Invoke--&amp;gt;art_quick_invoke_stub(art_quick_invoke_stub: function in quick_entry_point.S) artQuickToInterpreterBridge(artQuickToInterpreterBridge, prepare shadow frame)--&amp;gt;EnterInterpreterFromEntryPoint(interpreter::EnterInterpreterFromEntryPoint) EnterInterpreterFromEntryPoint--&amp;gt;ExecuteSwitchImplCpp PerformCall--&amp;gt;|CompiledCode|ArtInterpreterToCompiledCodeBridge(interpreter::ArtInterpreterToCompiledCodeBridge) ArtInterpreterToCompiledCodeBridge--&amp;gt;ArtMethod::Invoke compiledCode--&amp;gt;|Interpreter|artQuickToInterpreterBridge art_quick_invoke_stub--&amp;gt;|ART_METHOD_QUICK_CODE_OFFSET_32|IsJniMethod{Is JNI method?} IsJniMethod--&amp;gt;|no|entry_point_from_quick_compiled_code_(entry_point_from_quick_compiled_code_ linkCode时设置) IsJniMethod--&amp;gt;|yes|art_quick_generic_jni_trampoline_汇编 art_quick_generic_jni_trampoline_汇编--&amp;gt;artQuickGenericJniTrampoline artQuickGenericJniTrampoline--&amp;gt;data_(data_RegisterNative时设置) data_--&amp;gt;IsJniDlsymLookupStub{IsJniDlsymLookupStub?} IsJniDlsymLookupStub--&amp;gt;|no|nativeCode IsJniDlsymLookupStub--&amp;gt;|yes|artFindNativeMethod entry_point_from_quick_compiled_code_--&amp;gt;IsCompiled{Is Compiled?} IsCompiled--&amp;gt;|yes|compiledCode IsCompiled--&amp;gt;|no|art_quick_to_interpreter_bridge汇编 art_quick_to_interpreter_bridge汇编--&amp;gt;artQuickToInterpreterBridge Jni方法查找过程图解 sequenceDiagram Trampoline-&amp;gt;&amp;gt;Trampoline:artQuickGenericJniTrampoline activate Trampoline Trampoline-&amp;gt;&amp;gt;Trampoline:void const* nativeCode = artMethod-&amp;gt;GetEntryPointFromJni() activate Trampoline Note over Trampoline,artFindNativeMethod: if(nativeCode == GetJniDlsymLookupStub()) Trampoline-&amp;gt;&amp;gt;artFindNativeMethod:artFindNativeMethod activate artFindNativeMethod artFindNativeMethod-&amp;gt;&amp;gt;JavaVMExt: void* native_code = soa.</description>
    </item>
    
    <item>
      <title>JavaCrashSystemHandle</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/1javacrash/javacrashsystemhandle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/1javacrash/javacrashsystemhandle/</guid>
      <description>原理流程 当Binder服务端ApplicationThread所在进程(即Crash进程)挂掉后，则Binder客户端能收到相应的死亡通知，从而进入binderDied流程。
AMP.handleApplicationCrash AMS.handleApplicationCrash AMS.findAppProcess AMS.handleApplicationCrashInner AMS.addErrorToDropBox AMS.crashApplication AMS.makeAppCrashingLocked AMS.startAppProblemLocked ProcessRecord.stopFreezingAllLocked ActivityRecord.stopFreezingScreenLocked WMS.stopFreezingScreenLocked WMS.stopFreezingDisplayLocked AMS.handleAppCrashLocked mUiHandler.sendMessage(SHOW_ERROR_MSG) Process.killProcess(Process.myPid()); System.exit(10); 其中addErrorToDropBox是将crash的信息输出到目录/data/system/dropbox。例如system_server的dropbox文件名为system_server_crash@xxx.txt (xxx代表的是时间戳)
AMS.handleAppCrashLocked ASS.handleAppCrashLocked AS.handleAppCrashLocked AS.finishCurrentActivityLocked AMS.removeProcessLocked ProcessRecord.kill AMS.handleAppDiedLocked ASS.handleAppDiedLocked AMS.cleanUpApplicationRecordLocked AS.handleAppDiedLocked AS.removeHistoryRecordsForAppLocked ASS.resumeTopActivitiesLocked AS.resumeTopActivityLocked AS.resumeTopActivityInnerLocked ASS.finishTopRunningActivityLocked AS.finishTopRunningActivityLocked AS.finishActivityLocked 参考 http://gityuan.com/2016/06/24/app-crash/
吹爆系列：深入探索android稳定性优化</description>
    </item>
    
    <item>
      <title>java并发</title>
      <link>https://huanle19891345.github.io/en/java/java%E5%B9%B6%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/java/java%E5%B9%B6%E5%8F%91/</guid>
      <description>Java主流锁 悲观锁和乐观锁 乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。
先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。
而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。
乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的。
根据从上面的概念描述我们可以发现：
 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。  光说概念有些抽象，我们来看下乐观锁和悲观锁的调用方式示例：
通过调用方式示例，我们可以发现悲观锁基本都是在显式的锁定之后再操作同步资源，而乐观锁则直接去操作同步资源。那么，为何乐观锁能够做到不锁定同步资源也可以正确的实现线程同步呢？我们通过介绍乐观锁的主要实现方式 “CAS” 的技术原理来为大家解惑。
CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。
CAS算法涉及到三个操作数：
 需要读写的内存值 V。 进行比较的值 A。 要写入的新值 B。  当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。
之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁，那么我们进入原子类AtomicInteger的源码，看一下AtomicInteger的定义：
根据定义我们可以看出各属性的作用：
 unsafe： 获取并操作内存的数据。 valueOffset： 存储value在AtomicInteger中的偏移量。 value： 存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。  接下来，我们查看AtomicInteger的自增函数incrementAndGet()的源码时，发现自增函数底层调用的是unsafe.getAndAddInt()。但是由于JDK本身只有Unsafe.class，只通过class文件中的参数名，并不能很好的了解方法的作用，所以我们通过OpenJDK 8 来查看Unsafe的源码：
根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAndSwapInt()中，在JNI里是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。
后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。
CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：
 ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。  JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。
 循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。
  只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。</description>
    </item>
    
    <item>
      <title>JDK动态代理</title>
      <link>https://huanle19891345.github.io/en/android/aop/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/aop/jdk%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid>
      <description>Proxy /** parameter types of a proxy class constructor */ private static final Class&amp;lt;?&amp;gt;[] constructorParams = { InvocationHandler.class }; /** \* a cache of proxy classes */ private static final WeakCache&amp;lt;ClassLoader, Class&amp;lt;?&amp;gt;[], Class&amp;lt;?&amp;gt;&amp;gt; proxyClassCache = new WeakCache&amp;lt;&amp;gt;(new KeyFactory(), new ProxyClassFactory()); newProxyInstance public static Object newProxyInstance(ClassLoader loader, Class&amp;lt;?&amp;gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException { final Class&amp;lt;?&amp;gt;[] intfs = interfaces.clone(); /* \* Look up or generate the designated proxy class. */ Class&amp;lt;?&amp;gt; cl = getProxyClass0(loader, intfs);//main  final Constructor&amp;lt;?</description>
    </item>
    
    <item>
      <title>JNI</title>
      <link>https://huanle19891345.github.io/en/android/ndk/jni/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/ndk/jni/</guid>
      <description>https://docs.oracle.com/javase/7/docs/technotes/guides/jni/spec/types.html
https://developer.android.com/training/articles/perf-jni
JavaVM and JNIEnv 图解 graph LR JavaVM--&amp;gt;singlePerProcess JNIEnv--&amp;gt;singlePerThread JNI defines two key data structures, &amp;ldquo;JavaVM&amp;rdquo; and &amp;ldquo;JNIEnv&amp;rdquo;. Both of these are essentially pointers to pointers to function tables. (In the C++ version, they&amp;rsquo;re classes with a pointer to a function table and a member function for each JNI function that indirects through the table.) The JavaVM provides the &amp;ldquo;invocation interface&amp;rdquo; functions, which allow you to create and destroy a JavaVM.</description>
    </item>
    
    <item>
      <title>Jni数据转换</title>
      <link>https://huanle19891345.github.io/en/android/art/jni/jni%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/jni/jni%E6%95%B0%E6%8D%AE%E8%BD%AC%E6%8D%A2/</guid>
      <description>数据转换总结 graph TB jstring--&amp;gt;|soa.decode|mirror::String* mirror::String*--&amp;gt;|encode/AddLocalReference|jstring mirror::String*--&amp;gt;char* char*--&amp;gt;|mirror::String::AllocFromModifiedUtf8|mirror::String* jmethodid--&amp;gt;|decode|ArtMethod* ArtMethod*--&amp;gt;|encode|jmethodid jobject(&amp;quot;jobject/IndirectRef&amp;quot;)--&amp;gt;|decode|mirrorObject(&amp;quot;art::mirror::Object*&amp;quot;) mirrorObject--&amp;gt;|Assign/Compress|StackReference(&amp;quot;art::StackReference&amp;lt;mirror::Object&amp;gt;*&amp;quot;) StackReference--&amp;gt;|AsMirrorPtr/UnCompress|mirrorObject StackReference--&amp;gt;|OwnedBy|Handle(&amp;quot;art::Handle~T~&amp;quot;) StackHandleScope--&amp;gt;|Provided|Handle StackHandleScope--&amp;gt;|OwnsMulti|StackReference ThreadTlsPtr--&amp;gt;|OwnsLinkedList|StackHandleScope mirrorObject--&amp;gt;|encode|jobject HandleScope的作用 类设计 //8.2.2 ScopedObjectAccess等辅助类
ScopedObjectAccessAlreadyRunnable DecodeMethod ArtMethod* DecodeMethod(jmethodID mid) const SHARED_REQUIRES(Locks::mutator_lock_) { Locks::mutator_lock_-&amp;gt;AssertSharedHeld(Self()); return reinterpret_cast&amp;lt;ArtMethod*&amp;gt;(mid);//main  } EncodeMethod jmethodID EncodeMethod(ArtMethod* method) const SHARED_REQUIRES(Locks::mutator_lock_) { Locks::mutator_lock_-&amp;gt;AssertSharedHeld(Self()); return reinterpret_cast&amp;lt;jmethodID&amp;gt;(method);//main  } T AddLocalReference(mirror::Object* obj) /* * Add a local reference for an object to the indirect reference table associated with the * current stack frame. When the native function returns, the reference will be discarded.</description>
    </item>
    
    <item>
      <title>JVM_JIT</title>
      <link>https://huanle19891345.github.io/en/android/art/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91_%E8%BF%90%E8%A1%8C/jvm_jit/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91_%E8%BF%90%E8%A1%8C/jvm_jit/</guid>
      <description>JVM解释器和编译器 JVM：JVM有自己完善的硬件架构，如处理器、堆栈（Stack）、寄存器等，还具有相应的指令系统（字节码就是一种指令格式）。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需要生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。JVM是Java平台无关的基础。JVM负责运行字节码：JVM把每一条要执行的字节码交给解释器，翻译成对应的机器码，然后由解释器执行。JVM解释执行字节码文件就是JVM操作Java解释器进行解释执行字节码文件的过程。
Java编译器：将Java源文件（.java文件）编译成字节码文件（.class文件，是特殊的二进制文件，二进制字节码文件），这种字节码就是JVM的“机器语言”。javac.exe可以简单看成是Java编译器。
Java解释器：是JVM的一部分。Java解释器用来解释执行Java编译器编译后的程序。java.exe可以简单看成是Java解释器。
注意：通常情况下，一个平台上的二进制可执行文件不能在其他平台上工作，因为此可执行文件包含了对目标处理器的机器语言。而Class文件这种特殊的二进制文件，是可以运行在任何支持Java虚拟机的硬件平台和操作系统上的！
维基百科定义：
JVM：一种能够运行Java字节码（Java bytecode）的虚拟机。
字节码：字节码是已经经过编译，但与特定机器码无关，需要解释器转译后才能成为机器码的中间代码。
Java字节码：是Java虚拟机执行的一种指令格式。
解释器：是一种电脑程序，能够把高级编程语言一行一行直接翻译运行。解释器不会一次把整个程序翻译出来，只像一位“中间人”，每次运行程序时都要先转成另一种语言再作运行，因此解释器的程序运行速度比较缓慢。它每翻译一行程序叙述就立刻运行，然后再翻译下一行，再运行，如此不停地进行下去。它会先将源码翻译成另一种语言，以供多次运行而无需再经编译。其制成品无需依赖编译器而运行，程序运行速度比较快。
即时编译(Just-in-time compilation: JIT)：又叫实时编译、及时编译。是指一种在运行时期把字节码编译成原生机器码的技术，一句一句翻译源代码，但是会将翻译过的代码缓存起来以降低性能耗损。这项技术是被用来改善虚拟机的性能的。
JIT编译器是JRE的一部分。原本的Java程序都是要经过解释执行的，其执行速度肯定比可执行的二进制字节码程序慢。为了提高执行速度，引入了JIT。在运行时，JIT会把翻译过来的机器码保存起来，以备下次使用。而如果JIT对每条字节码都进行编译，则会负担过重，所以，JIT只会对经常执行的字节码进行编译，如循环，高频度使用的方法等。它会以整个方法为单位，一次性将整个方法的字节码编译为本地机器码，然后直接运行编译后的机器码。
 深入理解java虚拟机（程序编译与代码优化）
编译对象与触发条件 编译对象 程序在运行过程中会被即时编译器编译的「热点代码」有两类：
 被多次调用的方法； 被多次执行的循环体。 这两种被多次重复执行的代码，称之为「热点代码」。  对于被多次调用的方法，方法体内的代码自然会被执行多次，理所当然的就是热点代码。
而对于多次执行的循环体则是为了解决一个方法只被调用一次或者少量几次，但是方法体内部存在循环次数较多的循环体问题，这样循环体的代码也被重复执行多次，因此这些代码也是热点代码。
对于第一种情况，由于是方法调用触发的编译，因此编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的 JIT 编译方式。而对于后一种情况，尽管编译动作是由循环体所触发的，但是编译器依然会以整个方法（而不是单独的循环体）作为编译对象。这种编译方式因为发生在方法执行过程中，因此形象地称之为栈上替换（On Stack Replacement，简称 OSR 编译，即方法栈帧还在栈上，方法就被替换了）。
即时编译器的触发条件 判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为「热点探测」。其实进行热点探测并不一定需要知道方法具体被调用了多少次，目前主要的热点探测判定方式有两种。
  基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是「热点方法」。基于采样的热点探测的好处是实现简单、高效，还可以很容易地获取方法调用关系（将调用栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因数的影响而扰乱热点探测。
  基于计数器的热点探测：采用这种方法的虚拟机会为每个方法（甚至代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是「热点方法」。这种统计方法实现起来麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是统计结果相对来说更加精确和严谨。
  HotSpot 虚拟机采用的是第二种：基于计数器的热点探测。因此它为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。在确定虚拟机运行参数的情况下，这两个计数器都有一个确定的阈值，当计数器超过阈值就会触发 JIT 编译。
方法调用计数器 顾名思义，这个计数器用于统计方法被调用的次数。当一个方法被调用时，会首先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在，则将此方法的调用计数器加 1，==然后判断方法调用计数器与回边计数器之和是否超过方法调用计数器的阈值==。如果超过阈值，将会向即时编译器提交一个该方法的代码编译请求。
如果不做任何设置，执行引擎不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译完成后，这个方法的调用入口地址就会被系统自动改写成新的，下一次调用该方法时就会使用已编译的版本。
热度衰减 如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器值就会被减少一半，这个过程称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的==半衰期==。
进行热度衰减的动作是在虚拟机进行 GC 时顺便进行的，可以设置虚拟机参数来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。此外还可以设置虚拟机参数调整半衰期的时间。
回边计数器 回边计数器的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为「回边」（Back Edge）。建立回边计数器统计的目的是为了触发 OSR 编译。
当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否已经有编译好的版本，如果有，它将优先执行已编译的代码，否则就把回边计数器值加 1，然后判断方法调用计数器和回边计数器值之和是否超过计数器的阈值。当超过阈值时，将会提交一个 OSR 编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。</description>
    </item>
    
    <item>
      <title>KaptGenerateViewModel</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/kaptgenerateviewmodel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/kaptgenerateviewmodel/</guid>
      <description>Kapt编译时生成Viewmodel Android架构组件拥有生命周期的自动管理和数据解耦等优秀的功能，能够将传统MVP架构进行替换。在使用架构组件的过程中，我采用的方式是首先完成基础类
T 表示对应的retrofit service类型
abstract class BaseViewModel&amp;lt;T&amp;gt;(application: Application) : AndroidViewModel(application) { 之后针对Retrofit中的不同Service interface，继承并实现具体的viewmodel类，并针对每个service接口，需要编写一个liveData字段和对应的get或post方法提供给app层调用，同时对应的方法可能会存在三种类型:
1:直接调用service进行网络获取 package com.xxx.xxx.architecture.xxx import android.app.Application import android.arch.lifecycle.MediatorLiveData import com.baseproject.architecture.BaseViewModel import com.xxx.xxx.appbase.BaseAppLiveDataObserver /** * This file is generated by kapt, please do not edit this file */ open class BaseAnchorServiceViewModel(application: Application) : BaseViewModel&amp;lt;AnchorService&amp;gt;(application) { val getHotAnchorListLiveData: MediatorLiveData&amp;lt;kotlin.collections.List&amp;lt;SearchHotAnchorModel&amp;gt;&amp;gt; by lazy { MediatorLiveData&amp;lt;kotlin.collections.List&amp;lt;SearchHotAnchorModel&amp;gt;&amp;gt;() } fun getHotAnchorList() { mService.getHotAnchorList().subscribe(BaseAppLiveDataObserver(getHotAnchorListLiveData)) } } 2：使用本地缓存展示之后进行网络获取更新 val getUserAssetsLiveData: MediatorLiveData&amp;lt;UserAssetsModel&amp;gt; by lazy { MediatorLiveData&amp;lt;UserAssetsModel&amp;gt;() } fun getUserAssets() { object : BaseAppNetworkBoundResource&amp;lt;UserAssetsModel&amp;gt;(getUserAssetsLiveData) { override fun doApiCall(): Observable&amp;lt;UserAssetsModel&amp;gt; { return mService.</description>
    </item>
    
    <item>
      <title>kernel</title>
      <link>https://huanle19891345.github.io/en/android/system/kernel/kernel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/kernel/kernel/</guid>
      <description>下载和编译内核步骤 Android 9.0内核编译
下载内核 cd kernel git clone https://android.googlesource.com/kernel/goldfish 执行完这两条命令后就可以看到kernel目录下有一个goldfish目录了,goldfish内核专门是提供给emulator用的.
cd goldfish git branch -r git checkout origin/android-goldfish-4.4-dev -b android-goldfish-4.4-dev 这里涉及到要下载哪个版本的内核,emulator命令默认用的是qemu内核, 一般跟这个版本的内核一样就可以了,可以直接启用emulator然后进入到Settings-&amp;gt;System-&amp;gt;About phone-&amp;gt;点击Android version,里面就有内核版本号.
编译内核 一定要和Android编译时lunch选的一样, 可以进入到out/target/product目录下查看自己编的是什么版本, 如果是generic_x86_64,那lunch的就是aosp_x86_64_eng的,其他版本依此类推. 接下来就可以编译了,下面我提供了几个编译的脚本大家可以进行对比和参照,lunch不同的版本对应的脚本是不一样的,即使编译通过了,也不能运行,我因为这个浪费了很长的时间 使用方法:
 在goldfish目录下创建一个build.sh文件 将脚本里面的内容复制到build.sh中,或者根据脚本自己写, 注意lunch的版本 执行chmod a+rx build.sh并且执行./build.sh.  aosp_x86-eng #指定编译的内核类型 export ARCH=x86 #指定的gcc编译器的前缀, 就是下面PATH中的x86_64-linux-android-4.9的前缀 export CROSS_COMPILE=x86_64-linux-android- export REAL_CROSS_COMPILE=x86_64-linux-android- #这里android_root要写是android根目录的绝对地址例如: ~/google/android-9.0 PATH=$PATH:/home/zhenghuan/Android/Source/android-9.0.0_r3/prebuilts/gcc/linux-x86/x86/x86_64-linux-android-4.9/bin #编译的配置,在arch/x86/configs目录下, make x86_64_ranchu_defconfig #编译内核命令 make -j16 编译内核大概10来分钟就可以完成了,之后会生成一个arch/x86_64/boot/bzImage的东西,不同kernel生成的是不一样的,要看清楚. 最后回到android根目录执行emulator -kernel kernel/goldfish/arch/x86/boot/bzImage启动虚拟机
启动虚拟机 ~/Android/Source/android-9.0.0_r3$ emulator -show-kernel -kernel /home/zhenghuan/Android/Source/kernel/goldfish/arch/x86/boot/bzImage -qemu -s  -kernel use specific emulated kernel 指定模拟器的内核，这里指定我们自己编译的内核arch/x86/boot/bzImage -qemu args.</description>
    </item>
    
    <item>
      <title>kotlin协程</title>
      <link>https://huanle19891345.github.io/en/kotlin/coroutine/kotlin%E5%8D%8F%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/kotlin/coroutine/kotlin%E5%8D%8F%E7%A8%8B/</guid>
      <description>协程是通过编译技术实现(不需要虚拟机VM/操作系统OS的支持),通过插入相关代码来生效！ 与之相反,线程/进程是需要虚拟机VM/操作系统OS的支持,通过调度CPU执行生效!
优秀文章 Kotlin Coroutines(协程) 完全解析（一），协程简介
Kotlin Coroutines(协程) 完全解析（二），深入理解协程的挂起、恢复与调度
Kotlin Coroutines(协程) 完全解析（三），封装异步回调、协程间关系及协程的取消
Kotlin Coroutines(协程) 完全解析（四），协程的异常处理
Kotlin Coroutines(协程) 完全解析（五），协程的并发
Structured concurrency
谷歌开发者 在 android 开发中使用协程 | 背景介绍
协程中的取消和异常 | 异常处理详解
官网doc 英文:
https://kotlinlang.org/docs/reference/coroutines/basics.html
https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/coroutines-guide.md
https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md
中文:
https://www.kotlincn.net/docs/reference/coroutines/coroutines-guide.html
和Android Jetpack结合 https://developer.android.com/topic/libraries/architecture/coroutines#lifecyclescope
https://developer.android.google.cn/kotlin/coroutines
异步编程模型 异步的含义是被调用的方法执行完之后，无法直接拿到返回值(切换了线程)，需要通过回调接收返回值
协程相当于提前切换到子线程，然后同步走逻辑，进而改变每一层的异步调用为同步，
协程将同步方法和线程切换两者相隔离，所有方法都是同步方法，单独控制执行线程，避免异步方法去接收回调参数
区别：
 回调调用时机: 回调接口可以有多个method，并在不同时机调用(对应的也可以在return对象中区分处理) 回调方法参数: 可以封装成method的return参数， 调用方上下文: 需要利用调用方的上下文(提供变量等)  异步回调 fun requestTokenAsync(cb: (Token) -&amp;gt; Unit) { ... } fun createPostAsync(token: Token, item: Item, cb: (Post) -&amp;gt; Unit) { .</description>
    </item>
    
    <item>
      <title>kotlin协程Source</title>
      <link>https://huanle19891345.github.io/en/kotlin/coroutine/kotlin%E5%8D%8F%E7%A8%8Bsource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/kotlin/coroutine/kotlin%E5%8D%8F%E7%A8%8Bsource/</guid>
      <description>总结 类设计 协程的三层包装  常用的launch和async返回的Job、Deferred，里面封装了协程状态，提供了取消协程接口，而它们的实例都是继承自AbstractCoroutine，它是协程的第一层包装。 第二层包装是编译器生成的SuspendLambda的子类，封装了协程的真正运算逻辑，继承自BaseContinuationImpl，其中completion属性就是协程的第一层包装。 第三层包装是前面分析协程的线程调度时提到的DispatchedContinuation，封装了线程调度逻辑，包含了协程的第二层包装。三层包装都实现了Continuation接口，通过代理模式将协程的各层包装组合在一起，每层负责不同的功能。  resumeWith CoroutineContext graph LR coroutineContext--&amp;gt;Element1[&amp;quot;Element1: a singleton context by itself.&amp;quot;] coroutineContext--&amp;gt;Element2[&amp;quot;Element2: a singleton context by itself.&amp;quot;] coroutineContext--&amp;gt;ContinuationInterceptor[&amp;quot;ContinuationInterceptor: DefaultDispatcher.&amp;quot;] coroutineContext--&amp;gt;CoroutineExceptionHandler[&amp;quot;CoroutineExceptionHandler: CoroutineExceptionHandlerImpl.&amp;quot;] coroutineContext--&amp;gt;ElementXxx[&amp;quot;ElementXxx: a singleton context by itself.&amp;quot;] 挂起和恢复设计 sequenceDiagram CurrentThreadType-&amp;gt;&amp;gt;DispatchedThreadType: dispatch activate DispatchedThreadType CurrentThreadType-&amp;gt;&amp;gt;CurrentThreadType: suspend coroutine and release thread DispatchedThreadType--&amp;gt;&amp;gt;CurrentThreadType: resume deactivate DispatchedThreadType graph LR subgraph 基础层 suspendCoroutine--&amp;gt;suspendCoroutineUninterceptedOrReturn suspendCancellableCoroutine--&amp;gt;suspendCoroutineUninterceptedOrReturn end subgraph 上层功能 delay--&amp;gt;suspendCancellableCoroutine withContext--&amp;gt;suspendCoroutineUninterceptedOrReturn awaitSuspend--&amp;gt;suspendCoroutineUninterceptedOrReturn yield--&amp;gt;suspendCoroutineUninterceptedOrReturn coroutineScope--&amp;gt;suspendCoroutineUninterceptedOrReturn end Coroutine构造和启动 CoroutineScope.launch public val coroutineContext: CoroutineContext launch本质上也是将用户配置的协程闭包作为一个suspend函数(()-&amp;gt;Unit,这里查看编译产物看到实际上是new了对应的suspendLamda子类但是尚未关联第一层的abstractCoroutine,需要在后续的create过程中重新构造该子类对象并提供第一层的对象),并将该函数在指定的dispatcher上执行，和withContext类似</description>
    </item>
    
    <item>
      <title>kotlin协程取消</title>
      <link>https://huanle19891345.github.io/en/kotlin/coroutine/kotlin%E5%8D%8F%E7%A8%8B%E5%8F%96%E6%B6%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/kotlin/coroutine/kotlin%E5%8D%8F%E7%A8%8B%E5%8F%96%E6%B6%88/</guid>
      <description>协程的取消 graph subgraph 协程 subgraph 挂起函数1 开始挂起函数1--&amp;gt;|执行|函数1执行中--&amp;gt;|3:需要函数1内协作判断isAlive,退出计算|函数1执行完成 end subgraph 挂起函数2 开始挂起函数2--&amp;gt;|执行|函数2执行中--&amp;gt;函数2执行完成 end 函数1执行完成--&amp;gt;resume--&amp;gt;开始挂起函数2 cancel--&amp;gt;|1:cpu密集计算类型:在该协程线程中修改协程job状态为canceling|函数1执行中 resume--&amp;gt;|2:DispatchedTask.run判断job状态|异常resume 开始挂起函数1--&amp;gt;|IO类型:cont.invokeOnCancellation|设置cancel时的处理方法 end runtask时对CancellationException的判断
协程的取消只是在协程的第一层包装中 AbstractCoroutine 中修改协程的状态，并没有影响到第二层包装中 BaseContinuationImpl 中协程的实际运算逻辑。所以协程的取消只是状态的变化，并不会取消协程的实际运算逻辑，看下面的代码示例：
fun main(args: Array&amp;lt;String&amp;gt;) = runBlocking { val job1 = launch(Dispatchers.Default) { repeat(5) { println(&amp;#34;job1 sleep ${it + 1}times&amp;#34;) delay(500) } } delay(700) job1.cancel() val job2 = launch(Dispatchers.Default) { var nextPrintTime = 0L var i = 1 while (i &amp;lt;= 3) { val currentTime = System.currentTimeMillis() if (currentTime &amp;gt;= nextPrintTime) { println(&amp;#34;job2 sleep ${i++}.</description>
    </item>
    
    <item>
      <title>kotlin协程异常</title>
      <link>https://huanle19891345.github.io/en/kotlin/coroutine/kotlin%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/kotlin/coroutine/kotlin%E5%8D%8F%E7%A8%8B%E5%BC%82%E5%B8%B8/</guid>
      <description>协程内部异常分类 graph LR 协程内部trycatch--&amp;gt;|非suspend方法|作为invokeSuspend内部状态机中的一个分支,分支内和非协程类似catch,协程无感知 协程内部trycatch--&amp;gt;|suspend方法|抛出异常(&amp;quot;resume流程invokeSuspend时ResultKt.throwOnFailure($result);抛出异常&amp;quot;) CancellationException--&amp;gt;参考协程取消 协程UncaughtException /** kotlin/util/Result.kt * Throws exception if the result is failure. This internal function minimizes * inlined bytecode for [getOrThrow] and makes sure that in the future we can * add some exception-augmenting logic here (if needed). */ @PublishedApi @SinceKotlin(&amp;#34;1.3&amp;#34;) internal fun Result&amp;lt;*&amp;gt;.throwOnFailure() { if (value is Result.Failure) throw value.exception } 协程UncaughtException 标记异常 internal abstract class BaseContinuationImpl( // This is `public val` so that it is private on JVM and cannot be modified by untrusted code, yet  // it has a public getter (since even untrusted code is allowed to inspect its call stack).</description>
    </item>
    
    <item>
      <title>LayoutInflater</title>
      <link>https://huanle19891345.github.io/en/android/system/layoutinflater/layoutinflater/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/layoutinflater/layoutinflater/</guid>
      <description>原理图 视图层级 AppCompatActivity.setContentView @Override public void setContentView(@LayoutRes int layoutResID) { getDelegate().setContentView(layoutResID); } AppCompatDelegateImpl.java
@Override public void setContentView(int resId) { ensureSubDecor(); ViewGroup contentParent = mSubDecor.findViewById(android.R.id.content); contentParent.removeAllViews(); LayoutInflater.from(mContext).inflate(resId, contentParent); } installDecor,createSubDecor private void ensureSubDecor() { if (!mSubDecorInstalled) { mSubDecor = createSubDecor(); } } private ViewGroup createSubDecor() { // Now let&amp;#39;s make sure that the Window has installed its decor by retrieving it  //确保优先初始化 DecorView  mWindow.getDecorView();//PhoneWindow  ViewGroup subDecor = null; //根据不同的设置来对 subDecor 进行初始化  if (!</description>
    </item>
    
    <item>
      <title>LayoutNode</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/compose/layoutnode/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/compose/layoutnode/</guid>
      <description>Measure原理图 graph TB XxModifier--&amp;gt;MeasureScope.measure(&amp;quot;MeasureScope.measure&amp;quot;)--&amp;gt;|1|measurable(&amp;quot;measurable.measure(constraints)&amp;quot;) measurable--&amp;gt;|1|performMeasure performMeasure--&amp;gt;|1|MeasureScope.measure MeasureScope.measure--&amp;gt;|2|MeasureScope.layout Draw原理图 graph TB InnerPlaceable.performDraw--&amp;gt;|forEach|drawChild(&amp;quot;child.draw(canvas)&amp;quot;)--&amp;gt;ViewLayer.drawLayer --&amp;gt;ViewLayer.dispatchDraw--&amp;gt;|drawBlock|LayoutNodeWrapper.invoke--&amp;gt;performDraw(&amp;quot;performDraw(canvas)&amp;quot;) --&amp;gt;|leafNode?|DrawModifier.ContentDrawScope.draw performDraw--&amp;gt;|parentNode?|InnerPlaceable.performDraw LayoutNode类设计图 classDiagram class IntrinsicMeasurable{ &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; +parentData: Any? } class Measurable { &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; +measure(constraints: Constraints): Placeable } IntrinsicMeasurable&amp;lt;|--Measurable Measurable&amp;lt;|--LayoutNode Measurable&amp;lt;|--OuterMeasurablePlaceable Measurable&amp;lt;|--LayoutNodeWrapper class Measured { &amp;lt;&amp;lt;interface&amp;gt;&amp;gt; +measuredWidth: Int +measuredHeight: Int } class Placeable { +place(x: Int, y: Int, zIndex: Float = 0f) } class LayoutNodeWrapper{ +layoutNode: LayoutNode +layer: OwnedLayer +performMeasure(constraints: Constraints)Placeable +draw(canvas: Canvas) } class OuterMeasurablePlaceable { +layoutNode: LayoutNode +outerWrapper: LayoutNodeWrapper } class LayoutNode { +innerLayoutNodeWrapper: LayoutNodeWrapper = InnerPlaceable(this) +outerMeasurablePlaceable = OuterMeasurablePlaceable(this, innerLayoutNodeWrapper) +outerLayoutNodeWrapper: LayoutNodeWrapper +mDrawScope: LayoutNodeDrawScope = sharedDrawScope } class ModifiedDrawNode{ +modifier: DrawModifier } class DelegatingLayoutNodeWrapper~T : Modifier.</description>
    </item>
    
    <item>
      <title>Lifecycle</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/1lifecycle/lifecycle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/1lifecycle/lifecycle/</guid>
      <description>设计图 https://developer.android.com/topic/libraries/architecture/lifecycle
生命周期感知型组件的最佳做法  使界面控制器（Activity 和 Fragment）尽可能保持精简。它们不应试图获取自己的数据，而应使用 ViewModel 执行此操作，并观察 LiveData 对象以将更改体现到视图中。 设法编写数据驱动型界面，对于此类界面，界面控制器的责任是随着数据更改而更新视图，或者将用户操作通知给 ViewModel。 将数据逻辑放在 ViewModel 类中。ViewModel 应充当界面控制器与应用其余部分之间的连接器。不过要注意，ViewModel 不负责获取数据（例如，从网络获取）。但是，ViewModel 应调用相应的组件来获取数据，然后将结果提供给界面控制器。 使用数据绑定在视图与界面控制器之间维持干净的接口。这样一来，您可以使视图更具声明性，并尽量减少需要在 Activity 和 Fragment 中编写的更新代码。如果您更愿意使用 Java 编程语言执行此操作，请使用诸如 Butter Knife 之类的库，以避免样板代码并实现更好的抽象化。 如果界面很复杂，不妨考虑创建 presenter 类来处理界面的修改。这可能是一项艰巨的任务，但这样做可使界面组件更易于测试。 避免在 ViewModel 中引用 View 或 Activity 上下文。如果 ViewModel 存在的时间比 Activity 更长（在配置更改的情况下），Activity 将泄漏并且不会获得垃圾回收器的妥善处置。 使用 Kotlin 协程管理长时间运行的任务和其他可以异步运行的操作。  </description>
    </item>
    
    <item>
      <title>LifecycleCoroutine</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/1lifecycle/lifecyclecoroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/1lifecycle/lifecyclecoroutine/</guid>
      <description>LifecycleCoroutine 图解 sequenceDiagram LifecycleCoroutineScopeImpl-&amp;gt;&amp;gt;LifecycleCoroutineScopeImpl: Lifecycle.coroutineScope.get(),register activate LifecycleCoroutineScopeImpl Note right of LifecycleCoroutineScopeImpl: lunch启动协程并lifecycle.addObserver deactivate LifecycleCoroutineScopeImpl LifecycleCoroutineScopeImpl-&amp;gt;&amp;gt;LifecycleCoroutineScopeImpl: onStateChanged回调时State.DESTROYED自动取消协程 LifecycleCoroutineScopeImpl-&amp;gt;&amp;gt;LifecycleCoroutineScopeImpl: launchWhenXxx activate LifecycleCoroutineScopeImpl LifecycleCoroutineScopeImpl-&amp;gt;&amp;gt;LifecycleController: new LifecycleController LifecycleController-&amp;gt;&amp;gt;LifecycleController: lifecycle.addObserver LifecycleController-&amp;gt;&amp;gt;DispatchQueue: dispatch lifecycle to LifecycleCoroutineScopeImpl-&amp;gt;&amp;gt;PausingDispatcher: withContext(PausingDispatcher, block) deactivate LifecycleCoroutineScopeImpl PausingDispatcher-&amp;gt;&amp;gt;PausingDispatcher: dispatchQueue.runOrEnqueue(block) activate PausingDispatcher PausingDispatcher-&amp;gt;&amp;gt;DispatchQueue: dispatch block to deactivate PausingDispatcher LifecycleCoroutineScopeImpl /** * [CoroutineScope] tied to this [LifecycleOwner]&amp;#39;s [Lifecycle]. * * This scope will be cancelled when the [Lifecycle] is destroyed. * * This scope is bound to * [Dispatchers.</description>
    </item>
    
    <item>
      <title>linux_io</title>
      <link>https://huanle19891345.github.io/en/linux/linux_io/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/linux/linux_io/</guid>
      <description>linux基础——linux下五种IO模型小结（阻塞IO、非阻塞IO、IO复用、信号驱动式IO、异步IO）
Java IO：阻塞/非阻塞式IO、同步/异步IO
Linux IO模式及 select、poll、epoll详解
IO操作两个阶段 再说一下IO发生时涉及的对象和步骤。以read函数举例，对于一个networkIO会涉及到两个系统对象，一个是调用这个IO的process (or thread)，另一个就是系统内核(kernel)。当一个read操作发生时，它会经历两个阶段：
（1）等待数据准备(Waitingfor the data to be ready)
（2）将数据从内核拷贝到进程中(Copyingthe data from the kernel to the process)
记住这两点很重要，因为这些IO Model的区别就是在两个阶段上各有不同的情况。是否阻塞说的是第一个阶段，即等待数据准备阶段是否会阻塞，而是否同步说的是第二阶段，即将数据从内核拷贝到进程这个真实的IO Operation操作阶段是否阻塞。
FileObserver基于inotify
Looper基于epoll
https://stackoverflow.com/questions/17207809/difference-between-inotify-and-epoll
inotify  inotify_init(void) creates inotify instance to read events from inotify_add_watch(int fd, const char * path, int mask) returns a watch fd around the file node behind the path inotify_rm_watch(int fd, int wd) stops watching for events on fd  epoll  epoll_create(void) creates epoll object epoll_ctl(int epfd, int op, int fd, struct epoll_event * event) sets up events to watch epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); blocks until event happens  The biggest difference is that epoll can be used for ANY fd.</description>
    </item>
    
    <item>
      <title>linuxApi</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/xcrash/linuxapi/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/xcrash/linuxapi/</guid>
      <description>dlsym https://linux.die.net/man/3/dlsym
void *dlsym(void *handle, const char *symbol); The function dlsym() takes a &amp;ldquo;handle&amp;rdquo; of a dynamic library returned by dlopen() and the null-terminated symbol name, returning the address where that symbol is loaded into memory.
pthread_create http://man7.org/linux/man-pages/man3/pthread_create.3.html
int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);  The pthread_create() function starts a new thread in the calling process. The new thread starts execution by invoking start_routine(); arg is passed as the sole argument of start_routine().</description>
    </item>
    
    <item>
      <title>LiveData</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/2livedata/livedata/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/2livedata/livedata/</guid>
      <description>类设计 androidx.lifecycle:lifecycle-livedata:2.0.0
androidx.lifecycle:lifecycle-livedata-core:2.0.0
observe private SafeIterableMap&amp;lt;Observer&amp;lt;? super T&amp;gt;, ObserverWrapper&amp;gt; mObservers = new SafeIterableMap&amp;lt;&amp;gt;(); observe @MainThread public void observe(@NonNull LifecycleOwner owner, @NonNull Observer&amp;lt;? super T&amp;gt; observer) { assertMainThread(&amp;#34;observe&amp;#34;); if (owner.getLifecycle().getCurrentState() == DESTROYED) { // ignore  return; } LifecycleBoundObserver wrapper = new LifecycleBoundObserver(owner, observer); ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper); if (existing != null &amp;amp;&amp;amp; !existing.isAttachedTo(owner)) { throw new IllegalArgumentException(&amp;#34;Cannot add the same observer&amp;#34; + &amp;#34; with different lifecycles&amp;#34;); } if (existing !</description>
    </item>
    
    <item>
      <title>LiveDataCoroutine</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/2livedata/livedatacoroutine/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/2livedata/livedatacoroutine/</guid>
      <description>@UseExperimental(ExperimentalTypeInference::class) fun &amp;lt;T&amp;gt; liveData( context: CoroutineContext = EmptyCoroutineContext, timeoutInMs: Long = DEFAULT_TIMEOUT, @BuilderInference block: suspend LiveDataScope&amp;lt;T&amp;gt;.() -&amp;gt; Unit ): LiveData&amp;lt;T&amp;gt; = CoroutineLiveData(context, timeoutInMs, block) CoroutineLiveData 图解 sequenceDiagram CoroutineLiveData-&amp;gt;&amp;gt;CoroutineLiveData: init activate CoroutineLiveData CoroutineLiveData-&amp;gt;&amp;gt;BlockRunner: new BlockRunner BlockRunner-&amp;gt;&amp;gt;CoroutineScope: new CoroutineScope deactivate CoroutineLiveData CoroutineLiveData-&amp;gt;&amp;gt;CoroutineLiveData: onActive activate CoroutineLiveData CoroutineLiveData-&amp;gt;&amp;gt;BlockRunner: blockRunner?.maybeRun() BlockRunner-&amp;gt;&amp;gt;CoroutineScope: runningJob = scope.launch CoroutineScope-&amp;gt;&amp;gt;CoroutineScope: block(liveDataScopeImpl) deactivate CoroutineLiveData CoroutineLiveData-&amp;gt;&amp;gt;CoroutineLiveData: onInactive activate CoroutineLiveData CoroutineLiveData-&amp;gt;&amp;gt;BlockRunner: blockRunner?.cancel() BlockRunner-&amp;gt;&amp;gt;CoroutineScope: cancellationJob = scope.launch deactivate CoroutineLiveData internal typealias Block&amp;lt;T&amp;gt; = suspend LiveDataScope&amp;lt;T&amp;gt;.</description>
    </item>
    
    <item>
      <title>Looper</title>
      <link>https://huanle19891345.github.io/en/android/system/handler/looper/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/handler/looper/</guid>
      <description>原理总结 Looper就是对epoll系统调用的封装层，屏蔽外部对epoll的直接使用
Looper 图解 sequenceDiagram rect rgb(199, 237, 204) Looper-&amp;gt;&amp;gt;Looper: Looper() activate Looper Looper-&amp;gt;&amp;gt;Looper: mWakeEventFd = eventfd Looper-&amp;gt;&amp;gt;Looper: rebuildEpollLocked activate Looper Looper-&amp;gt;&amp;gt;Looper: mEpollFd = epoll_create(EPOLL_SIZE_HINT) Note right of Looper: eventItem.events = EPOLLIN,eventItem.data.fd = mWakeEventFd Looper-&amp;gt;&amp;gt;Looper: epoll_ctl(mEpollFd, EPOLL_CTL_ADD, mWakeEventFd, &amp;amp; eventItem) Note right of Looper: 编译mRequests对每个子项进行下面的ctl,mRequests通过addFd添加元素 Looper-&amp;gt;&amp;gt;Looper: epoll_ctl(mEpollFd, EPOLL_CTL_ADD, request.fd, &amp;amp; eventItem) deactivate Looper deactivate Looper end rect rgb(199, 237, 204) Looper-&amp;gt;&amp;gt;Looper: addFd Note right of Looper: 将fd封装成request,epoll_ctl(mEpollFd, EPOLL_CTL_ADD, fd, &amp;amp;eventItem),use SimpleLooperCallback as adapter from handleEvent to callback function end rect rgb(199, 237, 204) Looper-&amp;gt;&amp;gt;Looper: pollOnce,开启for循环 activate Looper Note right of Looper: timeoutMillis由MessageQueue的next()方法提供，队列中有message时，时间为msg.</description>
    </item>
    
    <item>
      <title>MatrixGradlePlugin</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/apm/matrixgradleplugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/apm/matrixgradleplugin/</guid>
      <description>主流程 graph LR 注册plugin--&amp;gt;CollectDirectoryInputTask--&amp;gt;MethodCollector 注册plugin--&amp;gt;CollectJarInputTask--&amp;gt;MethodCollector--&amp;gt;MethodTracer 解决了很多Matrix自身的问题，参考同目录下&amp;laquo;Matrix接入后遇到的问题.md&amp;raquo;
MatrixPlugin.apply @Override void apply(Project project) { project.extensions.create(&amp;#34;matrix&amp;#34;, MatrixExtension) project.matrix.extensions.create(&amp;#34;trace&amp;#34;, MatrixTraceExtension) project.matrix.extensions.create(&amp;#34;removeUnusedResources&amp;#34;, MatrixDelUnusedResConfiguration) if (!project.plugins.hasPlugin(&amp;#39;com.android.application&amp;#39;)) { throw new GradleException(&amp;#39;Matrix Plugin, Android Application plugin required&amp;#39;) } project.afterEvaluate { def android = project.extensions.android def configuration = project.matrix android.applicationVariants.all { variant -&amp;gt; if (configuration.trace.enable) { com.tencent.matrix.trace.transform.MatrixTraceTransform.inject(project, configuration.trace, variant.getVariantData().getScope())//main  } if (configuration.removeUnusedResources.enable) { if (Util.isNullOrNil(configuration.removeUnusedResources.variant) || variant.name.equalsIgnoreCase(configuration.removeUnusedResources.variant)) { Log.i(TAG, &amp;#34;removeUnusedResources %s&amp;#34;, configuration.removeUnusedResources) RemoveUnusedResourcesTask removeUnusedResourcesTask = project.tasks.create(&amp;#34;remove&amp;#34; + variant.name.capitalize() + &amp;#34;UnusedResources&amp;#34;, RemoveUnusedResourcesTask) removeUnusedResourcesTask.</description>
    </item>
    
    <item>
      <title>MatrixResourcePlugin</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/apm/resource/matrixresourceplugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/apm/resource/matrixresourceplugin/</guid>
      <description>Summary:
 参考了leakcanary并进行优化，如哨兵，hprof裁剪等 dump hprof文件仍然在主进程，无法在线上使用 先dump hprof文件，后使用HprofVisitor进行裁剪压缩，而不是在dump的同时通过native hook直接裁剪 hprof文件的生成和分析相分离，分析过程在server端命令行执行分析任务  ResourcePlugin.init private final ResourceConfig mConfig; private ActivityRefWatcher mWatcher = null; @Override public void init(Application app, PluginListener listener) { super.init(app, listener); if (Build.VERSION.SDK_INT &amp;lt; Build.VERSION_CODES.ICE_CREAM_SANDWICH) { MatrixLog.e(TAG, &amp;#34;API is low Build.VERSION_CODES.ICE_CREAM_SANDWICH(14), ResourcePlugin is not supported&amp;#34;); unSupportPlugin(); return; } mWatcher = new ActivityRefWatcher(app, this); } ResourcePlugin.start @Override public void start() { super.start(); mWatcher.start(); } @Override public void stop() { super.stop(); mWatcher.stop(); } @Override public void destroy() { super.</description>
    </item>
    
    <item>
      <title>MatrixSource</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/apm/matrixsource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/apm/matrixsource/</guid>
      <description>MatrixPlugins设计 TracePlugin设计 main_title_sbuffer_array
main_title_structureddatatostack
其他main_title为UIThreadMonitor和LooperMonitor
StartupTracer /** * &amp;lt;p&amp;gt; * firstMethod.i LAUNCH_ACTIVITY onWindowFocusChange LAUNCH_ACTIVITY onWindowFocusChange * ^ ^ ^ ^ ^ * | | | | | * |---------app---------|---|---firstActivity---|---------...---------|---careActivity---| * |&amp;lt;--applicationCost--&amp;gt;| * |&amp;lt;--------------firstScreenCost--------------&amp;gt;| * |&amp;lt;---------------------------------------coldCost-------------------------------------&amp;gt;| * . |&amp;lt;-----warmCost----&amp;gt;| * * &amp;lt;/p&amp;gt; */ MatrixApplication.onCreate @Override public void onCreate() { super.onCreate(); Matrix.Builder builder = new Matrix.Builder(this); builder.patchListener(new TestPluginListener(this)); //trace  TraceConfig traceConfig = new TraceConfig.Builder() .dynamicConfig(dynamicConfig) .enableFPS(fpsEnable) .enableEvilMethodTrace(traceEnable) .enableAnrTrace(traceEnable) .enableStartup(traceEnable) .splashActivities(&amp;#34;sample.tencent.matrix.SplashActivity;&amp;#34;) .isDebug(true) .</description>
    </item>
    
    <item>
      <title>Matrix接入后遇到的问题</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/apm/matrix%E6%8E%A5%E5%85%A5%E5%90%8E%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/apm/matrix%E6%8E%A5%E5%85%A5%E5%90%8E%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>1：methodId差异 描述:
和热修复同时使用的问题，methodId差异导致dexdiff差异多大且main dex上每次都有diff
解决方案: 通过配置baseMethodMap给matrix，将基准包的methodMapping信息提供给在构建差分包的前期构建new apk时使用，是的new apk的方法映射和old apk一致
2: methodid映射为具体的方法签名 debug环境下需要自动将methodid映射为具体的方法签名，增强堆栈可读性
解决方案: 在debug环境下将methodMapping文件在packageDebug task执行前放入assets目录进而打包进apk，展示前将assets信息读取并用来解析methodId
3：上报过滤 统计堆栈信息有时除了Handler.dispatchMessage(Message message)占据大量时间(700ms以上)但其他methodItem占用时间都很少(700多项方法调用，每项占据的时间都不大，但总时间较长)，这种场景可以理解为在一次dispatchMessage中进行了过多任务的处理，每个任务都耗时不明显大，也是需要处理的。但还是要看清时间占用是在app中的方法还是系统方法里
比如dispatchMessage-&amp;gt;分发onCreate时间处理逻辑方法任务数量过多
4: androidPlugin版本过低2.1.0&amp;ndash;&amp;gt;3.2.1 matrix-gradle-plugin中android plugin版本过低2.1.0&amp;ndash;&amp;gt;3.2.1
普通java仓库先在构建过程确定依赖仓库的最新版本，但gradle plugin的构建过程在未确定依赖仓库的最新版本之前，只能使用自身配置的版本进行构建
2.1.0的android plugin版本再构建初期限制了构建者的android plugin版本也是2.1.0，因此需要升级
5: androidPlugin版本过低3.2.1&amp;ndash;&amp;gt;3.6.1 matrix-gradle-plugin中android plugin版本过低3.2.1&amp;ndash;&amp;gt;3.6.1
5.1 反射transformClassesWithDexBuilderForDebug/Release新版不存在 compile &amp;#39;com.android.tools.build:gradle:3.2.1&amp;#39; 此时如果exclude，会导致在新的gradle插件版本如3.6.1上，matrix plugin完全失效但没有报错信息
implementation(Libs.lib_matrxi_gradle_plugin) { exclude group: &amp;#39;com.android.tools.build&amp;#39; } 原因1:
从gradle3.2.1&amp;ndash;&amp;gt;3.6.1期间project.getTasks()发生了变化，原本
transformClassesWithDexBuilderFordebug和transformClassesWithDexFordebug两个任务不存在，
实际生效log:
[INFO][MatrixTraceTransform]successfully inject task:transformClassesWithDexBuilderForDebug [INFO][MatrixTraceTransform]successfully inject task:transformClassesWithDexBuilderForRelease
导致matrix插件反射修改的逻辑没有机会进入&amp;quot;successfully inject task&amp;quot;:
try { String[] hardTask = getTransformTaskName(extension.getCustomDexTransformName(), variant.getName()); for (Task task : project.getTasks()) { for (String str : hardTask) { if (task.</description>
    </item>
    
    <item>
      <title>Matrix研究</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/apm/matrix%E7%A0%94%E7%A9%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/apm/matrix%E7%A0%94%E7%A9%B6/</guid>
      <description>线上:
https://github.com/Tencent/matrix/wiki/Matrix-Android-TraceCanary
https://github.com/Tencent/matrix/wiki/Matrix-Android-IOCanary
线下:
https://github.com/Tencent/matrix/wiki/Matrix-Android-ResourceCanary
https://github.com/Tencent/matrix/wiki/Matrix-Android-SQLiteLint
https://github.com/Tencent/matrix/wiki/Matrix-Android-
 https://developer.android.com/topic/performance/vitals/launch-time
极客时间-Android开发高手课
07 | 启动优化（上）：从启动过程看启动速度优化
methodMapping.txt文件走向 transform中内存计算出methodMapping,
写入&amp;quot;${buildDir}/outputs/mapping/${currentVariantName}/methodMapping.txt&amp;quot;，之后拷贝到getAssembleOutputBakFile里,用于tinker，构建new apk时的baseMethodMapping
debug时写入buildDirPath + &amp;ldquo;/intermediates/merged_assets/debug/methodMapping.txt&amp;rdquo;,用于开发模式下自动转换堆栈信息
启动优化 https://developer.android.google.cn/topic/performance/vitals/launch-time
我以微信为例，用户从桌面点击图标开始，会经过 4 个关键阶段。
  T1 预览窗口显示。系统在拉起微信进程之前，会先根据微信的 Theme 属性创建预览窗口。当然如果我们禁用预览窗口或者将预览窗口指定为透明，用户在这段时间依然看到的是桌面。
  T2 闪屏显示。在微信进程和闪屏窗口页面创建完毕，并且完成一系列 inflate view、onmeasure、onlayout 等准备工作后，用户终于可以看到熟悉的“小地球”。
  T3 主页显示。在完成主窗口创建和页面显示的准备工作后，用户可以看到微信的主界面。
  T4 界面可操作。在启动完成后，微信会有比较多的工作需要继续执行，例如聊天和朋友圈界面的预加载、小程序框架和进程的准备等。在这些工作完成后，用户才可以真正开始愉快地聊天。
  问题 1：点击图标很久都不响应
如果我们禁用了预览窗口或者指定了透明的皮肤，那用户点击了图标之后，需要 T2 时间才能真正看到应用闪屏。对于用户体验来说，点击了图标，过了几秒还是停留在桌面，看起来就像没有点击成功，这在中低端机中更加明显。
问题 2：首页显示太慢
现在应用启动流程越来越复杂，闪屏广告、热修复框架、插件化框架、大前端框架，所有准备工作都需要集中在启动阶段完成。上面说的 T3 首页显示时间对于中低端机来说简直就是噩梦，经常会达到十几秒的时间。
问题 3：首页显示后无法操作。
既然首页显示那么慢，那我能不能把尽量多的工作都通过异步化延后执行呢？很多应用的确就是这么做的，但这会造成两种后果：要么首页会出现白屏，要么首页出来后用户根本无法操作。
启动优化方法  闪屏优化 业务梳理 业务优化 线程优化 从具体的做法来看，线程的优化一方面是控制线程数量，线程数量太多会相互竞争 CPU 资源，因此要有统一的线程池，并且根据机器性能来控制数量。 GC 优化 系统调用优化  启动进阶方法  I/O 优化 数据重排 2.</description>
    </item>
    
    <item>
      <title>measure</title>
      <link>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/measurelayoutdraw/measure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/measurelayoutdraw/measure/</guid>
      <description>原理总结 MeasureSpec MeasureSpec是View的内部类，内部封装了View的规格尺寸，以及View的宽高信息。在Measure的流程中，系统会将View的LayoutParams根据父容器是施加的规则转换为MeasureSpec，然后在onMeasure()方法中具体确定控件的宽高信息。源码及分析如下所示：
public static class MeasureSpec { //int类型占4个字节，其中高2位表示尺寸测量模式，低30位表示具体的宽高信息  private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &amp;lt;&amp;lt; MODE_SHIFT; /** @hide */ @IntDef({UNSPECIFIED, EXACTLY, AT_MOST}) @Retention(RetentionPolicy.SOURCE) public @interface MeasureSpecMode {} //如下所示是MeasureSpec中的三种模式：UNSPECIFIED、EXACTLY、AT_MOST  /** * Measure specification mode: The parent has not imposed any constraint * on the child. It can be whatever size it wants. */ public static final int UNSPECIFIED = 0 &amp;lt;&amp;lt; MODE_SHIFT; /** * Measure specification mode: The parent has determined an exact size * for the child.</description>
    </item>
    
    <item>
      <title>MessageLoop</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/messageloop/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/messageloop/</guid>
      <description>androidshellholder图解
TaskRunners::TaskRunners(std::string label, fml::RefPtr&amp;lt;fml::TaskRunner&amp;gt; platform, fml::RefPtr&amp;lt;fml::TaskRunner&amp;gt; gpu, fml::RefPtr&amp;lt;fml::TaskRunner&amp;gt; ui, fml::RefPtr&amp;lt;fml::TaskRunner&amp;gt; io) : label_(std::move(label)), platform_(std::move(platform)), gpu_(std::move(gpu)), ui_(std::move(ui)), io_(std::move(io)) {} ThreadHost::ThreadHost /// The collection of all the threads used by the engine. ThreadHost enum Type { Platform = 1 &amp;lt;&amp;lt; 0, UI = 1 &amp;lt;&amp;lt; 1, GPU = 1 &amp;lt;&amp;lt; 2, IO = 1 &amp;lt;&amp;lt; 3, }; std::unique_ptr&amp;lt;fml::Thread&amp;gt; platform_thread; std::unique_ptr&amp;lt;fml::Thread&amp;gt; ui_thread; std::unique_ptr&amp;lt;fml::Thread&amp;gt; gpu_thread; std::unique_ptr&amp;lt;fml::Thread&amp;gt; io_thread; ThreadHost(std::string name_prefix, uint64_t type_mask); ThreadHost::ThreadHost(std::string name_prefix, uint64_t mask) { if (mask &amp;amp; ThreadHost::Type::Platform) { platform_thread = std::make_unique&amp;lt;fml::Thread&amp;gt;(name_prefix + &amp;#34;.</description>
    </item>
    
    <item>
      <title>MethodChannel</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/methodchannel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/methodchannel/</guid>
      <description>整体设计 graph LR subgraph DartVM Dart(DartFramework)--&amp;gt;|await|Engine(EngineC++) end subgraph Platform Engine--&amp;gt;|GetPlatformTaskRunner-&amp;gt;PostTask|PlatformC++--&amp;gt;PlatformJava PlatformJava--&amp;gt;PlatformC++ PlatformC++--&amp;gt;|ui_task_runner_-&amp;gt;PostTask|Engine--&amp;gt;Dart end 传递数据编解码设计 数据反向也是类似的编解码
graph LR subgraph Dart MethodCallDart(&amp;quot;MethodCall:StringMethodName,ObjectArguments&amp;quot;)--&amp;gt;|encode|ByteBufferDart(&amp;quot;ByteDataDart&amp;quot;) end ByteBufferDart--&amp;gt;Transport--&amp;gt;|decode|MethodCallNative subgraph native MethodCallNative end EngineUi线程接收消息模块设计 graph TB subgraph DartUiThreadNative ALooper_pollOnce--&amp;gt;MessageLoopAndroid::OnEventFired --&amp;gt;Engine::DispatchPlatformMessage--&amp;gt;RuntimeController::DispatchPlatformMessage --&amp;gt;PlatformConfiguration::DispatchPlatformMessage--&amp;gt;tonic::DartInvoke end subgraph DartUiThreadDart tonic::DartInvoke--&amp;gt;binding.dart--&amp;gt;platform_channel.dart--&amp;gt;callHandler end 类结构设计 MethodChannel classDiagram class MethodChannel { String name MethodCodec codec BinaryMessenger binaryMessenger } class MethodCodec { encodeMethodCall(MethodCall methodCall)ByteData decodeMethodCall(ByteData? methodCall)MethodCall decodeEnvelope(ByteData envelope)dynamic encodeSuccessEnvelope(dynamic result)ByteData encodeErrorEnvelope(String code, String? message, dynamic details)ByteData } class BinaryMessenger{ handlePlatformMessage(String channel, ByteData?</description>
    </item>
    
    <item>
      <title>MMKV</title>
      <link>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/mmkv/mmkv/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E5%A4%9A%E8%BF%9B%E7%A8%8B/mmkv/mmkv/</guid>
      <description>参考 https://github.com/Tencent/MMKV/wiki/android_ipc
https://github.com/Tencent/MMKV/wiki/design
原理总结 MMKV 本质上是将文件 mmap 到内存块中，将新增的 key-value 统统 append 到内存中；到达边界后，进行重整回写以腾出空间，空间还是不够的话，就 double 内存空间；对于内存文件中可能存在的重复键值，MMKV 只选用最后写入的作为有效键值。
状态同步 写指针的同步 我们可以在每个进程内部缓存自己的写指针，然后在写入键值的同时，还要把最新的写指针位置也写到 mmap 内存中；这样每个进程只需要对比一下缓存的指针与 mmap 内存的写指针，如果不一样，就说明其他进程进行了写操作。事实上 MMKV 原本就在文件头部保存了有效内存的大小，这个数值刚好就是写指针的内存偏移量，我们可以重用这个数值来校对写指针。
内存重整的感知 考虑使用一个单调递增的序列号，每次发生内存重整，就将序列号递增。将这个序列号也放到 mmap 内存中，每个进程内部也缓存一份，只需要对比序列号是否一致，就能够知道其他进程是否触发了内存重整。
内存增长的感知 事实上 MMKV 在内存增长之前，会先尝试通过内存重整来腾出空间，重整后还不够空间才申请新的内存。所以内存增长可以跟内存重整一样处理。至于新的内存大小，可以通过查询文件大小来获得，无需在 mmap 内存另外存放。
挑选进程锁  文件锁，优点是天然 robust，缺点是不支持递归加锁，也不支持读写锁升级/降级，需要自行实现。 pthread_mutex，优点是 pthread 库支持递归加锁，也支持读写锁升级/降级，缺点是不 robust，需要自行清理。  文件锁 到这里我们已经完成了数据的多进程同步工作，是时候回头处理锁事了，亦即前面提到的递归锁和锁升级/降级。
递归锁 意思是如果一个进程/线程已经拥有了锁，那么后续的加锁操作不会导致卡死，并且解锁也不会导致外层的锁被解掉。对于文件锁来说，前者是满足的，后者则不然。因为文件锁是状态锁，没有计数器，无论加了多少次锁，一个解锁操作就全解掉。只要用到子函数，就非常需要递归锁。
锁升级/降级 锁升级是指将已经持有的共享锁，升级为互斥锁，亦即将读锁升级为写锁；锁降级则是反过来。文件锁支持锁升级，但是容易死锁：假如 A、B 进程都持有了读锁，现在都想升级到写锁，就会陷入相互等待的困境，发生死锁。另外，由于文件锁不支持递归锁，也导致了锁降级无法进行，一降就降到没有锁。
为了解决递归锁和锁升级/降级这两个难题，需要对文件锁(系统调用flock)进行封装，增加读锁、写锁计数器。处理逻辑如下表：
   读锁计数器 写锁计数器 加读锁 加写锁 解读锁 解写锁     0 0 加读锁 加写锁 - -   0 1 +1 +1 - 解写锁   0 N +1 +1 - -1   1 0 +1 解读锁再加写锁 解读锁 -   1 1 +1 +1 -1 加读锁   1 N +1 +1 -1 -1   N 0 +1 解读锁再加写锁 -1 -   N 1 +1 +1 -1 加读锁   N N +1 +1 -1 -1    需要注意的地方有两点：</description>
    </item>
    
    <item>
      <title>MultiDex</title>
      <link>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/multidex/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/multidex/</guid>
      <description>原理 Android5.0以下MultiDex下启动丝般柔滑 Android5.0及以上的设备在安装apk的时候就优化好了Multidex,所以在首次打开的时候执行,Multidex.install(this);并不会占用多少时间
当Android系统安装一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文件的效率要高很多。 但是在早期的Android系统中，DexOpt有一个问题，DexOpt会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个链表的长度是用一个short类型来保存的，导致了方法id的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。尽管在新版本的Android系统中，DexOpt修复了这个问题，但是我们仍然需要对低版本的Android系统做兼容。 比如:微信app经过分包后,我们解压其apk文件:
从中我们可以看到微信经过分包处理之后有3个dex文件
使用 (1)在App所属的build.gradle里面
android { ...... defaultConfig { multiDexEnabled true ...... } } (2)在你自定义的Application(这个一般项目里面都有) MultiDex.install(this);//初始化
 参考 美团Android DEX自动拆包及动态加载简介
http://allenfeng.com/2016/11/17/principle-analysis-on-multidex/
https://blog.csdn.net/dbs1215/article/details/79214565
https://developer.android.com/studio/build/multidex#multidexkeepfile-property</description>
    </item>
    
    <item>
      <title>native_hook</title>
      <link>https://huanle19891345.github.io/en/android/ndk/native_hook/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/ndk/native_hook/</guid>
      <description>对于 Native Hook 技术，我们比较熟悉的有 GOT/PLT Hook、Trap Hook 以及 Inline Hook，下面我来逐个讲解这些 Hook 技术的实现原理和优劣比较。
GOT/PLT Hook xHook https://github.com/iqiyi/xHook
https://github.com/iqiyi/xHook/blob/master/docs/overview/android_plt_hook_overview.zh-CN.md
  hook libc.so android_getaddrinfofornet ，貌似没hook成功 https://github.com/iqiyi/xHook/issues/16
  如何获取到被hook的方法的地址 https://github.com/iqiyi/xHook/issues/15
  PLT/GOT hook局限性 xhook只支持PLT/GOT方式的hook，就是hook“调用方so中的对外调用点”。android_getaddrinfofornet函数的实现在libc.so中，需要hook android_getaddrinfofornet的调用方，可以： xhook_register(&amp;#34;.*/libwebviewchromium\\.so$&amp;#34;, &amp;#34;android_getaddrinfofornet&amp;#34;, new_android_getaddrinfofornet, NULL); 不能做 ELF 内部函数之间调用的 hook。 inline hook 可以做到 demo执行步骤 1：下载Android NDK r16b，配置环境变量(每次重启PC都要配置一次) 2：./build_libs.sh通过cmd中单个执行编译完成 3：./install_libs.sh通过在cmd中执行: C:\Users\zhenghuan\git\demo\xHook&amp;gt;install_libs.sh 完成 如何引用系统so https://developer.android.com/ndk/guides/stable_apis.html?hl=zh-CN
https://stackoverflow.com/questions/13115827/how-to-link-to-the-libmedia-so-system-library-in-an-android-ndk-app-using-androi
InlineHook Android inline hook 浅析
什么是 inline hook  Inline hooking is a method of intercepting calls to target functions.</description>
    </item>
    
    <item>
      <title>nativeCrash1SystemHandle</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/nativecrash/nativecrash1systemhandle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/nativecrash/nativecrash1systemhandle/</guid>
      <description>从安卓 APP 开发的角度，Java 崩溃捕获相对比较容易，JVM 给 Java 字节码提供了一个受控的运行环境，同时也提供了完善的 Java 崩溃捕获机制。Native 崩溃的捕获和处理相对比较困难，安卓系统的==debuggerd 守护进程会为 native 崩溃自动生成详细的崩溃描述文件（tombstone）。==
在==开发调试阶段，可以通过系统提供的 bugreport 工具获取 tombstone 文件==（或者将设备 root 后也可以拿到）。但是对于发布到线上的安卓 APP，如何获取 tombstone 文件，安卓操作系统本身并没有提供这样的功能。这个问题一直是安卓 native 崩溃分析和移动端 APM 系统的痛点之一。
Tombstones https://source.android.com/devices/tech/debug/native-crash
https://source.android.com/devices/tech/debug/index.html#debuggerd
Before Android 8.0, crashes were handled by the debuggerd and debuggerd64 daemons. In Android 8.0 and higher, crash_dump32 and crash_dump64 are spawned as needed.</description>
    </item>
    
    <item>
      <title>nativeCrash2Monitor_CollectStack</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/nativecrash/nativecrash2monitor_collectstack/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/nativecrash/nativecrash2monitor_collectstack/</guid>
      <description>参考xcrashnativecrash源码分析
1 捕捉native crash的发生 信号 所有的信号量都定义在&amp;lt;signal.h&amp;gt;文件中:
#define SIGHUP 1 // 终端连接结束时发出(不管正常或非正常) #define SIGINT 2 // 程序终止(例如Ctrl-C) #define SIGQUIT 3 // 程序退出(Ctrl-\) #define SIGILL 4 // 执行了非法指令，或者试图执行数据段，堆栈溢出 #define SIGTRAP 5 // 断点时产生，由debugger使用 #define SIGABRT 6 // 调用abort函数生成的信号，表示程序异常 #define SIGIOT 6 // 同上，更全，IO异常也会发出 #define SIGBUS 7 // 非法地址，包括内存地址对齐出错，比如访问一个4字节的整数, 但其地址不是4的倍数 #define SIGFPE 8 // 计算错误，比如除0、溢出 #define SIGKILL 9 // 强制结束程序，具有最高优先级，本信号不能被阻塞、处理和忽略 #define SIGUSR1 10 // 未使用，保留 #define SIGSEGV 11 // 非法内存操作，与SIGBUS不同，他是对合法地址的非法访问，比如访问没有读权限的内存，向没有写权限的地址写数据 #define SIGUSR2 12 // 未使用，保留 #define SIGPIPE 13 // 管道破裂，通常在进程间通信产生 #define SIGALRM 14 // 定时信号, #define SIGTERM 15 // 结束程序，类似温和的SIGKILL，可被阻塞和处理。通常程序如果终止不了，才会尝试SIGKILL #define SIGSTKFLT 16 // 协处理器堆栈错误 #define SIGCHLD 17 // 子进程结束时, 父进程会收到这个信号。 #define SIGCONT 18 // 让一个停止的进程继续执行 #define SIGSTOP 19 // 停止进程,本信号不能被阻塞,处理或忽略 #define SIGTSTP 20 // 停止进程,但该信号可以被处理和忽略 #define SIGTTIN 21 // 当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号 #define SIGTTOU 22 // 类似于SIGTTIN, 但在写终端时收到 #define SIGURG 23 // 有紧急数据或out-of-band数据到达socket时产生 #define SIGXCPU 24 // 超过CPU时间资源限制时发出 #define SIGXFSZ 25 // 当进程企图扩大文件以至于超过文件大小资源限制 #define SIGVTALRM 26 // 虚拟时钟信号.</description>
    </item>
    
    <item>
      <title>nativeCrash3SymbolRecovery</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/nativecrash/nativecrash3symbolrecovery/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/nativecrash/nativecrash3symbolrecovery/</guid>
      <description>1. 获取crash日志信息  adb logcat 的堆栈轨迹 /data/tombstones/ 中的 tombstone  2. 使用addr2line或ndk-stack工具查看crash文件和行号 addr2line https://stackoverflow.com/questions/5314036/how-to-use-addr2line-in-android
Native crash异常，能定位到代码哪个地方报错吗 #18
arm-linux-androideabi-addr2line –e obj/local/armeabi/libhello-jni.so 00004de8 000056c8 00004fb4 00004f58 #这一步就该addr2line出场了。我们从backstrace中拿到了出错时的指令地址，它对应我们程序中某个函数的某行操作。我们需要addr2line将对应文件和对应行数打出来。这个命令的格式是 addr2line -e exefile addr #在NDK中找到对应的addr2line命令，testapp程序文件取出来，执行命令 [root@localhost]# /opt/android_tools/android-ndk-r20/toolchains/llvm/prebuilt/linux-x86_64/bin/arm-linux-androideabi-addr2line -f -e testapp 000a3f10 testGetEntryById /home/***/***/***/test.c:220 real command: $ Sdk/ndk-bundle/toolchains/llvm/prebuilt/windows-x86_64/bin/x86_64-linux-android-addr2line.exe -f -e ~/git/demo/xCrash/src/native/libxcrash/obj/local/x86_64/libxcrash.so 000000000000c2df xc_test_call_4 git/demo/xCrash/src/native/libxcrash/jni/xc_test.c:64 ndk-stack工具 https://developer.android.com/ndk/guides/ndk-stack?hl=zh-cn
https://help.aliyun.com/knowledge_detail/70180.html
adb shell logcat | ndk-stack -sym $PROJECT_PATH/obj/local/armeabi //需要-sym指定的目录中存在包含符号的so，系统system/lib下的so默认被strip导致没有符号 ndk-stack -sym ./workspace2/testNdkStack/obj/local/armeabi-v7a/ -dump ./logcat.log &amp;gt; result.log 在result.log中可以分析定位到出现该crash的对应代码文件和具体行数 real command: git\demo\xCrash\src\native\libxcrash\obj\local&amp;gt;ndk-stack -sym .</description>
    </item>
    
    <item>
      <title>nativeCrash4AnalysisRootCause</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/nativecrash/nativecrash4analysisrootcause/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/nativecrash/nativecrash4analysisrootcause/</guid>
      <description>汇编 ARM汇编指令集汇总
基本语法 汇编语言的主体是汇编指令。汇编指令和机器指令的差别在于指令的表示方法上。汇编指令是机器指令便于记忆的书写格式。
#操作：寄存器BX的内容送到AX中 1000100111011000 #机器指令 mov ax,bx #汇编指令 汇编语言语句的语法 汇编语言语句输入每行一个语句。每个语句如下的格式如下：
[label] mnemonic [operands] [;comment] 方括号中的字段是可选的。基本指令有两部分组成，第一个是要执行的指令（助记符）的名称和所述第二命令的操作数或参数的。
以下是一些典型的汇编语言语句的例子：
INC COUNT ; Increment the memory variable COUNT MOV TOTAL, 48 ; Transfer the value 48 in the  ; memory variable TOTAL ADD AH, BH ; Add the content of the  ; BH register into the AH register AND MASK1, 128 ; Perform AND operation on the  ; variable MASK1 and 128 ADD MARKS, 10 ; Add 10 to the variable MARKS MOV AL, 10 ; Transfer the value 10 to the AL register disassembler tool IDAPro is best disassembler tool for many processors and file types.</description>
    </item>
    
    <item>
      <title>Pigeon</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/pigeon/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E9%80%9A%E4%BF%A1/pigeon/</guid>
      <description>https://github.com/flutter/packages/tree/master/packages/pigeon
Pigeon介绍 Pigeon是Flutter官方推荐的，用于自动生成PlatformChannel通信层模板代码(channel定义，编解码，异常处理等)的package，可以减少通信层开发时间。生成的代码通过MessageChannel进行通信。pigeon则使用MessageChannel并针对每个api方法设置唯一的channelName来进行区分，BasicMessageChannel中的T,也就是request参数和response类型都是Object，并在传输过程中对model进行编解码成Map传输。
Pigeon功能 graph LR subgraph Pigeon/message.dart HostApi(&amp;quot;@HostApi&amp;quot;) FlutterApi(&amp;quot;@FlutterApi&amp;quot;) Class(&amp;quot;Define Class&amp;quot;) configurePigeon end subgraph server GenerateFlutterApi GenereateHostApi end subgraph client GenerateCallHostApi GenerateCallFullterApi end FlutterApi--&amp;gt;|handle in Flutter|GenerateFlutterApi(&amp;quot;abstract class FlutterApi:channel.setMessageHandler and delegate to FlutterApi&amp;quot;) GenerateCallHostApi(&amp;quot;class HostApi: wrap channel.send&amp;quot;)--&amp;gt;|Flutter to host|HostApi GenerateCallFullterApi(&amp;quot;classFlutterApi: wrap channel.send&amp;quot;)--&amp;gt;|host to Flutter|FlutterApi HostApi--&amp;gt;|handle in host|GenereateHostApi(&amp;quot;interface HostApi: channel.setMessageHandler and delegate to HostApi&amp;quot;) Pigeon 生成代码 Client端 class NativeNetworkApi { Future&amp;lt;Resource&amp;gt; request(RequestParams arg) async { final Object encoded = arg.encode(); const BasicMessageChannel&amp;lt;Object&amp;gt; channel = BasicMessageChannel&amp;lt;Object&amp;gt;(&amp;#39;dev.</description>
    </item>
    
    <item>
      <title>Qigsaw</title>
      <link>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/qigsaw/qigsaw/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/qigsaw/qigsaw/</guid>
      <description>爱奇艺重磅开源基于Android-App-Bundle动态化方案Qigsaw
Split APKs 加载
应用进程所使用到的 ClassLoader 和 Resources 均在LoadedAPK中创建。
通过 Android 9.0 LoadedAPK源码片段，我们一起了解下 Split APKs 加载过程。
ClassLoader 创建 通过createOrUpdateClassLoaderLocked方法名，可以知道该方法是用于创建和更新 ClassLoader。该方法有两个核心步骤。
1：如果mClassLoader为空，则创建 PathClassLoader 实例。
2：如果addedPaths不为空，则更新 PathClassLoader 实例。
该方法指明，应用进程是可以动态加载 Split APKs 代码。
Resources 创建 通过getResources方法代码片段，可知 Split APKs 的资源路径作为mResources创建参数。
关于更多 Split APKs 加载原理细节，请阅读相关 Android 源码。
第三方应用利用 PackageInstaller 安装 split APKs 体验极其不友好，且某些国产手机对 split APKs 功能支持不完善，所以我们最终还是按照一般插件化方式安装加载 split APKs。
依据上图，如果需要动态加载 split APKs，需要解决代码、资源以及四大组件的加载。
Split APKs 代码加载 针对 splits 代码加载，Qigsaw 采用单类加载器方式，即 base APK 和 split APKs 采用同一 ClassLoader 加载。</description>
    </item>
    
    <item>
      <title>ReComposition</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/compose/recomposition/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/compose/recomposition/</guid>
      <description>类设计 GeneratedClass JetnewsApp传递ComposableLambdaImpl:AppContent{}给JetnewsTheme @Composable fun JetnewsApp( appContainer: AppContainer, navigationViewModel: NavigationViewModel ) { //调用方法JetnewsTheme,并将AppContent闭包作为composableLambda传递给JetnewsTheme  JetnewsTheme { //每个调用位置都有一个特殊的key，这里是-819895379  AppContent( navigationViewModel = navigationViewModel, interestsRepository = appContainer.interestsRepository, postsRepository = appContainer.postsRepository ) } } @Composable fun JetnewsTheme( darkTheme: Boolean = isSystemInDarkTheme(), content: @Composable () -&amp;gt; Unit ) {......} public final class JetnewsAppKt { public static final void JetnewsApp(AppContainer appContainer, NavigationViewModel navigationViewModel, Composer $composer, int $changed) { int i;...... Composer $composer2 = $composer.startRestartGroup(1936574869, &amp;#34;C(JetnewsApp)35@1302L232:JetnewsApp.kt#x6nqmx&amp;#34;); if (($changed &amp;amp; 14) == 0) { i = ($composer2.</description>
    </item>
    
    <item>
      <title>Resource.arsc生成和结构</title>
      <link>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/tinker/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/resource.arsc%E7%94%9F%E6%88%90%E5%92%8C%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/tinker/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/resource.arsc%E7%94%9F%E6%88%90%E5%92%8C%E7%BB%93%E6%9E%84/</guid>
      <description>从资源ID获取字符串资源 String appName = getResources().getString(R.string.app_name); 从资源ID获取drawable资源的过程 Drawable drawable = getResources().getDrawable(R.drawable.background, getTheme()); 研究源码来源 tinker gradle plugin中的resourceParser ResDiffDecoder&amp;ndash;AbstractApkParser&amp;ndash;ResourceTableParser
AbstractApkParser.parseResourceTable private DexClass[] dexClasses; private ResourceTable resourceTable; private String manifestXml; private ApkMeta apkMeta; private Set&amp;lt;Locale&amp;gt; locales; private List&amp;lt;CertificateMeta&amp;gt; certificateMetaList; private static final Locale DEFAULT_LOCALE; private Locale preferredLocale; public void parseResourceTable() throws IOException { byte[] data = this.getFileData(&amp;#34;resources.arsc&amp;#34;); if (data == null) { this.resourceTable = new ResourceTable(); this.locales = Collections.emptySet(); } else { this.resourceTable = new ResourceTable(); this.</description>
    </item>
    
    <item>
      <title>Runtime_VisitRoots</title>
      <link>https://huanle19891345.github.io/en/android/art/alloc_gc/runtime_visitroots/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/alloc_gc/runtime_visitroots/</guid>
      <description>art/runtime/runtime.cc
Runtime::VisitRoots void Runtime::VisitRoots(RootVisitor* visitor, VisitRootFlags flags) { VisitNonConcurrentRoots(visitor, flags); VisitConcurrentRoots(visitor, flags); } VisitNonConcurrentRoots void Runtime::VisitNonConcurrentRoots(RootVisitor* visitor, VisitRootFlags flags) { VisitThreadRoots(visitor, flags); VisitNonThreadRoots(visitor); } VisitThreadRoots void Runtime::VisitThreadRoots(RootVisitor* visitor, VisitRootFlags flags) { thread_list_-&amp;gt;VisitRoots(visitor, flags); } art/runtime/thread_list.cc
ThreadList::VisitRoots void ThreadList::VisitRoots(RootVisitor* visitor, VisitRootFlags flags) const { MutexLock mu(Thread::Current(), *Locks::thread_list_lock_); for (const auto&amp;amp; thread : list_) { thread-&amp;gt;VisitRoots(visitor, flags); } } art/runtime/thread.cc
Thread::VisitRoots void Thread::VisitRoots(RootVisitor* visitor, VisitRootFlags flags) { if ((flags &amp;amp; VisitRootFlags::kVisitRootFlagPrecise) != 0) { VisitRoots&amp;lt;/* kPrecise */ true&amp;gt;(visitor); } else { VisitRoots&amp;lt;/* kPrecise */ false&amp;gt;(visitor); } } //define the meaning of enum RootType template &amp;lt;bool kPrecise&amp;gt; void Thread::VisitRoots(RootVisitor* visitor) { const pid_t thread_id = GetThreadId(); visitor-&amp;gt;VisitRootIfNonNull(&amp;amp;tlsPtr_.</description>
    </item>
    
    <item>
      <title>SaveAndRestoreInstanceState</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/3viewmodel/saveandrestoreinstancestate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/3viewmodel/saveandrestoreinstancestate/</guid>
      <description>转屏场景 数据保存 android/app/servertransaction/ActivityRelaunchItem.java
@Override public void execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions) { client.handleRelaunchActivity(mActivityClientRecord, pendingActions); } ActivityThread.handleRelaunchActivity @Override public void handleRelaunchActivity(ActivityClientRecord tmp, PendingTransactionActions pendingActions) { handleRelaunchActivityInner(r, configChanges, tmp.pendingResults, tmp.pendingIntents, pendingActions, tmp.startsNotResumed, tmp.overrideConfig, &amp;#34;handleRelaunchActivity&amp;#34;); } private void handleRelaunchActivityInner(ActivityClientRecord r, int configChanges, List&amp;lt;ResultInfo&amp;gt; pendingResults, List&amp;lt;ReferrerIntent&amp;gt; pendingIntents, PendingTransactionActions pendingActions, boolean startsNotResumed, Configuration overrideConfig, String reason) { // Preserve last used intent, it may be set from Activity#setIntent().  final Intent customIntent = r.activity.mIntent; // Need to ensure state is saved.</description>
    </item>
    
    <item>
      <title>SavedStateHandle</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/3viewmodel/savedstatehandle/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/3viewmodel/savedstatehandle/</guid>
      <description>原理图 sequenceDiagram ComponentActivity-&amp;gt;&amp;gt;ComponentActivity: onSaveInstanceState activate ComponentActivity ComponentActivity-&amp;gt;&amp;gt;SavedStateRegistryController: performSave activate SavedStateRegistryController SavedStateRegistryController-&amp;gt;&amp;gt;SavedStateRegistry: performSave deactivate SavedStateRegistryController deactivate ComponentActivity ComponentActivity-&amp;gt;&amp;gt;ComponentActivity: onCreate activate ComponentActivity ComponentActivity-&amp;gt;&amp;gt;SavedStateRegistryController: performRestore activate SavedStateRegistryController SavedStateRegistryController-&amp;gt;&amp;gt;SavedStateRegistry: performRestore deactivate SavedStateRegistryController deactivate ComponentActivity SavedStateViewModelFactory-&amp;gt;&amp;gt;SavedStateViewModelFactory: create activate SavedStateViewModelFactory SavedStateViewModelFactory-&amp;gt;&amp;gt;SavedStateHandleController: create SavedStateHandleController-&amp;gt;&amp;gt;SavedStateRegistry: consumeRestoredStateForKey SavedStateRegistry-&amp;gt;&amp;gt;SavedStateHandle: createHandle deactivate SavedStateViewModelFactory Demo // UserProfileViewModel class UserProfileViewModel( savedStateHandle: SavedStateHandle ) : ViewModel() { val userId : String = savedStateHandle[&amp;#34;uid&amp;#34;] ?: throw IllegalArgumentException(&amp;#34;missing user id&amp;#34;) val user : User = TODO() } // UserProfileFragment private val viewModel: UserProfileViewModel by viewModels( factoryProducer = { SavedStateViewModelFactory(this) } //新版这已经是by viewModels的默认factory  .</description>
    </item>
    
    <item>
      <title>SavingStates</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/3viewmodel/savingstates/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/3viewmodel/savingstates/</guid>
      <description>SavingStatesScope sequenceDiagram LocalPersistence-&amp;gt;&amp;gt;AMS: user open activity activate AMS AMS-&amp;gt;&amp;gt;ActivityViewModelScope: start activate AMS activate ActivityViewModelScope ActivityViewModelScope-&amp;gt;&amp;gt;Activity: start activate Activity AMS-&amp;gt;&amp;gt;ActivityViewModelScope: rotation/relaunch rect rgb(199, 237, 204) ActivityViewModelScope-&amp;gt;&amp;gt;Activity: rotation/relaunch Activity-&amp;gt;&amp;gt;Activity: destory,retainNonConfigurationInstance deactivate Activity Activity-&amp;gt;&amp;gt;Activity: launch,attach恢复lastNonConfigurationInstances activate Activity deactivate Activity end rect rgb(253, 245, 230) AMS-&amp;gt;&amp;gt;ActivityViewModelScope: killApplicatonOrActivity by system ActivityViewModelScope-&amp;gt;&amp;gt;AMS: onStop,saveInstanceState deactivate ActivityViewModelScope activate AMS deactivate AMS AMS-&amp;gt;&amp;gt;ActivityViewModelScope: restart activate ActivityViewModelScope AMS-&amp;gt;&amp;gt;ActivityViewModelScope: onstart,restoreInstanceState deactivate ActivityViewModelScope end deactivate AMS rect rgb(151,255,255) AMS-&amp;gt;&amp;gt;LocalPersistence: save data to local persistence LocalPersistence-&amp;gt;&amp;gt;AMS: user leave activity deactivate AMS LocalPersistence-&amp;gt;&amp;gt;AMS: next time user open activity activate AMS AMS-&amp;gt;&amp;gt;LocalPersistence: user restore data from local persistence deactivate AMS end options https://developer.</description>
    </item>
    
    <item>
      <title>Shadow</title>
      <link>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/shadow/shadow/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/shadow/shadow/</guid>
      <description>Shadow设计 Activity的生命周期问题，大方向的选择 其实我们早就在用一款也是基于代理组件转调插件组件的插件框架了。只不过这款插件框架用到了大量反射使用私有API，眼看着是不可能再Android 9.0上继续使用了。我们也调研了外界口碑最好的RePlugin。所以大概就这两种方向，一是用代理Activity作为壳子注册在宿主中真正运行起来，然后让它持有插件Activity，想办法在收到系统的生命周期方法调用时转调插件Activity的对应生命周期方法。二是Hack修改宿主PathClassLoader，让它能在收到系统查询AndroidManifest中注册的Activity的类时返回插件的Activity类。
方法二就是RePlugin的关键技术。它利用了JVM的特性。我也不太肯定这算不算是bug，总之ClassLoader的loadClass方法返回的实际类可以和它被要求加载的类名字不一样。举个例子，宿主的AndroidManifest.xml注册一个Activity名叫A，插件里有一个Activity名叫B。宿主代码或者apk中最终是没有A这个类的，只有在AndroidManifest中注册的一个名字而已。当想要加载插件Activity B时，就发出一个启动Activity A的Intent。系统收到这个Intent后会检查宿主安装的AndroidManifest信息，从中确定A是哪个apk安装的，就会找到宿主的PathClassLoader。然后系统就会试图从PathClassLoader中加载A这个类，然后作为Activity类型的对象使用（这很正常）。所以如果我们把宿主的PathClassLoader给Hack了，控制它的加载逻辑，让它收到这个加载调用时实际返回的是插件Activity B的类。由于B也真的是Activity的子类，所以系统拿回去当作Activity类型使用没有任何问题。这里再扩展一下，如果类C继承自类A，在加载C时也会去加载A，如果这时拿B当A返回的话，C收到B之后是会发现B的名字不是A而出错的。关于RePlugin这段关键技术的实现，当时调研时就发现实现的有些麻烦了。RePlugin选择复制一个PathClassLoader，然后替换系统持有的PathClassLoader。所以复制PathClassLoader需要反射使用PathClassLoader的私有API，拿出来它里面的数据，替换系统持有的PathClassLoader也要反射修改私有API。我们当时已经实现了“全动态插件框架”，其中代理壳子Activity的动态化使用的方法也能解决这个问题，我们的选择是在宿主PathClassLoader上给它加一个parent ClassLoader。因为PathClassLoader也是一个有正常“双亲委派”逻辑的ClassLoader，它加载什么类都会先问自己parent ClassLoader先加载。所以我们加上去的这个parent ClassLoader也能完成RePlugin想要做的事。不过我们用它的目的是不希望壳子Activity打包在宿主占用宿主很多方法数，还不能更新。这一点以后可能再单独讲。关于这个替换实现，最近给RePlugin提了一个PR：github.com/Qihoo360/Re… ，有兴趣的同学可以看一下。
RePlugin的这种方案还有一点非常不适合我们的业务，就是宿主AndroidManifest中注册的“坑位”Activity，就是上面举例的Activity A，是不能同时供多个插件Activity使用的。就是我不能在宿主AndroidManifest中注册一个Activity A，然后让它同时支持插件Activity B和C。这是因为ClassLoader在loadClass的时候，收到的参数只有一个A的类名，我们没有办法传递更多信息，让ClassLoader能在这个loadClass的调用中区分出应该返回B还是应该返回C。所以这种方案需要在宿主中注册大量Activity，这对于我们的宿主来说是不可接受的。而方法一是用代理Activity持有插件Activity转调的方案，就可以在启动代理Activity时通过Intent传递很多参数，代理Activity通过Intent中的参数就能决定该构造一个B还是一个C。这就使得这种方案下壳子是可复用的。
还有一点就是我们在旧框架上就已经设计了“全动态插件框架”，所以基于方法一的方向上开发新插件框架，我们可以不修改宿主的任何代码，不跟宿主版本就能更新插件框架。关于这一点，后续文章再解析。
所以我们探索的方向就这样确定在方法一这个方向上了。
所有的插件框架中，Activity的加载都是这样的，new一个DexClassLoader加载插件apk。然后从插件ClassLoader中load指定的插件Activity名字，newInstance之后强转为Activity类型使用。实际上Android系统自身在启动Activity时也是这样做的。所以这就是插件机制能动态更新Activity的基本原理。
所以，所有的插件框架在解决的问题都不是如何动态加载类，而是动态加载的Activity没有在AndroidManifest中注册，该如何能正常运行。如果Android系统没有AndroidManifest的限制，那么所有插件框架都没有存在的必要了。因为Java语言本身就支持动态更新实现的能力。
Shadow动态化原理 Shadow的全动态设计原理解析
打包在宿主中的只有core.common和dynamic.host。其余都是动态加载的，或者编译期的。
源码中的dynamic-host module中的接口pluginManager，dynamic-loader module,都对自己的能力做了接口抽象，用于运行时加载动态实现
dynamic-host module中的接口pluginManager在dynamic-manager内进行了实现，具体见&amp;quot;Shadow设计.vsdx&amp;quot;
Container动态化 PluginProcessService在void loadRuntime(String uuid)成功加载runtimeapk之后，判断如果加载了新的runtime，会将InstalledApk信息保存到sp。之后hackParentToRuntime时会new RuntimeClassLoader来设置为当前宿主PathClassLoader的parent，这样就可以实现宿主manifest文件中注册的代理容器Activity的动态加载:public class PluginDefaultProxyActivity extends PluginContainerActivity ,其中的@override方法可以不必一次全部实现，可以在业务需要时再添加
动态化加载manager 参考代码分析
loadParameters.dependsOn Shadow对插件包管理的设计
LoadApkBloc:: /** * 加载插件到ClassLoader中. * * @param installedPlugin 已安装（PluginManager已经下载解包）的插件 * @return 加载了插件的ClassLoader */ @Throws(LoadApkException::class) fun loadPlugin(installedApk: InstalledApk, loadParameters: LoadParameters, pluginPartsMap: MutableMap&amp;lt;String, PluginParts&amp;gt;): PluginClassLoader { val apk = File(installedApk.apkFilePath) val odexDir = if (installedApk.</description>
    </item>
    
    <item>
      <title>ShadowPlugin</title>
      <link>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/shadow/shadowplugin/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/shadow/shadowplugin/</guid>
      <description>ShadowTransform类设计 gradle配置 //Sample-plugin-app中build.gradle中对应的配置，动态生成config.json的一些参数  packagePlugin { pluginTypes { debug { loaderApkConfig = new Tuple2(&amp;#39;sample-loader-debug.apk&amp;#39;, &amp;#39;:sample-loader:assembleDebug&amp;#39;) runtimeApkConfig = new Tuple2(&amp;#39;sample-runtime-debug.apk&amp;#39;, &amp;#39;:sample-runtime:assembleDebug&amp;#39;) pluginApks { pluginApk1 { businessName = &amp;#39;sample-plugin-app&amp;#39; partKey = &amp;#39;sample-plugin-app&amp;#39; buildTask = &amp;#39;:sample-plugin-app:assembleDebug&amp;#39; apkName = &amp;#39;sample-plugin-app-debug.apk&amp;#39; apkPath = &amp;#39;projects/sample/sample-plugin/sample-plugin-app/build/outputs/apk/debug/sample-plugin-app-debug.apk&amp;#39; } } } release { loaderApkConfig = new Tuple2(&amp;#39;sample-loader-release.apk&amp;#39;, &amp;#39;:sample-loader:assembleRelease&amp;#39;) runtimeApkConfig = new Tuple2(&amp;#39;sample-runtime-release.apk&amp;#39;, &amp;#39;:sample-runtime:assembleRelease&amp;#39;) pluginApks { pluginApk1 { businessName = &amp;#39;sample-plugin-app&amp;#39; partKey = &amp;#39;sample-plugin-app&amp;#39; buildTask = &amp;#39;:sample-plugin-app:assembleRelease&amp;#39; apkName = &amp;#39;sample-plugin-app-release.apk&amp;#39; apkPath = &amp;#39;projects/sample/sample-plugin/sample-plugin-app/build/outputs/apk/release/sample-plugin-app-release.</description>
    </item>
    
    <item>
      <title>ShadowSource</title>
      <link>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/shadow/shadowsource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/shadow/shadowsource/</guid>
      <description>Shadow类设计和原理 Shadow核心功能 core层 = manager + loader, dynamic层用来动态化
打包在宿主中的只有core.common和dynamic.host。其余都是动态加载的，或者编译期的。
sequenceDiagram Note over Manager: host(位于主进程) Note over Loader: PluginProcessPPS(plugin进程) Manager-&amp;gt;&amp;gt;Manager: Manager动态化:通过接口PluginManager实现 Manager-&amp;gt;&amp;gt;Manager: 下载插件、安装插件,得到LoadParameters Manager-&amp;gt;&amp;gt;Loader: bindService Loader-&amp;gt;&amp;gt;Loader: Loader动态化:通过双向接口HostActivityDelegate和HostActivityDelegator实现 Loader-&amp;gt;&amp;gt;Loader: 将插件免安装的运行起来,代理壳子ContainerActivity需要和PluginActivity通过Loader相互调用 Manager 1：解压zip包到data目录下的指定路径下
2：解析config.json到PluginConfig
3：根据插件配置信息插入一组数据到db，返回InstalledPlugin
4：对runtime和loader两个apk做odex(更新odex信息到数据库，更新part.oDexDir)
5：对每个插件apk做extractSo(更新信息到数据库，更新part.libraryDir)和odex(更新odex信息到数据库，更新part.oDexDir)
6：bindPluginProgressService，加载runtime，加载loader，加载plugin，调用loader的convertActivityIntent转换intent为代理容器Activity
7：正常启动代理容器Activity
shadow的全动态设计原理解析
Manager的动态化 Shadow的Manager的功能就是管理插件，包括插件的下载逻辑、入口逻辑，预加载逻辑等。反正就是一切还没有进入到Loader之前的所有事情。
由于Manager就是一个普通类，不是Android系统规定要在Manifest中注册才能使用的类，所以Manager的动态化就是一般性的动态加载实现。
为了让宿主中的固定代码足够的少，我们给Manager定义的接口就是一个类似传统Main函数的接口。
void enter(Context context, long formId, Bundle bundle, EnterCallback callback); 这就是Manager的唯一方法，宿主中只会调用这个方法。传入当前界面的Context以便打开下一个插件Activity。将所有插件中可能用到的参数通过Bundle传给插件。定义一些fromId，用来让Manager的实现逻辑分辨这一次enter是从哪里来的。实际上在宿主中的每一处enter调用都可以设置不同的fromId，就相当于让Manager知道调用来自宿主中的哪一行代码了。再传入一个EnterCallback供Manager可以返回一个动态加载的View作为插件的Loading View。
Loader PpsBinder中Loader本身的Binder先通过PPS跨进程通信到Manager进程，从而使Loader的Binder成了跨进程的Binder
Loader的动态化 Loader就是负责加载插件Activity，然后实现插件Activity的生命周期等功能的那部分核心逻辑了。很多插件框架就只有Loader这部分功能，或者说只开源了Loader这部分功能。一般来说，Loader是宿主到插件的桥梁。比如说我们要在宿主中执行Loader的代码，才能Hack一些系统类，让它们加载插件Activity。或者在宿主中的代理壳子Activity中，也要使用Loader去加载插件Activity完成转调功能。所以通常宿主代码就直接依赖了Loader的代码。这就是为什么其他插件框架都需要将插件框架本身的代码打包在宿主中。
稍复杂一点的问题就是代理壳子ContainerActivity需要和PluginActivity通过Loader相互调用。所以Shadow应用前面提到的动态化原理时，做了双向的接口，可以看到代码中的HostActivityDelegate和HostActivityDelegator。通过定义出这两个接口，可以避免ContainerActivity和Loader相互加载对方时还需要加载对方所依赖的其他类。定义成接口，就只需要加载这个接口就行了。
通过这个设计，插件框架的绝大部分需要修改或修复的代码就都可以动态发布了。并且也使得在同一个宿主中可以有多个不同实现的Loader，这样业务就可以针对业务自身的bug修改Loader的代码，不会影响其他业务了。紧急情况下Loader也可以耦合业务逻辑。
宿主中的公共代码和资源的更新和修复可行性方案 graph LR subgraph 插件自带动态加载能力,可以更新功能,修复问题 宿主(&amp;quot;宿主(包含公共仓库资源)&amp;quot;)--&amp;gt;插件1,通过配置whiteList访问宿主公共资源 宿主--&amp;gt;插件2 宿主--&amp;gt;插件3 end 1：利用热修复方案如Tinker中的java修复部分替换宿主dex elements(atlas的host更新也使用的类似修复方案)，资源更新也采用相应的热修复方式进行
2：将公共代码和资源从组件做成插件，动态加载：</description>
    </item>
    
    <item>
      <title>SharedPreferences</title>
      <link>https://huanle19891345.github.io/en/android/%E5%AD%98%E5%82%A8/sharedpreferences/sharedpreferences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E5%AD%98%E5%82%A8/sharedpreferences/sharedpreferences/</guid>
      <description>1、加载/初始化 维护spName&amp;ndash;&amp;gt;file,file&amp;ndash;&amp;gt;sharedPreferencesImpl两个ArrayMap内存缓存 ContextImpl.java
@Override public SharedPreferences getSharedPreferences(String name, int mode) { File file; synchronized (ContextImpl.class) { if (mSharedPrefsPaths == null) { mSharedPrefsPaths = new ArrayMap&amp;lt;&amp;gt;(); } file = mSharedPrefsPaths.get(name); if (file == null) { file = getSharedPreferencesPath(name); mSharedPrefsPaths.put(name, file); } } return getSharedPreferences(file, mode); } @Override public SharedPreferences getSharedPreferences(File file, int mode) { SharedPreferencesImpl sp; synchronized (ContextImpl.class) { final ArrayMap&amp;lt;File, SharedPreferencesImpl&amp;gt; cache = getSharedPreferencesCacheLocked(); sp = cache.get(file); if (sp == null) { checkMode(mode); sp = new SharedPreferencesImpl(file, mode); cache.</description>
    </item>
    
    <item>
      <title>StackTraceElement</title>
      <link>https://huanle19891345.github.io/en/android/system/thread/stacktraceelement/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/thread/stacktraceelement/</guid>
      <description>9.0.0_r3
Throwable.getStackTrace public Throwable() { fillInStackTrace(); } public synchronized Throwable fillInStackTrace() { if (stackTrace != null || backtrace != null /* Out of protocol state */ ) { backtrace = nativeFillInStackTrace(); } return this; } fillInStackTrace art/runtime/native/java_lang_Throwable.cc
static jobject Throwable_nativeFillInStackTrace(JNIEnv* env, jclass) { ScopedFastNativeObjectAccess soa(env); return soa.Self()-&amp;gt;CreateInternalStackTrace&amp;lt;false&amp;gt;(soa); } template&amp;lt;bool kTransactionActive&amp;gt; jobject Thread::CreateInternalStackTrace(const ScopedObjectAccessAlreadyRunnable&amp;amp; soa) const { // Compute depth of stack, save frames if possible to avoid needing to recompute many.</description>
    </item>
    
    <item>
      <title>Stream</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9E%B6%E6%9E%84/stream/stream/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E5%93%8D%E5%BA%94%E5%BC%8F%E6%9E%B6%E6%9E%84/stream/stream/</guid>
      <description>Stream/BLoC https://www.didierboelens.com/2018/08/reactive-programming-streams-bloc/
Flutter中如何利用StreamBuilder和BLoC来控制Widget状态
Why use RxDart and how we can use with BLoC Pattern in Flutter?
What is a Stream? Introduction In order to easily visualize the notion of Stream, simply consider a pipe with 2 ends, only one allowing to insert something into it. When you insert something into the pipe, it flows inside the pipe and goes out by the other end.
In Flutter,
 the pipe is called a Stream to control the Stream, we usually(*) use a StreamController to insert something into the Stream, the StreamController exposes the “entrance&amp;quot;, called a StreamSink, accessible via the sink property the way out of the Stream, is exposed by the StreamController via the stream property  How do I know that something is conveyed by a Stream?</description>
    </item>
    
    <item>
      <title>SupportToAndroidx</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/supporttoandroidx/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/supporttoandroidx/</guid>
      <description>升级背景 为了升级公司客户端架构，促进更高效的开发效率，减少模板代码并提升稳定性，需要基础仓库从support迁移到androidx，并提供相应的升级方案以及基于androidx的基础组件。
模块拆分方式命名   不依赖support/androidx的模块称为pure模块
  依赖support的称为support模块
  依赖androidx的称为androidx模块
  升级方案  module内部，将原本的基础仓库old base module拆分为base_support + base_pure两个模块，剥离support依赖。其中base_pure模块拆分到一个单独的project中，而base_support项目需要新增base_androidx branch，分开两个branch迭代，并通过cherrypick进行修改同步，同时分别发布独立的maven。 old base module所依赖的模块，也需要按照1的方式进行拆分。同时pure模块只能依赖pure模块,非pure模块可以依赖对应的非pure模块和pure模块 pure模块的单测test模块是support或者androidx都没关系，不影响发版仓库中的内容 androidx利用灰度版本去进行测试  包依赖关系 graph TB app_support--&amp;gt;base_support app_support--&amp;gt;base_pure app_androidx--&amp;gt;base_androidx app_androidx--&amp;gt;base_pure base_support--&amp;gt;xxx_pure base_pure--&amp;gt;xxx_pure base_support--&amp;gt;xxx_support base_androidx--&amp;gt;xxx_androidx base_androidx--&amp;gt;xxx_pure 升级步骤 https://developer.android.google.cn/jetpack/androidx/migrate?hl=zh-cn
https://medium.com/androiddevelopers/migrating-to-androidx-tip-tricks-and-guidance-88d5de238876
是时候迁移至 AndroidX 了！
graph LR olderSupport--&amp;gt;|APIchanges|28.0.0Support--&amp;gt;|namespaceChanges|androidx1.0  创建新分支准备迁移，停止同步进行的新功能开发和重构，防止冲突 在old base module中搜索support进行处理,去除不必要的support库依赖 support升级到28，这是因为，1.0.0 版本的 AndroidX 工件是与支持库 28.0.0 工件等效的二进制文件。 编译和测试用例通过 配置android.useAndroidX=true android.enableJetifier=true 更新依赖的仓库到支持androidx的版本 迁移到androidx: AS操作 Refactor &amp;gt; Migrate to AndroidX  基于androidx的后续基础架构封装 新架构单独封装一个独立的module(使用androidx)，提供基础能力</description>
    </item>
    
    <item>
      <title>SurfaceViewSource</title>
      <link>https://huanle19891345.github.io/en/android/system/surfaceview/surfaceviewsource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/surfaceview/surfaceviewsource/</guid>
      <description>源码位置: frameworks/base/core/java/android/view/SurfaceView.java
surfaceView support scale and translation to its parent or itself
onAttachedToWindow @Override protected void onAttachedToWindow() { super.onAttachedToWindow(); getViewRootImpl().addWindowStoppedCallback(this); mWindowStopped = false; mViewVisibility = getVisibility() == VISIBLE; updateRequestedVisibility(); mAttachedToWindow = true; mParent.requestTransparentRegion(SurfaceView.this);//main  if (!mGlobalListenersAdded) { ViewTreeObserver observer = getViewTreeObserver(); observer.addOnScrollChangedListener(mScrollChangedListener); observer.addOnPreDrawListener(mDrawListener); mGlobalListenersAdded = true; } } requestTransparentRegion //ViewGroup  @Override public void requestTransparentRegion(View child) { if (child != null) { child.mPrivateFlags |= View.PFLAG_REQUEST_TRANSPARENT_REGIONS; if (mParent != null) { mParent.</description>
    </item>
    
    <item>
      <title>Syscall查找方式</title>
      <link>https://huanle19891345.github.io/en/android/system/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95/syscall%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E6%BA%90%E7%A0%81%E7%A0%94%E7%A9%B6%E6%96%B9%E6%B3%95/syscall%E6%9F%A5%E6%89%BE%E6%96%B9%E5%BC%8F/</guid>
      <description>Android9.0采用如下Tips3,4进行定位
Tips 1： 用户空间的方法xxx，对应系统调用层方法则是sys_xxx； Tips 2： unistd.h文件记录着系统调用中断号的信息。(搜索__SYSCALL找到unistd.d文件位置) /* kernel/signal.c */ __SYSCALL(__NR_kill, sys_kill) Tips 3： 宏定义SYSCALL_DEFINEx(xxx,…)，展开后对应的方法则是sys_xxx； Tips 4： 方法参数的个数x，对应于SYSCALL_DEFINEx。 kill(int pid, int sig)方法共两个参数，则对应方法于SYSCALL_DEFINE2(kill,...)，进入signal.c文件，再次搜索关键字，便能看到方法： include/linux/syscalls.h
syscalls.h #define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__) #define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__) #define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__) #define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__) #define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__) #define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)  #define SYSCALL_DEFINEx(x, sname, ...)	\ SYSCALL_METADATA(sname, x, __VA_ARGS__)	\ __SYSCALL_DEFINEx(x, sname, __VA_ARGS__)  #define __SYSCALL_DEFINEx(x, name, .</description>
    </item>
    
    <item>
      <title>SystemLoadLibrary</title>
      <link>https://huanle19891345.github.io/en/android/art/jni/systemloadlibrary/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/jni/systemloadlibrary/</guid>
      <description>图解 graph LR findLibrary--&amp;gt;mapLibraryName findLibrary--&amp;gt;NativeLibraryElement.findNativeLibrary nativeload--&amp;gt;JavaVMExt::LoadNativeLibrary--&amp;gt;checkCache(&amp;quot;library = libraries_-&amp;gt;Get(path);&amp;quot;) JavaVMExt::LoadNativeLibrary--&amp;gt;android_dlopen_ext JavaVMExt::LoadNativeLibrary--&amp;gt;dlsym--&amp;gt;JNI_OnLoad--&amp;gt;RegisterNatives--&amp;gt;ArtMethod::setEntryProintFromJni 动态链接器linker过程参考
Runtime.getRuntime().load /** * Loads the native library specified by the filename argument. The filename * argument must be an absolute path name. * (for example * &amp;lt;code&amp;gt;Runtime.getRuntime().load(&amp;#34;/home/avh/lib/libX11.so&amp;#34;);&amp;lt;/code&amp;gt;). */ public void load(String filename) { load0(VMStack.getStackClass1(), filename); } synchronized void load0(Class&amp;lt;?&amp;gt; fromClass, String filename) { if (!(new File(filename).isAbsolute())) { throw new UnsatisfiedLinkError(&amp;#34;Expecting an absolute path of the library: &amp;#34; + filename); } String error = nativeLoad(filename, fromClass.</description>
    </item>
    
    <item>
      <title>SystemServerSource</title>
      <link>https://huanle19891345.github.io/en/android/system/zygote/systemserversource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/zygote/systemserversource/</guid>
      <description>main /** * The main entry point from zygote. */ public static void main(String[] args) { new SystemServer().run(); } run private void run() { // The system server should never make non-oneway calls  Binder.setWarnOnBlocking(true); // Ensure binder calls into the system always run at foreground priority.  BinderInternal.disableBackgroundScheduling(true); // Increase the number of binder threads in system_server  BinderInternal.setMaxThreads(sMaxBinderThreads); // Prepare the main looper thread (this thread).  android.os.Process.setThreadPriority( android.</description>
    </item>
    
    <item>
      <title>TextureViewSource</title>
      <link>https://huanle19891345.github.io/en/android/system/textureview/textureviewsource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/textureview/textureviewsource/</guid>
      <description>//TextureView private TextureLayer mLayer; private SurfaceTexture mSurface; private SurfaceTextureListener mListener; public void setSurfaceTextureListener(SurfaceTextureListener listener) { mListener = listener; } draw @Override public final void draw(Canvas canvas) { mPrivateFlags = (mPrivateFlags &amp;amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* Simplify drawing to guarantee the layer is the only thing drawn - so e.g. no background, scrolling, or fading edges. This guarantees all drawing is in the layer, so drawing properties (alpha, layer paint) affect all of the content of a TextureView.</description>
    </item>
    
    <item>
      <title>ThreadLocal</title>
      <link>https://huanle19891345.github.io/en/android/system/handler/threadlocal/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/handler/threadlocal/</guid>
      <description>ThreadLocal模型 graph LR thread--&amp;gt;threadLocalMap threadLocalMap--&amp;gt;entry1 threadLocalMap--&amp;gt;entry2 threadLocalMap--&amp;gt;entryLooper threadLocalMap--&amp;gt;entryxxx entry1--&amp;gt;key=threadlocal1,value=T1 entry2--&amp;gt;key=threadlocal2,value=T2 entryLooper--&amp;gt;LooperEntry(key=threadlocal_Looper,value=Looper) LooperEntry--&amp;gt;MessageQueue  线性探测解决hash冲突 超过默认长度(16)的2/3时rehash减少hash冲突，扩容一倍 threadlocal作为key保存在entry中时是WeakReference，在被回收时清除记录，因此需要外部定义TheadLocal实例的地方配置为static，否则在外部回收threadlocal时，threadlocalmap中的entry也会被清理掉 lazy模式，只有添加第一个 元素时才通过createMap创建ThreadLocalMap  Thread /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; /* * InheritableThreadLocal values pertaining to this thread. This map is * maintained by the InheritableThreadLocal class. */ ThreadLocal.ThreadLocalMap inheritableThreadLocals = null; ThreadLocal threadLocalHashCode public class ThreadLocal&amp;lt;T&amp;gt; { /** * ThreadLocals rely on per-thread linear-probe hash maps attached * to each thread (Thread.</description>
    </item>
    
    <item>
      <title>ThreadPoolExecutor</title>
      <link>https://huanle19891345.github.io/en/java/threadpoolexecutor/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/java/threadpoolexecutor/</guid>
      <description>2.1 总体设计 继承关系 ThreadPoolExecutor实现的顶层接口是Executor，顶层接口Executor提供了一种思想：将任务提交和任务执行进行解耦。用户无需关注如何创建线程，如何调度线程来执行任务，用户只需提供Runnable对象，将任务的运行逻辑提交到执行器(Executor)中，由Executor框架完成线程的调配和任务的执行部分。ExecutorService接口增加了一些能力：（1）扩充执行任务的能力，补充可以为一个或一批异步任务生成Future的方法；（2）提供了管控线程池的方法，比如停止线程池的运行。AbstractExecutorService则是上层的抽象类，将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。最下层的实现类ThreadPoolExecutor实现最复杂的运行部分，ThreadPoolExecutor将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。
ThreadPoolExecutor是如何运行，如何同时维护线程和执行任务的呢？其运行机制如下图所示：
运行流程 线程池在内部实际上构建了一个生产者消费者模型，将线程和任务两者解耦，并不直接关联，从而良好的缓冲任务，复用线程。线程池的运行主要分成两部分：任务管理、线程管理。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。
接下来，我们会按照以下三个部分去详细讲解线程池运行机制：
 线程池如何维护自身状态。 线程池如何管理任务。 线程池如何管理线程。  2.2 生命周期管理 线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：
private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); ctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。这里都使用的是位运算的方式，相比于基本运算，速度也会快很多。
关于内部封装的获取生命周期状态、获取线程池线程数量的计算方法如以下代码所示：
private static int runStateOf(int c) { return c &amp;amp; ~CAPACITY; } //计算当前运行状态 private static int workerCountOf(int c) { return c &amp;amp; CAPACITY; } //计算当前线程数量 private static int ctlOf(int rs, int wc) { return rs | wc; } //通过状态和线程数生成ctl ThreadPoolExecutor的运行状态有5种，分别为：</description>
    </item>
    
    <item>
      <title>ThreadState</title>
      <link>https://huanle19891345.github.io/en/android/system/thread/threadstate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/thread/threadstate/</guid>
      <description>浅析android 线程状态 java的6种线程状态定义在/java/lang/Thread.java中:
https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.State.html
//Thread.java public class Thread implements Runnable { ... public enum State { /** * The thread has been created, but has never been started. */ NEW, /** * The thread may be run. */ RUNNABLE, /** * The thread is blocked and waiting for a lock. */ BLOCKED, /** * The thread is waiting. */ WAITING, /** * The thread is waiting for a specified amount of time.</description>
    </item>
    
    <item>
      <title>TinkerGradlePluginSource</title>
      <link>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/tinker/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tinkergradlepluginsource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/tinker/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tinkergradlepluginsource/</guid>
      <description>keyTitle_decoder类设计
keyTitle_dexsectiondiffalgorithm类设计
keyTitle_dexsectionpatchalgorithm类设计
build.gradle层 1：构建基准apk(仅仅发版时需要打开tinkerEnabled，开发自己debug时不需要打开)
1.1: Copy apk,map,R文件到bakApk目录下
1.2: 创建tinkerPatchDebug和tinkerPatchRelease的task执行的必要参数
//tinker/tinker-sample-android/app/build.gradle def bakPath = file(&amp;#34;${buildDir}/bakApk/&amp;#34;) /** \* you can use assembleRelease to build you base apk \* use tinkerPatchRelease -POLD_APK= -PAPPLY_MAPPING= -PAPPLY_RESOURCE= to build patch \* add apk from the build/bakApk */ ext { //for some reason, you may want to ignore tinkerBuild, such as instant run debug build?  tinkerEnabled = true //for normal build  //old apk file to build patch apk  tinkerOldApkPath = &amp;#34;${bakPath}/app-debug-0917-16-24-41.</description>
    </item>
    
    <item>
      <title>TinkerSource</title>
      <link>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/tinker/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tinkersource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%83%AD%E4%BF%AE%E5%A4%8D%E5%AD%97%E8%8A%82%E7%A0%81/tinker/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/tinkersource/</guid>
      <description>TinkerApplication.attachBaseContext /** \* tinkerFlags, which types is supported \* dex only, library only, all support \* default: TINKER_ENABLE_ALL */ private final int tinkerFlags; private final boolean tinkerLoadVerifyFlag; private final String delegateClassName; private final String loaderClassName; private ITinkerInlineFenceBridge mBridge = null; private static final String TINKER_LOADER_METHOD = &amp;#34;tryLoad&amp;#34;; @Override protected void attachBaseContext(Context base) { super.attachBaseContext(base); Thread.setDefaultUncaughtExceptionHandler(new TinkerUncaughtHandler(this)); onBaseContextAttached(base);//main  } private void onBaseContextAttached(Context base) { try { final long applicationStartElapsedTime = SystemClock.</description>
    </item>
    
    <item>
      <title>Touch</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/touch/touch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/touch/touch/</guid>
      <description>原理图 graph TB subgraph 3Down事件添加gestureRecognizer到pointerRouter,后续才会分发过来 pointerRouter.addRoute end subgraph 4分发pointerRouter.addRoute添加进来的监听 pointerRouter.route_event end subgraph 1Down事件时确定HitTestResult PointerDownEvent end subgraph 2发给HitTestResult每个元素 PointerAllEvent end PointerDownEvent--&amp;gt;|hitTest|HitTestResult--&amp;gt;HitTestTarget1 HitTestResult--&amp;gt;|RenderPointerListener.handleEvent|RawGestureDetectorState._handlePointerDown--&amp;gt;|addPointer_event|gestureRecognizer1 HitTestResult--&amp;gt;HitTestTargetXxx HitTestResult--&amp;gt;|handleEvent|GestureBinding.handleEvent--&amp;gt;pointerRouter.route_event GestureBinding.handleEvent--&amp;gt;|Down?|gestureArena.close GestureBinding.handleEvent--&amp;gt;|Up?|gestureArena.sweep RawGestureDetectorState._handlePointerDown--&amp;gt;|addPointer_event|gestureRecognizerXxx--&amp;gt;|Down|pointerRouter.addRoute gestureRecognizerXxx--&amp;gt;|Down|gestureArena.add PointerAllEvent--&amp;gt;|dispatchEvent|HitTestResult 类设计 GestureBinding.initInstances /// A binding for the gesture subsystem. //mixin GestureBinding on BindingBase implements HitTestable, HitTestDispatcher, HitTestTarget @override void initInstances() { super.initInstances(); _instance = this; window.onPointerDataPacket = _handlePointerDataPacket; } GestureBinding._handlePointerDataPacket void _handlePointerDataPacket(ui.PointerDataPacket packet) { // We convert pointer data to logical pixels so that e.</description>
    </item>
    
    <item>
      <title>touchEventNative</title>
      <link>https://huanle19891345.github.io/en/android/system/input/toucheventnative/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/input/toucheventnative/</guid>
      <description>原理图 static const char *WAKE_LOCK_ID = &amp;#34;KeyEvents&amp;#34;; static const char *DEVICE_PATH = &amp;#34;/dev/input&amp;#34;; SystemServer startOtherServices private void startOtherServices() { inputManager = new InputManagerService(context); wm = WindowManagerService.main(context, inputManager, mFactoryTestMode != FactoryTest.FACTORY_TEST_LOW_LEVEL, !mFirstBoot, mOnlyCore, new PhoneWindowManager()); ServiceManager.addService(Context.WINDOW_SERVICE, wm, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PROTO); ServiceManager.addService(Context.INPUT_SERVICE, inputManager, /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL); ...... inputManager.setWindowManagerCallbacks(wm.getInputMonitor()); inputManager.start(); } InputManagerService public class InputManagerService extends IInputManager.Stub { public InputManagerService(Context context) { this.mContext = context; this.mHandler = new InputManagerHandler(DisplayThread.</description>
    </item>
    
    <item>
      <title>TranscodingSource</title>
      <link>https://huanle19891345.github.io/en/%E6%96%B9%E5%90%91%E5%92%8C%E8%B6%8B%E5%8A%BF/%E9%9F%B3%E8%A7%86%E9%A2%91/ffmpeg/examples/transcodingsource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E6%96%B9%E5%90%91%E5%92%8C%E8%B6%8B%E5%8A%BF/%E9%9F%B3%E8%A7%86%E9%A2%91/ffmpeg/examples/transcodingsource/</guid>
      <description>https://www.ffmpeg.org/ffmpeg.html
Transcoding Detailed description The transcoding process in ffmpeg for each output can be described by the following diagram:
 _______ ______________ | | | | | input | demuxer | encoded data | decoder | file | ---------&amp;gt; | packets | -----+ |_______| |______________| | av_read_frame AVPacket v ---------&amp;gt; _________ | | | decoded |AVFrame | frames | |_________| ________ ______________ | | | | | |fliter | output | &amp;lt;-------- | encoded data | &amp;lt;----+ | file | muxer | packets | encoder |________| |______________| AVPacket ffmpeg calls the libavformat library (containing demuxers) to read input files and get packets containing encoded data from them.</description>
    </item>
    
    <item>
      <title>Transform</title>
      <link>https://huanle19891345.github.io/en/android/gradlejenkins/transform/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/gradlejenkins/transform/</guid>
      <description>注册Transform 1. //com.android.build.gradle.internal.dsl.BaseAppModuleExtension_Decorated实例 def android = project.extensions.getByType(AppExtension) 或 AppPlugin appPlugin = getProject().getPlugins().getPlugin(AppPlugin.class) //com.android.build.gradle.internal.dsl.BaseAppModuleExtension_Decorated实例 def android = appPlugin.getExtension() 2. android.registerTransform(new MyClassTransform(project));  Transform执行时机 图解 graph LR registerTransform--&amp;gt;addTransform(&amp;quot;BaseExtension.transforms.add(transform);&amp;quot;)--&amp;gt;|TaskManager.createPostCompilationTasks|transformManager.addTransform--&amp;gt;TransformTask.transform public abstract class BaseExtension implements AndroidConfig { public void registerTransform(@NonNull Transform transform, Object... dependencies) { transforms.add(transform); transformDependencies.add(Arrays.asList(dependencies)); } @Override @NonNull public List&amp;lt;Transform&amp;gt; getTransforms() { return ImmutableList.copyOf(transforms); } public abstract class TaskManager { public void createPostCompilationTasks( @NonNull final VariantScope variantScope) { // ----- External Transforms -----  // apply all the external transforms.</description>
    </item>
    
    <item>
      <title>Transformations</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/2livedata/transformations/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/2livedata/transformations/</guid>
      <description>map 图解 sequenceDiagram SourceLiveData-&amp;gt;&amp;gt;ResultMediatorLivedata: onChanged ResultMediatorLivedata-&amp;gt;&amp;gt;ResultMediatorLivedata: setValue(mapFunction.apply(x)) inline fun &amp;lt;X, Y&amp;gt; LiveData&amp;lt;X&amp;gt;.map(crossinline transform: (X) -&amp;gt; Y): LiveData&amp;lt;Y&amp;gt; = Transformations.map(this) { transform(it) } public static &amp;lt;X, Y&amp;gt; LiveData&amp;lt;Y&amp;gt; map( @NonNull LiveData&amp;lt;X&amp;gt; source, @NonNull final Function&amp;lt;X, Y&amp;gt; mapFunction) { final MediatorLiveData&amp;lt;Y&amp;gt; result = new MediatorLiveData&amp;lt;&amp;gt;(); result.addSource(source, new Observer&amp;lt;X&amp;gt;() { @Override public void onChanged(@Nullable X x) { result.setValue(mapFunction.apply(x)); } }); return result; } switchMap 图解 sequenceDiagram SourceLiveData-&amp;gt;&amp;gt;SwitchedLiveData: switchMapFunction.apply(x) SwitchedLiveData-&amp;gt;&amp;gt;ResultMediatorLivedata: onChanged ResultMediatorLivedata-&amp;gt;&amp;gt;ResultMediatorLivedata: setValue(y) inline fun &amp;lt;X, Y&amp;gt; LiveData&amp;lt;X&amp;gt;.</description>
    </item>
    
    <item>
      <title>TwoWayDataBinding</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/databinding/twowaydatabinding/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/databinding/twowaydatabinding/</guid>
      <description>https://developer.android.com/topic/libraries/data-binding/two-way
Infinite loops using two-way data binding Be careful not to introduce infinite loops when using two-way data binding. When the user changes an attribute, the method annotated using @InverseBindingAdapter is called, and the value is assigned to the backing property. This, in turn, would call the method annotated using @BindingAdapter, which would trigger another call to the method annotated using @InverseBindingAdapter, and so on.
For this reason, it&amp;rsquo;s important to break possible infinite loops by comparing new and old values in the methods annotated using @BindingAdapter.</description>
    </item>
    
    <item>
      <title>ViewModel</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/3viewmodel/viewmodel/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/3viewmodel/viewmodel/</guid>
      <description>类设计 基于androidx.lifecycle:lifecycle-viewmodel:2.1.0
保存viewModelStore handleDestroyActivity ActivityThread.java
@Override public void handleDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) {//转屏时传递的getNonConfigInstance为true  ActivityClientRecord r = performDestroyActivity(token, finishing, configChanges, getNonConfigInstance, reason); } handledestroyactivity由来
/** Core implementation of activity destroy call. */ ActivityClientRecord performDestroyActivity(IBinder token, boolean finishing, int configChanges, boolean getNonConfigInstance, String reason) { ActivityClientRecord r = mActivities.get(token); Class&amp;lt;? extends Activity&amp;gt; activityClass = null; if (r != null) { if (finishing) { r.activity.mFinished = true; } performPauseActivityIfNeeded(r, &amp;#34;destroy&amp;#34;); if (!</description>
    </item>
    
    <item>
      <title>ViewModelScope_Delegate</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/3viewmodel/viewmodelscope_delegate/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/3viewmodel/viewmodelscope_delegate/</guid>
      <description>ViewModel初始化委托 https://stackoverflow.com/questions/58106707/how-does-kotlin-use-this-by-delegate-to-instantiate-the-viewmodel
by viewModels(...) is part of fragment-ktx library, it&amp;rsquo;s a convienience short hand for creating a lazy delegate obtaining ViewModels.
// creates lazy delegate for obtaining zero-argument MyViewModel private val viewModel : MyViewModel by viewModels() // it&amp;#39;s functionally equal to: private val viewModel by lazy { ViewModelProvider(this).get(MyViewModel::class.java) } // with factory: private val viewModel : MyViewModel by viewModels { getViewModelFactory() } // is equal to: private val viewModel by lazy { ViewModelProvider(this, getViewModelFactory()).</description>
    </item>
    
    <item>
      <title>Vsync</title>
      <link>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/vsync/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/vsync/</guid>
      <description>原理图 Vsync App进程 graph TB DisplayEventDispatcher::scheduleVsync--&amp;gt;eventConnection.requestNextVsync sequenceDiagram participant JavaDispalyEventReveiver participant NativeDisplayEventReceiver participant Looper participant BitTube NativeDisplayEventReceiver-&amp;gt;&amp;gt;+Looper: looper.addFd Looper--&amp;gt;&amp;gt;-NativeDisplayEventReceiver: fd可读 NativeDisplayEventReceiver-&amp;gt;&amp;gt;+NativeDisplayEventReceiver: handleEvent NativeDisplayEventReceiver-&amp;gt;&amp;gt;-BitTube: recvObjects BitTube--&amp;gt;&amp;gt;NativeDisplayEventReceiver: return NativeDisplayEventReceiver-&amp;gt;&amp;gt;JavaDispalyEventReveiver:dispatchVsnc frameworks/base/libs/androidfw/DisplayEventDispatcher.cpp
DisplayEventDispatcher.cpp initialize status_t DisplayEventDispatcher::initialize() { status_t result = mReceiver.initCheck(); int rc = mLooper-&amp;gt;addFd(mReceiver.getFd(), 0, Looper::EVENT_INPUT, this, NULL); return OK; } handleEvent int DisplayEventDispatcher::handleEvent(int, int events, void*) { // Drain all pending events, keep the last vsync.  nsecs_t vsyncTimestamp; int32_t vsyncDisplayId; uint32_t vsyncCount; if (processPendingEvents(&amp;amp;vsyncTimestamp, &amp;amp;vsyncDisplayId, &amp;amp;vsyncCount)) { dispatchVsync(vsyncTimestamp, vsyncDisplayId, vsyncCount); } return 1; // keep the callback } scheduleVsync status_t DisplayEventDispatcher::scheduleVsync() { if (!</description>
    </item>
    
    <item>
      <title>Vsync_SurfaceFlinger</title>
      <link>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/vsync_surfaceflinger/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/vsync_surfaceflinger/</guid>
      <description>Android-SurfaceFlinger启动与绘图原理
创建 HWComposer 对象(通过 HAL 层的 HWComposer 硬件模块 或 软件模拟产生 Vsync 信号)，现在的 Android 系统基本上都可以看成是通过硬件 HWComposer 产生 Vsync 信号，而不使用软件模拟，所以下面解析都只谈及硬件 HWComposer 的 Vsync 信号；
Choreographer 会通过上面创建的 APP 延时源 mEventThreadSource 对象及其对应的 EventThread 线程来监听同步模拟发出的 Vsync 信号，然后进行绘制(measure/layout/draw)操作。具体逻辑见 Android-Choreographer原理。
SurfaceFlinger类设计 classDiagram IBinder&amp;lt;|--BBinder BBinder&amp;lt;|--BnInterface IInterface&amp;lt;|--ISurfaceComposer BnInterface&amp;lt;|--BnSurfaceComposer ISurfaceComposer&amp;lt;|--BnSurfaceComposer: 泛型类型 BnSurfaceComposer&amp;lt;|--SurfaceFlinger system/core/rootdir/init.rc
init.rc on property:vold.decrypt=trigger_restart_framework stop surfaceflinger start surfaceflinger # A/B update verifier that marks a successful boot. exec_start update_verifier class_start main class_start late_start frameworks/native/services/surfaceflinger/surfaceflinger.rc
surfaceflinger.rc service surfaceflinger /system/bin/surfaceflinger class core animation user system group graphics drmrpc readproc onrestart restart zygote writepid /dev/stune/foreground/tasks socket pdx/system/vr/display/client stream 0666 system graphics u:object_r:pdx_display_client_endpoint_socket:s0 socket pdx/system/vr/display/manager stream 0666 system graphics u:object_r:pdx_display_manager_endpoint_socket:s0 socket pdx/system/vr/display/vsync stream 0666 system graphics u:object_r:pdx_display_vsync_endpoint_socket:s0 frameworks/native/services/surfaceflinger/main_surfaceflinger.</description>
    </item>
    
    <item>
      <title>WebRTC源码下载和编译</title>
      <link>https://huanle19891345.github.io/en/%E6%96%B9%E5%90%91%E5%92%8C%E8%B6%8B%E5%8A%BF/%E9%9F%B3%E8%A7%86%E9%A2%91/webrtc/webrtc%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E6%96%B9%E5%90%91%E5%92%8C%E8%B6%8B%E5%8A%BF/%E9%9F%B3%E8%A7%86%E9%A2%91/webrtc/webrtc%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E5%92%8C%E7%BC%96%E8%AF%91/</guid>
      <description>下载和编译步骤 1. GET DEPOT TOOLS LINUX / MAC Clone the depot_tools repository:
$ git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git Add depot_tools to the front of your PATH (you will probably want to put this in your ~/.bashrc or ~/.zshrc). Assuming you cloned depot_tools to /path/to/depot_tools:
$ export PATH=/path/to/depot_tools:$PATH 2. 安装python 2.7 3. Download Source Create a working directory, enter it, and run:
$ fetch --nohooks webrtc_android //会在当前执行目录中下载文件到src文件夹 $ gclient sync 4. preCompile # 进入到src目录中 cd src # 执行完后，当前目录应为 /home/webrtc/webrtc_android/src # 下载 java相关命令和包，以及其他一些必要的软件和包 build/install-build-deps-android.</description>
    </item>
    
    <item>
      <title>WebView</title>
      <link>https://huanle19891345.github.io/en/android/ui/webview/webview/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/ui/webview/webview/</guid>
      <description>WebView优化 一般来说，WebView 渲染需要经过下面几个步骤
 解析 HTML 文件 加载 JavaScript 和 CSS 文件 解析并执行 JavaScript 构建 DOM 结构 加载图片等资源 页面加载完毕  而 loadFinish 实际上是在页面加载完毕阶段，而 DOM 构建完成时页面结构就已经基本渲染完成，所以从用户真实体验的角度出发，我们以 DOM 结构构建完成（即 domReady）的时间点作为页面加载完成时间点。
模板优化 模板拆分 原先:
优化后:
还能不能更快一点呢？当然能！
为了提高页面的加载速度，客户端通过一定的策略去预加载新闻数据，这样在理想状态下用户进入页面时看到页面时就可以直接使用缓存的数据，用户在看新闻的时候可以实现完全离线化，避免受到网络的影响。
模板预热 模板复用 网络优化 CDN 加速 渲染优化 服务端预渲染 客户端渲染 所以在详情页中，我们会将图片和视频等非文字内容通过原生组件的方式放在客户端进行渲染，既可以提高渲染效率，也可以减少不必要的流量消耗。
原生化渲染还有一个好处，图片越来越成为文章体验的重要部分，对于多图文章，我们在 Feed 页面也可以智能加载详情页需要的图片，增加用户的文章首屏体验。
白屏优化 而在 Android 中，我们采用的是自研内核 WebView，也会遇到一些奇奇怪怪的坑。
 多线程读模板文件问题，WebView 在运行中会读取的文件模板，如果此时另外一个线程同时更新模板文件时，就出现了模板加载问题，所以需要保证模板加载的原子性 Render 卡死问题，内核是一个比较复杂的逻辑，内部渲染极少数情况也会出现 Render 卡死问题，但是在详情页整体用户的量级下，即使只有十万分之一的可能，对用户来说也是一个比较大的问题，此时我们会从业务上做白屏监控进行重试  当然不管是 iOS 和 Android， WebView 加载的逻辑都比较复杂，有时候怎么重试也无法成功，这个时候我们会直接降级到加载线上的详情页，优先保证用户的体验。
总结 限于篇幅原因，我们还做了很多其他事情，包括请求精简，push 文章预拉取，数据注入的方式优化等等，也做了很多其他的方向的探索，这里不做展开，希望有机会能再分享给大家。
最后总结一下我们在优化详情页打开速度之后的一些想法
 数据很重要，我们在优化加载速度之前做的第一件事情其实是建立了一个详情页的数据看板，只有通过数据我们才能真正了解目前线上用户的现状，从真实用户的体验中找到瓶颈和优化点。 用户体验优先，优化方案有很多，除了加载速度之外，还需要从整体应用体验出发，选择对用户最佳的方案 追求极致，其实最开始的优化是比较简单的，但是越到后面越难，需要一点点抠细节，才能达到极致的用户体验  参考 WebView性能、体验分析与优化</description>
    </item>
    
    <item>
      <title>Widget</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E6%B8%B2%E6%9F%93/widget/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E6%B8%B2%E6%9F%93/widget/</guid>
      <description>graph LR State--&amp;gt;|持有|Widget Element--&amp;gt;|持有|State Element--&amp;gt;|持有|Widget Build 触发State.build时机 graph LR after_initState--&amp;gt;State.build after_didUpdateWidget--&amp;gt;State.build after_setState--&amp;gt;State.build after_dependencyChange--&amp;gt;State.build after_deactiveAndReinsertIntoTree--&amp;gt;State.build 挂载树核心方法调用 graph LR mount--&amp;gt;_firstBuild--&amp;gt;reBuild--&amp;gt;performRebuild--&amp;gt;|1|build--&amp;gt;|stateless|StatelessWidget.build build--&amp;gt;|stateful|State.build buildOwner.buildScope--&amp;gt;reBuild performRebuild--&amp;gt;|2|updateChild updateChild--&amp;gt;|优先更新而非重新创建child|canUpdate{&amp;quot;canUpdate?&amp;quot;}--&amp;gt;|yes|child.updateWithNewWidget; canUpdate--&amp;gt;|no|inflateWidgetForNewChildElement--&amp;gt;mount 挂载树挂载过程 graph TB parentElement--&amp;gt;|2:performRebuild|currentElement currentElement--&amp;gt;|1:mount|parentElement currentElement--&amp;gt;|3:buildMyWidget|currentElement currentElement--&amp;gt;|4:newWidget.createElement|childElement childElement--&amp;gt;|5:mount|currentElement 类设计 State.setState //State&amp;lt;T extends StatefulWidget&amp;gt; /** setState方法标记对应的element需要build 如果当前位于一帧内例如点击(input处理+动画+drawFrame)，在调用setState方法之后会触发drawFrame进而触发reBuild 如果当前不位于一帧内，则会策划一次frame*/ @protected void setState(VoidCallback fn) { final dynamic result = fn() as dynamic; _element.markNeedsBuild(); } Element.markNeedsBuild /// Marks the element as dirty and adds it to the global list of widgets to  /// rebuild in the next frame.</description>
    </item>
    
    <item>
      <title>WorkManager</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/workmanager/workmanager/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/workmanager/workmanager/</guid>
      <description>https://developer.android.com/topic/libraries/architecture/workmanager/
Android新技术之从Service到WorkManager
使用 WorkManager 处理需要立刻执行的后台任务
WorkManager 流程分析和源码解析 | 开发者说·DTalk
WorkManager 的特点与适用场景 特点   保证任务一定会被执行 WorkManager 有自己的数据库，每一个任务的信息与任务状态，都会保存在本地数据库中。所以即使程序没有在运行，或者在设备重启等情况下，WorkManager 依然可以保证任务的执行，只是不保证任务立即被执行。
  合理使用设备资源 在执行很多周期性或非立即执行的任务时，WorkManager 提供我们 API，帮助我们合理利用设备资源，避免不必要的内存，流量，电量等消耗。
  适用场景  可延迟进行的任务 a.满足某些条件才执行的任务，如需要在充电时才执行的任务。 b.用户无感知或可延迟感知的任务，如同步配置信息，同步资源，同步通讯录等。 定期重复性任务，但时效性要求不高的，如定期 log 上传，数据备份等。 退出应用后还应继续执行的未完成任务。  WorkManager 的使用 WorkManager 的使用非常简单，分为如下几个步骤:
 创建一个后台任务 Worker。 定义 WorkRequest，配置运行任务的方式和时间。 将任务提交给系统处理。 观察 Worker 的进度或状态。  WorkManager 流程分析与源码解析 这个章节将会从以下几个方面梳理 WorkManager 的流程与源码:
 创建 a. WorkManager的初始化 b. WorkRequest的创建 非约束条件任务的执行 带约束条件任务的执行  4.1 创建 首先梳理一下 WorkManager 的初始化过程。
4.1.1. WorkManager 的初始化 WorkManagerInitializer 在默认的情况下，WorkManager 并不是在我们调用 WorkManager.</description>
    </item>
    
    <item>
      <title>xCrashAnr</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/xcrash/xcrashanr/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/xcrash/xcrashanr/</guid>
      <description>总结 API level &amp;lt; 21 new FileObserver(&amp;quot;/data/anr/&amp;quot;, CLOSE_WRITE)
API level &amp;gt;= 21 SIGQUIT
ELFFormat 图解 sequenceDiagram SystemServer-&amp;gt;&amp;gt;xcc_signal_trace_register:SIGQUIT xcc_signal_trace_register-&amp;gt;&amp;gt;xcc_signal_trace_register:xc_trace_handler xcc_signal_trace_register-&amp;gt;&amp;gt;xc_trace_dumper:write(xc_trace_notifier, &amp;amp;data, sizeof(data) Note over xcc_signal_trace_register,xc_trace_dumper:和xc_trace_dumper线程通过阻塞式io通信 xc_trace_dumper-&amp;gt;&amp;gt;xc_trace_dumper: xc_trace_load_symbols activate xc_trace_dumper xc_trace_dumper-&amp;gt;&amp;gt;xc_trace_dumper: xc_dl_create Note right of xc_trace_dumper: xc_dl_find_map_start,/proc/self/maps中找到指定so,设置self-&amp;gt;map_start Note right of xc_trace_dumper: xc_dl_file_open(open and mmap so) Note right of xc_trace_dumper: xc_dl_parse_elf xc_trace_dumper-&amp;gt;&amp;gt;xc_trace_dumper: xc_dl_sym Note right of xc_trace_dumper: read each .symtab/.dynsym, 需要str_offset作为index指向的str等于当前目标str,则找到Sym Note right of xc_trace_dumper: (void *)(self-&amp;gt;map_start + sym-&amp;gt;st_value - self-&amp;gt;load_bias); deactivate xc_trace_dumper xc_trace_dumper-&amp;gt;&amp;gt;xc_trace_dumper: xc_trace_libart_runtime_dump activate xc_trace_dumper deactivate xc_trace_dumper Note right of xc_trace_dumper: 转调动态链接的系统so方法处理 Note right of xc_trace_dumper: Runtime::DumpForSigQuit(std::ostream&amp;amp; os)，dump本进程anr信息 xc_trace_init //xc_trace.</description>
    </item>
    
    <item>
      <title>xCrashNativeCrash</title>
      <link>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/xcrash/xcrashnativecrash/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E7%A8%B3%E5%AE%9A%E6%80%A7/%E5%BC%82%E5%B8%B8/xcrash/xcrashnativecrash/</guid>
      <description>原理时序图 sequenceDiagram CrashProcess-&amp;gt;&amp;gt;CrashProcess: xcc_signal_crash_register Note right of CrashProcess: 迭代注册每种信号监听,接收到信号调用xc_crash_signal_handler CrashProcess-&amp;gt;&amp;gt;CrashProcess: xc_crash_signal_handler(int sig, siginfo_t *si, void *uc) CrashProcess-&amp;gt;&amp;gt;DumperProcess: pid_t dumper_pid = xc_crash_fork(xc_crash_exec_dumper); CrashProcess-&amp;gt;&amp;gt;CrashProcess: waitpid(dumper_pid,...) Note right of CrashProcess: wait the crash dumper process terminated DumperProcess-&amp;gt;&amp;gt;DumperProcess: xc_crash_exec_dumper(void *arg) DumperProcess-&amp;gt;&amp;gt;DumperProcess: execl执行libxcrash_dumper.so.main activate DumperProcess DumperProcess-&amp;gt;&amp;gt;DumperProcess: xcd_process_create activate DumperProcess Note right of DumperProcess: 统计崩溃进程所有线程信息到队列xcd_core_proc-&amp;gt;thds，通过读取/proc/%d/task&amp;quot;, self-&amp;gt;pid实现 deactivate DumperProcess DumperProcess-&amp;gt;&amp;gt;CrashProcess: xcd_process_suspend_threads(xcd_core_proc) activate DumperProcess Note over DumperProcess,CrashProcess: suspend all threads in Crash process,通过系统调用ptrace(PTRACE_ATTACH, self-&amp;gt;tid,...))实现 deactivate DumperProcess DumperProcess-&amp;gt;&amp;gt;DumperProcess: xcd_process_load_info activate DumperProcess DumperProcess-&amp;gt;&amp;gt;DumperProcess: xcc_util_get_process_name activate DumperProcess Note right of DumperProcess: /proc/%d/cmdline,pid deactivate DumperProcess DumperProcess-&amp;gt;&amp;gt;DumperProcess: xcd_thread_load_info(&amp;amp;(thd-&amp;gt;t)); activate DumperProcess Note right of DumperProcess: 迭代每个线程,load thread info,&amp;quot;/proc/%d/comm&amp;quot;, tid,设置tname deactivate DumperProcess DumperProcess-&amp;gt;&amp;gt;DumperProcess: xcd_thread_load_regs(&amp;amp;(thd-&amp;gt;t)); activate DumperProcess Note right of DumperProcess: 迭代每个非crash线程,load thread regs,ptrace(PTRACE_GETREGSET, self-&amp;gt;tid.</description>
    </item>
    
    <item>
      <title>ZygoteSource</title>
      <link>https://huanle19891345.github.io/en/android/system/zygote/zygotesource/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/zygote/zygotesource/</guid>
      <description>原理图 sequenceDiagram ZygoteProcess-&amp;gt;&amp;gt;ZygoteProcess: ZygoteInit.main activate ZygoteProcess ZygoteProcess-&amp;gt;&amp;gt;SystemServerProcess: forkSystemServer activate SystemServerProcess SystemServerProcess-&amp;gt;&amp;gt;SystemServerProcess: handleSystemServerProcess activate SystemServerProcess SystemServerProcess-&amp;gt;&amp;gt;SystemServerProcess: ZygoteInit.zygoteInit deactivate SystemServerProcess activate SystemServerProcess SystemServerProcess-&amp;gt;&amp;gt;SystemServerProcess: SystemServer.main deactivate SystemServerProcess deactivate SystemServerProcess activate ZygoteProcess ZygoteProcess-&amp;gt;&amp;gt;ZygoteProcess: runSelectLoop SystemServerProcess-&amp;gt;&amp;gt;ZygoteProcess: notify activate ZygoteProcess ZygoteProcess-&amp;gt;&amp;gt;ZygoteProcess: processOneCommand ZygoteProcess-&amp;gt;&amp;gt;ChildAppProcess: Zygote.forkAndSpecialize deactivate ZygoteProcess activate ChildAppProcess ChildAppProcess-&amp;gt;&amp;gt;ChildAppProcess: handleChildProc activate ChildAppProcess ChildAppProcess-&amp;gt;&amp;gt;ChildAppProcess: ZygoteInit.zygoteInit deactivate ChildAppProcess activate ChildAppProcess ChildAppProcess-&amp;gt;&amp;gt;ChildAppProcess: ActivityThead.main deactivate ChildAppProcess deactivate ChildAppProcess deactivate ZygoteProcess deactivate ZygoteProcess ZygoteInit.main public static void main(String argv[]) { ZygoteServer zygoteServer = new ZygoteServer(); for (int i = 1; i &amp;lt; argv.</description>
    </item>
    
    <item>
      <title>Zygote进程</title>
      <link>https://huanle19891345.github.io/en/android/system/zygote/zygote%E8%BF%9B%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/zygote/zygote%E8%BF%9B%E7%A8%8B/</guid>
      <description>What is the Zygote copy-on-write heap?
All &amp;ldquo;Zygote-based&amp;rdquo; processes have memory pages that are identical among them.
Those pages are not copied, instead everything is linked to the same memory page. This reduces the amount on RAM used by all the &amp;ldquo;Zygote-based&amp;rdquo; processes.
If one of those process writes new data into such a page the page is automatically copied before the write actually takes place (because otherwise the memory of all forks would be changed).</description>
    </item>
    
    <item>
      <title>使用挂起函数来封装回调</title>
      <link>https://huanle19891345.github.io/en/kotlin/coroutine/%E4%BD%BF%E7%94%A8%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0%E6%9D%A5%E5%B0%81%E8%A3%85%E5%9B%9E%E8%B0%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/kotlin/coroutine/%E4%BD%BF%E7%94%A8%E6%8C%82%E8%B5%B7%E5%87%BD%E6%95%B0%E6%9D%A5%E5%B0%81%E8%A3%85%E5%9B%9E%E8%B0%83/</guid>
      <description>graph LR lifecycleScope--&amp;gt;|destory时通知|协程被取消 subgraph 协程挂起时,也就是异步任务执行时,需要考虑双向通知 协程被取消--&amp;gt;|cont.invokeOnCancellation通知|取消异步任务 异步任务被取消或异常--&amp;gt;|通知|取消协程/通知协程异常 end 参考 在 View 上使用挂起函数</description>
    </item>
    
    <item>
      <title>动画</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E5%8A%A8%E7%94%BB/%E5%8A%A8%E7%94%BB/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E5%8A%A8%E7%94%BB/%E5%8A%A8%E7%94%BB/</guid>
      <description>类设计 原理图 AnimationController() /// An [AnimationController] needs a [TickerProvider], which is configured using  /// the `vsync` argument on the constructor.  ///  /// The [TickerProvider] interface describes a factory for [Ticker] objects. A  /// [Ticker] is an object that knows how to register itself with the  /// [SchedulerBinding] and fires a callback every frame. The  /// [AnimationController] class uses a [Ticker] to step through the animation  /// that it controls.</description>
    </item>
    
    <item>
      <title>包体积压缩</title>
      <link>https://huanle19891345.github.io/en/android/%E5%8C%85%E4%BD%93%E7%A7%AF/%E5%8C%85%E4%BD%93%E7%A7%AF%E5%8E%8B%E7%BC%A9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E5%8C%85%E4%BD%93%E7%A7%AF/%E5%8C%85%E4%BD%93%E7%A7%AF%E5%8E%8B%E7%BC%A9/</guid>
      <description>AndroidBuildProcess Shrink your code To shrink your app’s code, R8 first determines all entry points into your app’s code based on the combined set of configuration files. These entry points include all classes that the Android platform may use to open your app’s Activities or services. Starting from each entry point, R8 inspects your app’s code to build a graph of all methods, member variables, and other classes that your app might access at runtime.</description>
    </item>
    
    <item>
      <title>匿名共享内存Ashmem</title>
      <link>https://huanle19891345.github.io/en/android/system/ashmem/%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98ashmem/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/ashmem/%E5%8C%BF%E5%90%8D%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98ashmem/</guid>
      <description>原理图 sequenceDiagram sharedMemory-&amp;gt;&amp;gt;+ashmem_dev: 1: ashmem_create_region ashmem_dev-&amp;gt;&amp;gt;ashmem_dev : fd = __ashmem_open() 创建ashmem_area放入file-&amp;gt;private_data ashmem_dev-&amp;gt;&amp;gt;ashmem_dev: ioctl(fd, ASHMEM_SET_NAME, buf) ashmem_dev-&amp;gt;&amp;gt;ashmem_dev: ioctl(fd, ASHMEM_SET_SIZE, size) ashmem_dev-&amp;gt;&amp;gt;-sharedMemory: fd sharedMemory-&amp;gt;&amp;gt;+Os : 2: mmap Os-&amp;gt;&amp;gt;-ashmem : ashmem_mmap ashmem-&amp;gt;&amp;gt;+shmem: vmfile = shmem_file_setup shmem-&amp;gt;&amp;gt;shmem: shmem_get_inode shmem-&amp;gt;&amp;gt;-shmem: alloc_file ashmem-&amp;gt;&amp;gt;shmem: shmem_set_file sharedMemory-&amp;gt;&amp;gt;ashmem_dev: 3: native_write ashmem_dev-&amp;gt;&amp;gt;ashmem: unpinned &amp;amp;&amp;amp; ashmem_pin_region ashmem_dev-&amp;gt;&amp;gt;shmem: env-&amp;gt;GetByteArrayRegion shmem-&amp;gt;&amp;gt;+shmem: shmem_fault Note right of shmem: 触发缺页中断 shmem-&amp;gt;&amp;gt;-shmem: shmem_getpage分配真实物理页 ashmem_dev-&amp;gt;&amp;gt;ashmem: ashmem_unpin_region MemoryFile public MemoryFile(String name, int length) throws IOException { try { mSharedMemory = SharedMemory.</description>
    </item>
    
    <item>
      <title>后台任务处理</title>
      <link>https://huanle19891345.github.io/en/android/system/%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1/%E5%90%8E%E5%8F%B0%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86/</guid>
      <description>https://developer.android.com/guide/background/
图 1. 此决策树可帮助您确定哪个类别最适合您的后台任务。
推荐的解决方案 下面几部分将介绍针对各个后台任务类型的推荐解决方案。
即时任务 对于应在用户离开特定作用域或完成某项互动时结束的任务，我们建议使用 Kotlin 协程。许多 Android KTX 库都包含适用于常见应用组件（如 ViewModel）和常见应用生命周期的现成可用的协程作用域。
如果您是 Java 编程语言用户，请参阅 Android 上的线程处理，了解推荐的选项。
对于应立即执行并需要继续处理的任务，即使用户将应用放在后台运行或重启设备，我们也建议使用 WorkManager 并利用其对长时间运行的任务的支持。
在特定情况下（例如使用媒体播放或主动导航功能时），您可能希望直接使用前台服务。
延期任务 凡是不直接与用户互动相关且日后可随时运行的任务，都可以延期执行。建议为延期任务使用 WorkManager 解决方案。
如果您希望某些可延期异步任务即使在应用退出或设备重启后仍能正常运行，使用 WorkManager 可以轻松地调度这些任务。如需了解如何调度这些类型的任务，请参阅 WorkManager 相关文档。
精确任务 需要在精确时间点执行的任务可以使用 AlarmManager。
如需详细了解 AlarmManager，请参阅设置重复闹铃时间。</description>
    </item>
    
    <item>
      <title>埋点</title>
      <link>https://huanle19891345.github.io/en/android/%E5%9F%8B%E7%82%B9/%E5%9F%8B%E7%82%B9/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E5%9F%8B%E7%82%B9/%E5%9F%8B%E7%82%B9/</guid>
      <description>功能需求：
我们希望提供以下功能
 和业务无关的代码，我们希望能够以无需手动埋点的方式进行监控，包括页面生命周期、JSON耗时，网络耗时、SQL查询耗时、点击事件、页面进入等 对特定方法进行耗时监控，我们希望用户给方法加上注解就可以，称之为半埋点 编译期，需要能够支持配置，包括对哪些页面、哪些操作进行监控 运行期，能够动态下发配置，包括各类耗时监控的上报开关和阈值等  代码埋点 **代码埋点是指在某个事件发生时调用数据发送接口上报数据。**例如开发人员按照产品/运营的需求，在Web页面/App的源码里面添加行为上报的代码，当用户的行为满足某一个条件时，这些代码就会被执行，向服务器上报行为数据。这种方案是最基础的方案，每次增加或者修改数据上报的条件，都需要开发人员的参与，并且只能在下一个版本上线后才能看到效果。基本上所有的数据平台都提供了这类数据上报的SDK，将行为上报的后台服务器接口封装成了简单的客户端SDK接口。开发者可以通过嵌入这类SDK，在埋点的地方调用少量的代码就可以上报行为数据。
全埋点 全埋点指的是将Web页面/App内产生的所有的、满足某个条件的行为，全部上报到后台服务器。例如把一个App中所有的按钮点击都进行上报，然后由产品/运营去后台筛选所需要的行为数据。这种方案的优点非常明显，就是可以不用在新增/修改行为上报条件时，再找开发人员去修改埋点的代码。然而它的缺点也和优点一样明显，那就是上报的数据量比代码埋点大很多，里面可能很多是没有价值的数据。此外，这种方案更倾向于独立去看待用户的行为，而没有关注行为的上下文，给数据分析带来了一些难度。很多公司也提供了这类功能的SDK，通过静态或者动态的方式，“Hook”了原有的App代码，从而实现了行为的监测，在数据上报时通常是采用累积多条再上报的方案来合并请求。
可视化埋点 可视化埋点技术揭秘
▌什么是可视化埋点 **可视化埋点是指通过可视化工具配置采集节点，在App/Web解析配置查找节点，监听节点产生的事件并上报。**例如产品在Web页面/App的界面上进行圈选，配置需要监测界面上哪一个元素，然后保存这个配置，当App启动时会从后台服务器获得产品/运营预先圈选好的配置，然后根据这份配置查找并监测App界面上的元素，当某一个元素满足条件时，就会上报行为数据到后台服务器。有了暴力的全埋点技术方案，很容易联想到按需埋点，可视化埋点就是一种按需配置埋点的方案。现在也有一些公司提供了这类SDK，圈选监测元素时，有的是提供一个Web管理界面，手机在安装并初始化了SDK之后，可以和管理界面了连接，让用户在Web管理界面上配置需要监测的元素，有的是直接让用户在手机上圈选元素进行埋点。
可视化埋点，通常是指用户通过设备连接用户行为分析工具的数据接入管理界面，对可交互且交互后有效果的页面元素（如：图片、按钮、链接等），直接在界面上进行操作实现数据埋点，下发采集代码生效回数的埋点方式。这种方式所见即所得，跳过代码部署、测试验证和发版过程，极大提升生产力。
▌可视化埋点的具体流程 首先手机APP嵌入开启可视化功能的SDK，通过WebSocket的方式和服务器、前端进行相互通信，SDK会定时收到服务器下发的页面请求；然后会上报页面快照和界面因子信息到服务器，服务器收到信息后会根据界面因子信息对页面的每个元素进行分析，根据控件的类型来标记哪些页面元素是可以被埋点的；最后将可埋点信息交给前端渲染，此时，前端Web页面上展示就的就是可以埋点的页面。
埋点人员在渲染出来的前端Web页面上进行框选，标记事件属性等进行埋点。前端Web页面会将对应的埋点信息传递给服务器保存，SDK则会通过策略定时从服务器获取埋点信息。
以上就是整个埋点的大体工作流程，具体包含WebSocket通信过程以及具体的埋点过程。下面就针对这两个过程分别进行细致的介绍。
▌WebSocket通信 由于埋点过程中需要设备APP与前端埋点Web页面进行长时间的连接，并且连接期间双方需要进行互相通信，所以就需要一种高效的支持双向通信的协议来支持这种场景。
WebSocket是用于在Web浏览器和服务器之间进行任意的双向数据传输的一种技术，它基于TCP协议实现，包含初始的握手过程，以及后续的多次数据帧双向传输过程。其目的是在应用和服务器进行频繁双向通信时，可以避免Server端被打开多个HTTP连接进行工作，节约资源、提高了工作效率和资源利用率。WebSocket被广泛用于Web的实时消息通信系统中。它实现了浏览器与服务器全双工通信，将会替代基于HTTP的Ajax长轮询的拉取消息模式。建立了WebSocket连接后，只要客户端和服务器端任意一端不主动断开连接前，通信行为都是在一个持久连接上发起，后续数据与请求都通过帧序列的形式进行传输。
在具体的连接过程中，其实前端Web页面和SDK与服务器的连接都是基于WebSocket的，并且这两个连接最终会建立一个一对一的对应关系。易观在埋点的过程中规定，同一个版本的APP只允许一台设备进行连接埋点。流程如下图：
该图描述的是SDK如何与服务器建立WebSocket连接以及如何与前端Web页面进行关联，具体有以下几个步骤：
1.埋点人员打开埋点Web页面，页面与服务器建立连接。
2.打开手机APP(已经提前集成了易观可视化埋点功能的SDK)，手机摇一摇建立WebSocket连接。
3.服务端通过WebSocket连接请求该手机的设备信息。
4.手机收到服务器的请求后获取对应的设备信息，然后通过WebSocket上报设备信息到服务器。
5.服务器收到设备的信息后发送到步骤一的Web页面进行显示。
6.埋点人员在Web页面选择手机进行关联，同时服务器通过WebSocket发送快照请求到手机。
以上就是具体的设备的连接过程，到此为止，服务器与手机就已经建立了一个可以相互通信的长连接，并且与Web页面进行了关联，如果此时再有同一版本的APP进行连接，页面会提示用户该版本的APP已经进行连接了。
接下来就是埋点过程中，服务器会定时向手机下发请求信息来获取最新的页面信息：
1.服务器定时请求手机的快照信息，手机在收到快照请求后发送快照信息到服务器。
2.WebSocket服务器收到手机的快照信息后，首先把标志置为false，待解析完快照信息后发送至Web界面进行展示。
3.发送成功后把标志置为true,定时服务根据标志来决定是否继续请求快照。
4.心跳包为APP以及WEB端定时发送，来保证WebSocket的长连接畅通。
以上就是埋点过程中，整个WebSocket的工作流程。这里面有几个需要注意的地方：
1.SDK通过WebSocket上报的页面快照信息大小是根据当前页面的复杂度来决定的。如果当前页面包含的元素比较多，那么上传的快照信息就会比较大，这样上传至服务器就会比较慢。在网络不好的情况下出错的概率就比较大。易观在这方面做了一些优化，会对上传的信息进行一些优化和压缩处理，从而尽可能兼顾效率的同时保证上报数据的连续性和完整性。
2.SDK上报快照信息是被动的，是通过服务器来控制的。服务器会定时（比如每隔几秒）请求SDK上报信息。这样就会有一个问题，就是SDK在此期间没有发生页面的切换，页面信息没有变化，这时候收到服务器请求就无需上报快照信息，否则既浪费带宽，体验上也不好。所以易观在这方面也做了优化，服务端和SDK通过某些机制来尽量减少比较大的交互过程，尽量减少不必要的请求。
▌埋点过程 下面介绍一下具体的埋点过程，先看下图：
埋点过程是通过Http协议来实现的。服务器提供相关的埋点查询/新增/修改/删除的接口。埋点人员通过浏览器在具体的埋点Web页面对埋点元素进行框选，继而填写对应的事件名称，然后点击相应的新增/修改/删除按钮即可。
用户编辑的所有的埋点信息最终都会保存到MySQL数据库中。用户最新的快照信息会保存在Redis中一段时间，供用户修改埋点的时候调用。用户编辑完所有的埋点后点击部署按钮，所有的埋点就会实时生效，其他设备上的APP就会获取到部署后的埋点信息。
至此，可视化埋点的流程和技术细节就介绍完了。
参考 强大！asm插桩实现android端无埋点性能监控！
Android埋点技术分析</description>
    </item>
    
    <item>
      <title>基础数据结构</title>
      <link>https://huanle19891345.github.io/en/android/art/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>dex文件里class_def ArtField 一个ArtField对象仅仅是代表一个Java类的成员变量，但它自己并不提供空间来存储这个Java成员变量的内容。Class LinkFields时我们将看到这个Java成员变量所需的存储空间在什么地方
.... private： GcRoot&amp;lt;mirror::Class&amp;gt; declaring_class_; //该成员变量在哪个类中被定义  uint32_t access_flags_; //该成员变量的访问标记  //该成员变量在dex文件中field_ids数组中的索引，注意，它是由图8-7中encoded_field结  //构体中field_idx_diff计算而来  uint32_t field_dex_idx_; //如果ArtField所代表的成员变量是类的静态成员变量，则下面的offset_代表是该变量实际的存储  //空间在图8-13里Class内存布局中的起始位置。如果是非静态成员变量，则offset_指向图8-13中  //Object内存布局里对应的位置。  uint32_t offset_; ArtMethod 7.0
...... protected: //下面这四个成员变量的解释可参考图8-7  GcRoot&amp;lt;mirror::Class&amp;gt; declaring_class_; //本函数在哪个类中声明  uint32_t access_flags_; uint32_t dex_code_item_offset_; //表示某个方法在dex文件method_ids数组中的索引  uint32_t dex_method_index_; //与ArtField的field_index_类似，下面这个成员变量和Class类如何管理它的成员函数有关。  //如果这个ArtMethod对应的是一个static或direct函数，则method_index_是指向定义它的类的methods_中的索引。 //如果这个ArtMethod是virtual函数，则method_index_是指向它的VTable中的索引。注意，可能多个类的VTable都包含该//ArtMethod对象（比如Object的那11个方法），所以要保证这个method_index_在不同VTable中都有相同的值——这也是//LinkMethods中那三个函数比较复杂的原因。  uint16_t method_index_; //热度。函数每被调用一次，该值递增1。一旦超过某个阈值，该函数可能就需要被编译成本地方法以加  //快执行速度了。  uint16_t hotness_count_; struct PACKED(4) PtrSizedFields { //指向declaring_class_-&amp;gt;dex_cache_的resolved_methods_成员，详情需结合下文对Dex-Cache的介绍。  ArtMethod** dex_cache_resolved_methods_; //指针的指针，指向declaring_class_-&amp;gt;dex_cache_的dex_cache_resolved_types_成员，详情需结合下文对DexCache的介绍  GcRoot&amp;lt;mirror::Class&amp;gt;* dex_cache_resolved_types_; //下面两个变量是函数指针，它们是一个ArtMethod对象代表的Java方法的入口函数地址。  //我们后续章节介绍Java代码执行的时候再来讨论它  void* entry_point_from_jni_; // Method dispatch from quick compiled code invokes this pointer which may cause bridging into  // the interpreter.</description>
    </item>
    
    <item>
      <title>布局优化</title>
      <link>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96/</guid>
      <description>布局加载优化 graph LR 正面解决(正面解决)--&amp;gt;去IO,去解析--&amp;gt;|solution|frontSolution(&amp;quot;X2C,Anko,Compose&amp;quot;) 正面解决--&amp;gt;去反射--&amp;gt;|solution|frontSolution 侧面解决--&amp;gt;异步加载--&amp;gt;|solution|AsyncLayoutInflater 我们可以看到，在setContentView中主要有两个耗时操作：
1.解析xml,获取XmlResourceParser,这是IO过程。
2.通过createViewFromTag,创建View对象，用到了反射。
以上两点就是布局加载可能导致卡顿的原因，也是布局的性能瓶颈。
耗时监听 AOP(Aspectj,ASM) @Around(&amp;#34;execution(* android.app.Activity.setContentView(..))&amp;#34;) public void getSetContentViewTime(ProceedingJoinPoint joinPoint) { Signature signature = joinPoint.getSignature(); String name = signature.toShortString(); long time = System.currentTimeMillis(); try { joinPoint.proceed(); } catch (Throwable throwable) { throwable.printStackTrace(); } Log.i(&amp;#34;aop inflate&amp;#34;,name + &amp;#34; cost &amp;#34; + (System.currentTimeMillis() - time)); } 上面用的Aspectj，比较简单，上面的注解的意思是在setContentView方法执行内部去调用我们写好的getSetContentViewTime方法。 这样就可以获取相应的耗时。我们可以看下打印的日志：
I/aop inflate: AppCompatActivity.setContentView(..) cost 69 I/aop inflate: AppCompatActivity.setContentView(..) cost 25 这样就可以实现无侵入的监控每个页面布局加载的耗时。
获取任一控件耗时 有时为了更精确的知道到底是哪个控件加载耗时，比如我们新添加了自定义View,需要监控它的性能。 我们可以利用setFactory2来监听每个控件的加载耗时。首先我们来回顾下setContentView方法：
public final View tryCreateView(@Nullable View parent, @NonNull String name, .</description>
    </item>
    
    <item>
      <title>应用启动</title>
      <link>https://huanle19891345.github.io/en/android/system/%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E9%80%80%E5%87%BA/%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E9%80%80%E5%87%BA/%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8/</guid>
      <description>原理图 上述流程4——5之间还有一个过程，即当ActivityManagerService调用attachApplicationLocked时会跨进程调用thread.bindApplication通知应用进程发消息并调用handleBindApplication，内部会第一次初始化应用进程的mResources和mClassLoader给LoadedApk
Activity.startActivity public void startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { options = transferSpringboardActivityOptions(options); Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); } } Instrumentation.execStartActivity public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { IApplicationThread whoThread = (IApplicationThread) contextThread; int result = ActivityManager.getService() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ?</description>
    </item>
    
    <item>
      <title>应用安全</title>
      <link>https://huanle19891345.github.io/en/android/%E5%AE%89%E5%85%A8/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E5%AE%89%E5%85%A8/%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8/</guid>
      <description>防Hook 第一、Xposed框架将Hook信息存储在字段fieldCache，methodCache，constructorCache 中， 利用java 反射机制获取这些信息，检测Hook信息中是否含有App中敏感的方法，字段，构造方法
第二、检测进程中使用so名中包含关键”hack|inject|hook|call” 的信息，这个主要是防止有的人不用这个Xposed框架，而是直接自己写一个注入功能
第三、root检测原理是：是否含有su程序和ro.secure是否为1
第四、防止被Hook的方式就是可以查看XposedBridge这个类，有一个全局的hook开关，所有有的应用在启动的时候就用反射把这个值设置成true，这样Xposed的hook功能就是失效了
第五、如果应用被Xposed进行hook操作之后，抛出的异常堆栈信息中就会包含Xposed字样，所以可以通过应用自身内部抛出异常来检测是否包含Xposed字段来进行防护
Log 泄露app中的信息
线上仅仅写入文件，不打印log
完整性校验(防篡改)，签名 &amp;lt;应用安全防护和逆向分析&amp;gt;&amp;ndash;第12章
 MANIFEST.MF文件  包含了apk文件中所有文件的数据摘要内容SHA1+Base64,属性名为&amp;quot;SHA1-Digest&amp;quot;(安全散列算法) 另外还有一个&amp;quot;Name&amp;quot;属性，值为该文件在apk包中的路径, 例子:
Manifest-Version: 1.0 Name: AUTHORS SHA1-Digest: tNG7y16mMckMxD5PMWbMbm15YuM= Name: AndroidManifest.xml SHA1-Digest: DpoXWRs62IFQkzew0PZZ1IhBr4E= Name: META-INF/android.arch.lifecycle_livedata.version SHA1-Digest: OxxKFJcpzAROGjnfMbNijNv1+JU=  CERT.SF文件 计算MANIFEST.MF文件整体的SHA1值，再经过BASE64编码后记录在主属性(文件头)上的&amp;quot;SHA1-Digest-Mainifest&amp;quot;属性下 MANIFEST.MF文件的每个条目做一个SHA1+Base64之后记录在同名块中，属性名为&amp;quot;SHA1-Digest&amp;quot;, 例子:  Signature-Version: 1.0 Created-By: 1.0 (Android) SHA1-Digest-Manifest: lCe0n/umuXx2pJRbNdAPxSJQGyU= X-Android-APK-Signed: 2 Name: AUTHORS SHA1-Digest: NJvhMmfYrxh85l+E46t/lOXoRmk= Name: AndroidManifest.xml SHA1-Digest: N/26hYDkRfJLe6NEN7232YcVe1M= Name: META-INF/android.arch.lifecycle_livedata.version SHA1-Digest: MlMwWIwNpuS2rz/AzXm5Hqaliu4=  CERT.RSA文件 对CERT.SF文件用私钥加密出签名，再将签名以及包含公钥信息的数字证书一同写入CERT.RSA  二进制文件，因为RSA文件加密了，所以需要用openssl命令查看内容
openssl pkcs7 -inform DER -in CERT.</description>
    </item>
    
    <item>
      <title>应用安装和卸载过程</title>
      <link>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/apk%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%E8%BF%87%E7%A8%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/apk%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/%E5%BA%94%E7%94%A8%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD%E8%BF%87%E7%A8%8B/</guid>
      <description>安装过程： 1.程序安装的4大步骤
（1） 拷贝apk文件到指定目录 在Android系统中，apk安装文件是会被保存起来的，默认情况下，用户安装的apk首先会被拷贝到 /data/app 目录下。
/data/app目录是用户有权限访问的目录，在安装apk的时候会自动选择该目录存放用户安装的文件，而系统出厂的apk文件则被放到了 /system 分区下,包括 /system/app，/system/vendor/app，以及 /system/priv-app 等等，该分区只有Root权限的用户才能访问，这也就是为什么在没有Root手机之前，我们无法删除系统出厂的app的原因了。
PackageInstaller所在的app进程先将其apk copy到data/user_de/0/com.android.packageinstaller/no_backup/package859349096673958696.apk中
复制APK安装包到data/app目录下，首先copy到data/app/vmdl609226785.tmp/base.apk
（2） 解压apk，拷贝文件，创建应用的数据目录 为了加快app的启动速度，apk在安装的时候，会首先将app的可执行文件（dex）拷贝到 /data/dalvik-cache 目录，缓存起来。
然后，在/data/data/目录下创建应用程序的数据目录（以应用的包名命名），存放应用的相关数据，如数据库、xml文件、cache、二进制的so动态库等等，
（3） 解析apk的AndroidManifinest.xml文件 Android系统中，也有一个类似注册表的东西，用来记录当前所有安装的应用的基本信息，每次系统安装或者卸载了任何apk文件，都会更新这个文件。这个文件位于如下目录：
/data/system/packages.xml
系统在安装apk的过程中，会解析apk的AndroidManifinest.xml文件，提取出这个apk的重要信息写入到packages.xml文件中，这些信息包括：权限、应用包名、APK的安装位置、版本、userID等等。
由此，我们就知道了为啥一些应用市场和软件管理类的app能够很清楚地知道当前手机所安装的所有的app，以及这些app的详细信息了。
另外一件事就是Linux的用户Id和用户组Id，以便他可以获得合适的运行权限。
以上这些都是由PackageManagerService完成的。
（4） 显示快捷方式 这些应用程序只是相当于在PackageManagerService服务注册好了，如果我们想要在Android桌面上看到这些应用程序，还需要有一个Home应用程序，负责从PackageManagerService服务中把这些安装好的应用程序取出来，并以友好的方式在桌面上展现出来，例如以快捷图标的形式。在Android系统中，负责把系统中已经安装的应用程序在桌面中展现出来的Home应用程序就是Launcher了
PackageManagerService的启动过程 Android系统在启动的过程中，会启动一个应用程序管理服务PackageManagerService，这个服务负责扫描系统中特定的目录，找到里面的应用程序文件，即以Apk为后缀的文件，然后对这些文件进解析，得到应用程序的相关信息。应用程序管理服务PackageManagerService安装应用程序的过程，其实就是解析析应用程序配置文件AndroidManifest.xml的过程，并从里面得到得到应用程序的相关信息，例如得到应用程序的组件Activity、Service、Broadcast Receiver和Content Provider等信息，有了这些信息后，通过ActivityManagerService这个服务，我们就可以在系统中正常地使用这些应用程序了。应用程序管理服务PackageManagerService是系统启动的时候由SystemServer组件启动的，启后它就会执行应用程序安装的过程，因此，本文将从SystemServer启动PackageManagerService服务的过程开始分析系统中的应用程序安装的过程。
卸载过程 删除安装过程中在上述三个目录下创建的文件及目录。
参考 Android应用安装过程及原理
Android应用安装流程(基于Android9.0)
Android应用程序安装过程解析(源码角度)</description>
    </item>
    
    <item>
      <title>异常</title>
      <link>https://huanle19891345.github.io/en/android/art/jni/%E5%BC%82%E5%B8%B8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/jni/%E5%BC%82%E5%B8%B8/</guid>
      <description>原理图 graph LR 解释执行--&amp;gt;异常投递--&amp;gt;|case Instruction::THROW|setException(&amp;quot;异常对象赋值给Thread的tlsPtr_exception的成员变量&amp;quot;) 解释执行--&amp;gt;异常处理--&amp;gt;HANDLE_PENDING_EXCEPTION--&amp;gt;|找到能处理该异常的指令码|ArtMethod::FindCatchBlock 机器码执行--&amp;gt;InstructionCodeGeneratorX86::VisitThrow--&amp;gt;artDeliverExceptionFromCode--&amp;gt;setException artDeliverExceptionFromCode--&amp;gt;|找到异常处理处的指令位置|findCatch(&amp;quot;exception_handler.FindCatch(exception);&amp;quot;) 解释执行异常抛出和处理 被抛出的异常对象赋值给Thread tlsPtr_exception的成员变量，异常投递的工作就算完成；
接下来就是异常处理的过程。以switch/case方式来解释执行的代码中，下面这个宏用于判断是否有异常发生并处理它。
Dex_instruction_list.h
#define DEX_INSTRUCTION_LIST(V) \ V(0x27, THROW, &amp;#34;throw&amp;#34;, k11x, false, kIndexNone, kThrow, kVerifyRegA) \ interpreter_switch_impl.cc
ExecuteSwitchImpl template&amp;lt;bool do_access_check, bool transaction_active&amp;gt; JValue ExecuteSwitchImpl(......) { ......　//该函数详情见10.2.3.1节  do { dex_pc = inst-&amp;gt;GetDexPc(insns); ...... inst_data = inst-&amp;gt;Fetch16(0); switch (inst-&amp;gt;Opcode(inst_data)) { //switch/case方式执行不同的dex指令  ...... case Instruction::THROW: { //抛异常  PREAMBLE(); Object* exception = shadow_frame.GetVRegReference( inst-&amp;gt;VRegA_11x(inst_data)); if (UNLIKELY(exception == nullptr)) { //Throw抛出的异常对象为空，则重新抛一个空指针异常  ThrowNullPointerException(&amp;#34;throw with null exception&amp;#34;); } else if (.</description>
    </item>
    
    <item>
      <title>插件化技术选型</title>
      <link>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E6%8F%92%E4%BB%B6%E5%8C%96/%E6%8F%92%E4%BB%B6%E5%8C%96%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</guid>
      <description>Shadow(腾讯) Qigsaw(爱奇艺) https://developer.android.google.cn/guide/app-bundle
 VirtualAPK(滴滴) https://github.com/didi/VirtualAPK
https://blog.csdn.net/u012124438/article/details/74118905
我们可以先启动一个已经在AndroidManifest.xml里面声明过的替身Activity，让这个Activity进入AMS进程接受检验；最后在换成我们真正需要启动的Activity；这样就成功欺骗了AMS进程
Atlas(阿里) https://blog.csdn.net/M075097/article/details/79225030
;//-----2.3.3替换系统原生ClassLoader为DelegateClassLoad AndroidHack.injectClassLoader(packageName, newClassLoaderer) //-----2.3.4 替换系统的Instrumentation为InstrumentationHook，该类是一个系统与用户之间交互的介质层，大部分调用的功能操作都会流过此类之后再进一步调  AndroidHack.injectInstrumentationHook(new InstrumentationHook(AndroidHack.getInstrumentation(), application.getBaseContext() ActivityManagerDelegate activityManagerProxy = new ActivityManagerDelegate(); Object gDefault = null; if(Build.VERSION.SDK_INT&amp;gt;25 || (Build.VERSION.SDK_INT==25&amp;amp;&amp;amp;Build.VERSION.PREVIEW_SDK_INT&amp;gt;0)){ gDefault=AtlasHacks.ActivityManager_IActivityManagerSingleton.get(AtlasHacks.ActivityManager.getmClass()); }else{ gDefault=AtlasHacks.ActivityManagerNative_gDefault.get(AtlasHacks.ActivityManagerNative.getmClass()); } AtlasHacks.Singleton_mInstance.hijack(gDefault, activityManagerProxy); RePlugin(360) Replugin与DroidPlugin框架比较
虽然唯一Hook点为宿主Application#LoadedApk中的classLoader对象，但源码中依然存在着众多的invoke反射，和google禁止使用非公开api的策略相违背
Neptune(爱奇艺)  插件的安装与加载  https://github.com/iqiyi/Neptune/blob/master/docs/SDK%E5%8E%9F%E7%90%86/%E6%8F%92%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E5%8A%A0%E8%BD%BD.md
 Neptune/docs/SDK原理/插件的代理实现机制.md  https://github.com/iqiyi/Neptune/blob/master/docs/SDK%E5%8E%9F%E7%90%86/%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E6%9C%BA%E5%88%B6.md
Hydra(美团-未开源) </description>
    </item>
    
    <item>
      <title>易观方舟</title>
      <link>https://huanle19891345.github.io/en/android/%E5%9F%8B%E7%82%B9/%E6%98%93%E8%A7%82%E6%96%B9%E8%88%9F/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E5%9F%8B%E7%82%B9/%E6%98%93%E8%A7%82%E6%96%B9%E8%88%9F/</guid>
      <description>模块设计 graph TB 采集策略--&amp;gt;|控制触发|采集 采集--&amp;gt;自动采集--&amp;gt;全埋点监听touch--&amp;gt;|onGlobalLayout|hookDecorViewClick--&amp;gt;|mOnTouchListener|HookTouchListener--&amp;gt;trackEvent 采集--&amp;gt;手动采集--&amp;gt;trackEvent 上报策略--&amp;gt;|控制触发|上报 /** com/analysys/process/HeatMap.java * 反射给View注册监听 */ private void hookViewClick(View view) throws Exception {  ans-sdk/analysys_core/src/main/java/com/analysys/AutomaticAcquisition.java
AutomaticAcquisition onActivityCreated @Override public void onActivityCreated(final Activity activity, Bundle savedInstanceState) { AnalysysConfig config = AgentProcess.getInstance().getConfig(); if (config.isAutoTrackClick()) { AnalysysUtil.onActivityCreated(activity); } if (config.isAutoHeatMap()) { initHeatMap(new WeakReference&amp;lt;&amp;gt;(activity)); } } initHeatMap private void initHeatMap(final WeakReference&amp;lt;Activity&amp;gt; wa) { layoutListener = new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { if (wa == null) { return; } final Activity activity = wa.</description>
    </item>
    
    <item>
      <title>架构思考和实现</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83%E5%92%8C%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83%E5%92%8C%E5%AE%9E%E7%8E%B0/</guid>
      <description>架构设计过程 架构思考 graph LR subgraph 抽象客观事物 页面开发任务--&amp;gt;|抽象出模型|数据处理并展示 end subgraph 发现客观问题 数据处理并展示--&amp;gt;|发现问题|splitArch(需要分离界面和数据,分层架构) 数据处理并展示--&amp;gt;|发现问题|数据处理需要考虑界面生命周期 数据处理并展示--&amp;gt;|发现问题|ViewController需要声明式更新 数据处理并展示--&amp;gt;|发现问题|数据需要保留 数据处理并展示--&amp;gt;|发现问题|需要处理异步任务(&amp;quot;需要处理异步任务,结构化并发&amp;quot;) 数据处理并展示--&amp;gt;|发现问题|需要数据源emit多数据项 数据处理并展示--&amp;gt;|发现问题|需要抽象数据策略 数据处理并展示--&amp;gt;|发现问题|callback影响可读性 数据处理并展示--&amp;gt;|发现问题|层间依赖内部引用不灵活 数据处理并展示--&amp;gt;|发现问题|IOC时模板代码且无scope end subgraph 解决问题 splitArch--&amp;gt;|解决方案|MVC,MVP,MVVM(&amp;quot;MVC,MVP,MVVM(数据驱动)&amp;quot;) 数据处理需要考虑界面生命周期--&amp;gt;|解决方案|LifecycleAware组件 ViewController需要声明式更新--&amp;gt;|解决方案|DataBinding 数据需要保留--&amp;gt;|解决方案|ViewModel等三段式保留方案 需要处理异步任务--&amp;gt;|解决方案|Coroutine1(Coroutine) 需要数据源emit多数据项--&amp;gt;|解决方案|Flow 需要抽象数据策略--&amp;gt;|解决方案|NetworkBoundResource类族 callback影响可读性--&amp;gt;|解决方案|Coroutine2(Coroutine,Flow) 层间依赖内部引用不灵活--&amp;gt;|解决方案|IOC传入依赖 IOC时模板代码且无scope--&amp;gt;|解决方案|DI框架,如Hilt end 架构设计 Jetpack架构组件的通用落地设计如下
各层内设计 View Layer 类设计 Activity和Fragment是同样的继承结构设计，以Activity为例:
classDiagram class CommonActivity { +inflateContent(savedInstanceState: Bundle?)* +init(savedInstanceState: Bundle?)* } class CommonInflateActivity { +inflateContent(savedInstanceState: Bundle?) +getLayoutId()*Int } class DataBindingActivity~VDB : ViewDataBinding~{ +inflateContent(savedInstanceState: Bundle?) +init(savedInstanceState: Bundle?) -bindVariable(activityDataBinding: VDB) +getLayoutId()* Int +getVariableMap()* Map } class ViewModelCommonActivity~VM : BaseViewModel~ { ~VM viewModel } class ViewModelBindingActivity~VDB : ViewDataBinding, VM : BaseViewModel~ { ~VM viewModel +getVariableMap()Map +getViewModelVariableId()*Int } BaseActivity&amp;lt;|--CommonActivity CommonActivity&amp;lt;|--CommonInflateActivity CommonActivity&amp;lt;|--DataBindingActivity CommonInflateActivity&amp;lt;|--ViewModelCommonActivity DataBindingActivity&amp;lt;|--ViewModelBindingActivity Hilt构造并注入viewmodel DataBinding场景细分 ViewModel Layer Hilt注入需要的Domain层Repository Data load type Trigger by lifecycle event automatic val userNameLiveData = liveData { emit(userRepository.</description>
    </item>
    
    <item>
      <title>架构思考和实现Inner</title>
      <link>https://huanle19891345.github.io/en/android/jetpack/arch/%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83%E5%92%8C%E5%AE%9E%E7%8E%B0inner/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/jetpack/arch/%E6%9E%B6%E6%9E%84%E5%AE%9E%E7%8E%B0/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83%E5%92%8C%E5%AE%9E%E7%8E%B0inner/</guid>
      <description>分层架构 https://developer.android.com/jetpack/guide#overview
NetworkBoundResource数据策略 https://developer.android.com/jetpack/guide#addendum
 ResueViewmodels Should I reuse view models in different views?
I noticed that I have views that need the same information like others. But sometimes you need 5 properties of the view model and sometimes only 2.
Do you share such view model over many views or do you create a separate view model for each view or maybe do you prefere an inheritance or composition strategy?</description>
    </item>
    
    <item>
      <title>混合开发</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/</guid>
      <description>Flutter和native混合开发 Binding to native C/C++ code using dart:ffi
Writing custom platform-specific code Writing custom platform-specific code
Flutter’s platform-specific API support does not rely on code generation, but rather on a flexible message passing style:
 The Flutter portion of the app sends messages to its host, the iOS or Android portion of the app, over a platform channel.  static const platform = const MethodChannel(&amp;#39;samples.flutter.dev/battery&amp;#39;); try { final int result = await platform.</description>
    </item>
    
    <item>
      <title>混合编译_运行</title>
      <link>https://huanle19891345.github.io/en/android/art/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91_%E8%BF%90%E8%A1%8C/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91_%E8%BF%90%E8%A1%8C/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91_%E8%BF%90%E8%A1%8C/%E6%B7%B7%E5%90%88%E7%BC%96%E8%AF%91_%E8%BF%90%E8%A1%8C/</guid>
      <description>How ART works ART uses ahead-of-time (AOT) compilation, and starting in Android 7.0 (Nougat or N), it uses a hybrid ==combination of AOT, just-in-time (JIT) compilation, and profile-guided compilation==. The combination of all these compilation modes is ==configurable== and will be discussed in this section. As an example, Pixel devices are configured with the following compilation flow:
 An application is initially installed without any AOT compilation. The first few times the application runs, it will be ==interpreted, and methods frequently executed will be JIT compiled==.</description>
    </item>
    
    <item>
      <title>渲染</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E6%B8%B2%E6%9F%93/%E6%B8%B2%E6%9F%93/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E6%B8%B2%E6%9F%93/%E6%B8%B2%E6%9F%93/</guid>
      <description>绘制渲染 三棵树 https://flutter.dev/docs/resources/architectural-overview#layout-and-rendering
Widget Tree，Element Tree 以及 RenderObject Tree 。根据它们的功能我将它翻译成模型树，状态树和渲染树，也正是通过这三棵树维护起了整个应用的视图数据。
开发者通过Widget配置，Framework通过比对Widget配置来更新Element，最后调度RenderObject Tree完成布局排列和绘制。
 Widget Tree  存放属性的描述信息，更像是一个Model。同一个Widget可以同时描述多个渲染树中的节点，但是它是不可修改的，因此它只会被创建或销毁。
Widget是为Element描述需要的配置， 负责创建Element，决定Element是否需要更新。Flutter Framework通过差分算法比对Widget树前后的变化，决定Element的State是否改变。当重建Widget树后并未发生改变， 则Element不会触发重绘，则就是Widget树的重建并不一定会触发Element树的重建。
 Element Tree  存放上下文状态信息，同时持有 Widget和RenderObject的引用。像是一个Controller控制着状态的更新(initial, mount,amount,activate,deactivate,update)。
Element表示Widget配置树的特定位置的一个实例，同时持有Widget和RenderObject，负责管理Widget配置和RenderObject渲染。Element状态由Flutter Framework管理， 开发人员只需更改Widget即可。
 RenderObject Tree  实现了layout和paint事件，是最终渲染的View视图。
RenderObject表示渲染树的一个对象，负责真正的渲染工作，比如测量大小、位置、绘制等都由RenderObject完成。
渲染库（Rendering） Flutter的控件树在实际显示时会转换成对应的渲染对象（RenderObject）树来实现布局和绘制操作。渲染库主要提供的功能类有：
abstract class RendererBinding extends BindingBase with ServicesBinding, SchedulerBinding, HitTestable { ... } abstract class RenderObject extends AbstractNode with DiagnosticableTreeMixin implements HitTestTarget { abstract class RenderBox extends RenderObject { ... } class RenderParagraph extends RenderBox { .</description>
    </item>
    
    <item>
      <title>硬件加速绘制</title>
      <link>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E7%BB%98%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E7%BB%98%E5%88%B6/</guid>
      <description>硬件加速绘制 Android硬件加速过程分析
理解Android硬件加速原理的小白文
Android硬件加速原理与实现
总结：
 CPU更擅长复杂逻辑控制，而GPU得益于大量ALU和并行结构设计，更擅长数学运算。 页面由各种基础元素（DisplayList）构成，渲染时需要进行大量浮点运算。 硬件加速条件下，CPU用于控制复杂绘制逻辑，构建或更新DisplayList；GPU用于完成图形计算，渲染DisplayList。 硬件加速条件下，刷新界面尤其是播放动画时，CPU只重建或更新必要的DisplayList，进一步提高渲染效率。   软硬件加速的区别 软硬件加速的区别主要是==图形的绘制究竟是GPU来处理还是CPU，如果是GPU==，就认为是硬件加速绘制，反之，软件绘制。
不仅仅限定在绘制方面，绘制之前，在如何构建绘制区域上，硬件加速也做出了很大优化，因此硬件加速特性可以从下面两部分来分析：
 ==前期策略：如何构建需要绘制的区域== ==后期绘制：单独渲染线程，依赖GPU进行绘制==  无论是软件绘制还是硬件加速，==绘制内存的分配都是类似的，都是需要请求SurfaceFlinger服务分配一块内存==，只不过硬件加速有可能从FrameBuffer硬件缓冲区直接分配内存（SurfaceFlinger一直这么干的），==两者的绘制都是在APP端，绘制完成之后同样需要通知SurfaceFlinger进行合成，在这个流程上没有任何区别==，真正的区别在于在APP端如何完成UI数据绘制
软件绘制同硬件加速的区别主要是在绘制上，内存分配、图层合成等整体流程是一样的，只不过硬件加速相比软件绘制算法更加合理，同时采用单独的渲染线程，减轻了主线程的负担。
软件绘制跟硬件加速的分歧点 ViewRootImpl.java
private void draw(boolean fullRedrawNeeded) { ... if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) { //关键点1 是否开启硬件加速  if (mAttachInfo.mHardwareRenderer != null &amp;amp;&amp;amp; mAttachInfo.mHardwareRenderer.isEnabled()) { ... dirty.setEmpty(); mBlockResizeBuffer = false; //关键点2 硬件加速绘制  mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this); } else { ... //关键点3 软件绘制  if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) { return; } .</description>
    </item>
    
    <item>
      <title>程序设计规范</title>
      <link>https://huanle19891345.github.io/en/%E6%80%9D%E6%83%B3/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E6%80%9D%E6%83%B3/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%A7%84%E8%8C%83/</guid>
      <description>单一职责原则 Single Responsibility Principle
  依赖倒置原则 Dependence Inversion Principle
  接口隔离原则 Interface Segregation Principle
  迪米特法则(最小知道原则)
  合成复用原则
  开闭原则
  里氏替换原则 Liskov Substitution Principle
  对于工程最佳实践的形而上的思考过程，就是：
把工程实践中遇到的问题，从问题类型和解法类型，两个角度去归类，总结出一些有限适用的原则，就从点到了面。把诸多总结出的原则，组合应用到自己的项目代码中，就是把多个面结合起来构建了一套立体的最佳实践的方案。
组合原则: 设计时考虑拼接组合
吝啬原则: 除非确无它法避免, 不要编写庞大的程序
透明性原则: 设计要可见，以便审查和调试
通俗原则: 接口设计避免标新立异
缄默原则: 如果一个程序没什么好说的，就沉默
补救原则: 出现异常时，马上退出并给出足够错误信息
 对于代码格式规范，100%严格执行，严重容不得一点沙。 文件绝不能超过 800 行，超过，一定要思考怎么拆文件。工程思维，就在于拆文件的时候积累。 函数对决不能超过 80 行，超过，一定要思考怎么拆函数，思考函数分组，层次。工程思维，就在于拆文件的时候积累。 代码嵌套层次不能超过 4 层，超过了就得改。多想想能不能 early return。工程思维，就在于拆文件的时候积累。  参考 腾讯万字Code Review规范出炉！别再乱写代码了</description>
    </item>
    
    <item>
      <title>类加载</title>
      <link>https://huanle19891345.github.io/en/android/art/2%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E7%B1%BB%E5%8A%A0%E8%BD%BD/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/2%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E7%B1%BB%E5%8A%A0%E8%BD%BD/</guid>
      <description>动态加载dex和so https://alibaba.github.io/atlas/update/principle.html
PathClassLoader自身负责主Apk的类和c库的查找路口；其parent BootClassloader负责framework sdk的内容的查找。
PathClassLoader本身也是一个class，继承了BaseDexClassLoader（同DexClassLoader），里面查找过程在DexPathList里面实现（如下图） &amp;gt;
DexPathList最终通过DexFile去loadClass，DexPathList可以理解为持有者DexFile以及nativeLibrary目录，再查找的时候遍历这些对象，直到找到需要的类或者c库，那么动态部署的方式就是把新修改的内容添加到这些对象的最前面，从而使得查找的过程中新修改的内容能够提前找到从而替换原有的（如下图）
BaseDexClassLoader构造方法 private final DexPathList pathList; /** \* Constructs an instance. \* Note that all the *.jar and *.apk files from {@code dexPath} might be \* first extracted in-memory before the code is loaded. This can be avoided \* by passing raw dex files (*.dex) in the {@code dexPath}. * \* @param dexPath the list of jar/apk files containing classes and \* resources, delimited by {@code File.</description>
    </item>
    
    <item>
      <title>类加载虚拟机层</title>
      <link>https://huanle19891345.github.io/en/android/art/2%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B1%82/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/2%E7%B1%BB%E5%8A%A0%E8%BD%BD/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%B1%82/</guid>
      <description>Flow load class trigger flow graph TB EnsureInitialized--&amp;gt;InitializeClass InitializeClass--&amp;gt;MethodVerifier::VerifyClass MethodVerifier::VerifyClass--&amp;gt;MethodVerifier::VerifyMethods MethodVerifier::VerifyMethods--&amp;gt;MethodVerifier::VerifyMethod MethodVerifier::VerifyMethod--&amp;gt;MethodVerifier::CodeFlowVerifyInstruction MethodVerifier::CodeFlowVerifyInstruction--&amp;gt;ResolveType MethodVerifier::VerifyMethod--&amp;gt;ResolveType ResolveType--&amp;gt;FindClass FindClass--&amp;gt;DefineClass ClassLinkerSummary ClassLinker中其他一些常见函数。包括：
·Resolve相关函数。虽然名称叫Resolve，但在ART代码里，它并非是图8-5类加载、链接和初始化阶段中提到的Resolve。相反，它甚至可能触发一个类的加载和链接流程。
·FindClass：根据类的字符串名称搜索一个类。如果没有的话，则可能触发类的加载和链接流程。
graph LR ResolveMethod--&amp;gt;ResolveType ResolveField--&amp;gt;ResolveType ResolveType--&amp;gt;FindClass FindClass--&amp;gt;FindClassInBaseDexClassLoader--&amp;gt;FindClassInBaseDexClassLoaderClassPath--&amp;gt;DefineClass ResolveMethod template &amp;lt;ClassLinker::ResolveMode kResolveMode&amp;gt; ArtMethod* ClassLinker::ResolveMethod(const DexFile&amp;amp; dex_file, uint32_t method_idx, Handle&amp;lt;mirror::DexCache&amp;gt; dex_cache, Handle&amp;lt;mirror::ClassLoader&amp;gt; class_loader, ArtMethod* referrer, InvokeType type) { //和ResolveType类似，首先判断dex_cache中是否已经解析过这个方法了。  ArtMethod* resolved = dex_cache-&amp;gt;GetResolvedMethod(method_idx, image_pointer_size_); if (resolved != nullptr &amp;amp;&amp;amp; !resolved-&amp;gt;IsRuntimeMethod()) { if (kResolveMode == ClassLinker::kForceICCECheck) { //Java有诸如1.5、1.6这样的版本，在早期Java版本里，有些信息和现在的版本有差异，  //此处将检查是否有信息不兼容的地方（即check incompatible class change），  //如果检查失败，则会设置一个IncompatibleClassChangeError异常，笔者此处不拟讨论。  if (resolved-&amp;gt;CheckIncompatibleClassChange(type)) { .</description>
    </item>
    
    <item>
      <title>绘制原理</title>
      <link>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/%E7%BB%98%E5%88%B6%E5%8E%9F%E7%90%86/</guid>
      <description>流程原理 ViewRootImpl.setView /** * We have one child */ public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { // If the application owns the surface, don&amp;#39;t enable hardware acceleration  if (mSurfaceHolder == null) { // While this is supposed to enable only, it can effectively disable  // the acceleration too.  enableHardwareAcceleration(attrs); } // Schedule the first layout -before- adding to the window  // manager, to make sure we do the relayout before receiving  // any other events from the system.</description>
    </item>
    
    <item>
      <title>继承和组合</title>
      <link>https://huanle19891345.github.io/en/%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E6%80%9D%E6%83%B3/%E7%BB%A7%E6%89%BF%E5%92%8C%E7%BB%84%E5%90%88/</guid>
      <description>组织结构形态 继承和组合对应着客观事物的组织结构形态，具体的说：
 继承: 子类是父类，是有相同行为(方法)签名但实现不同的父类能力延伸和拓展，拥有父类的public访问和protect override能力 组合: 包裹类组合多个被包裹类，拥有多个被包裹类的public访问能力  访问权限可以由不同语言的访问限定符进行不同粒度的控制，而继承和组合最大的区别在于继承体系中子类对父类protect 方法的override能力(在子类实现中可能会调用super的相同方法)
一般优化方式 继承 对于继承和组合对代码结构的优化，首先开始的是由客观事物形态决定的继承关系，在子类继承父类的同时，自身有很多功能的定制
组合 将子类对每个功能的定义进行依赖关系梳理，每个功能以高内聚低耦合的组合方式在子类中使用，可以考虑使用android lifecycle这种观察者模式将每个功能类的对关键事件(生命周期)的监听进行分发，降低其在子类中的耦合，一行代码完成一个功能
这种优化方式已经可以使得项目代码逻辑清晰，对于需要某个高内聚功能时，可以选择直接继承(有合适的父类时)或者组合各个功能类进行实现，从而解决无法多继承但同时需要两个不同的父类功能时的问题
函数式优化，组合代替继承 很多设计模式和设计思想都是为了组合代替继承，又如语言层面对委托的支持(kotlin delegate, dart mixin)。通过上面对组织结构形态的分析，继承和组合最大的区别在于继承体系中子类对父类protect 方法的override能力，因此函数式编程思想(kotlin, dart中的函数变量传递，java中则对应着lambda表达式或者单方法interface)解决这个问题，在flutter中更是推荐组合代理继承，所有widget只要继承StatefulWidget或者StatelessWidget并进行功能组合即可
graph LR subgraph 被别人组合获取能力: 要求两者对外具有相同的接口能力抽象,通过代理转发 MyViewWantsToBeCenter--&amp;gt;|继承|View MyViewWantsToBeCenter--&amp;gt;|组合|Center(&amp;quot;wrap it in a Center widget&amp;quot;) end subgraph 组合别人获取能力 子类--&amp;gt;|继承|父类 包裹者--&amp;gt;|包裹|被包裹者 end 具体做法 通过传递方法fun实现给被包裹类，在被包裹类中进行fun的调用，达到类似子类override父类的能力。如果要实现类似子类调用super同签名方法实现的功能，
方法1(较难理解，要修改方法签名，不推荐) 从被包裹类到包裹类层层包裹方法实现:
可以将被包裹类中的同签名fun作为额外的(原方法签名参数列表后新增一个)参数，让外部传递新的参数列表给被包裹类，被包裹类通过调用fun1时传递自身实现让包裹类拥有类似子类调用super同签名方法实现的能力，如果包裹类没有传递fun1，可以直接调用fun
class BeWrapperedA(Fun1 funA) otherFun() { funA(param1, param2, fun) } fun(param1, param2) { } Fun1(param1 a, param2 b, fun(param1, param2) c) ------------------------------------------------ class BeWrapperedB(Fun1 funB) BeWrapperedA((a, b, c) -&amp;gt; {funB(a, b, (a, b) -&amp;gt; (Fun1(a, b, c))))}) Fun1(param1 a, param2 b, fun(param1, param2) c) { c(a , b) //相当于调用super(a, b)  a + b;//自定义逻辑 } 方法2，便于理解，不用修改方法签名 正向思维，从包裹类到被包裹类，按需调用方法，类似代理等设计思想，都实现接口，按需调用，类似flutter的StatefulWidget的一级子类，通过build方法约定从包裹类最外层开始向内调用被包裹类的方法实现</description>
    </item>
    
    <item>
      <title>编解码知识</title>
      <link>https://huanle19891345.github.io/en/%E6%96%B9%E5%90%91%E5%92%8C%E8%B6%8B%E5%8A%BF/%E9%9F%B3%E8%A7%86%E9%A2%91/%E7%BC%96%E8%A7%A3%E7%A0%81/%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9F%A5%E8%AF%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E6%96%B9%E5%90%91%E5%92%8C%E8%B6%8B%E5%8A%BF/%E9%9F%B3%E8%A7%86%E9%A2%91/%E7%BC%96%E8%A7%A3%E7%A0%81/%E7%BC%96%E8%A7%A3%E7%A0%81%E7%9F%A5%E8%AF%86/</guid>
      <description>视频编码器 第一步:帧类型分析(分组)&amp;ndash;确定I、P、B帧 经过压缩后的帧分为：I帧，P帧和B帧:
　I帧：关键帧，采用帧内压缩技术。 P帧：向前参考帧，在压缩时，只参考前面已经处理的帧。采用帧音压缩技术。 B帧：双向参考帧，在压缩时，它即参考前而的帧，又参考它后面的帧。采用帧间压缩技术。
理想情况下，一个视频流，从一个I帧开始后面轻微运动都是 P/B，直到遇到场景切换就再插一个I，如此往复。一般来说，P/B 参考范围不会越过I帧。
我们可以强行指定 P/B 参考不允许越过 I 帧，这样的I帧我们叫它 IDR 帧，每个 IDR 帧（Instantaneous Decoding Refresh）的间隔我们称作一个 GOP（Group of Pictures）。
上图中的箭头表示信息提供方向，二分方式确定Coding Order
第二步:帧内/帧间预测 　帧内预测压缩，解决的是空域数据冗余问题。 帧间预测压缩（运动估计与补偿），解决的是时域数据冗徐问题。
帧内 大量统计表明，源 YUV 中两个相邻像素值相等、相似或者缓变概率极大，发生突变的几率是极小。（简单解释下，缓变图像：细量化，粗采样；突变图像：粗量化，细采样，处理细节丰富的图像）
通常，编码器会通过算法将图像划分为一块一块的，然后逐块进行后续的压缩处理。
假设当前的块不在图像边缘，我们可以用上方相邻块边界邻近值作为基础值，也就是上面一行中的每一个值，都垂直向下做拷贝，构建出和源 YUV 块一样大小的预测块，这种构建预测块的方式，我们叫做垂直预测模式，属于帧内预测模式的一种。与它相似的，还有水平预测模式、均值预测模式（也就是4x4的均值填充整个 4x4）等。
紧接着，用源YUV的数据和预测YUV的数据做差值，得到残差块，这样我们在码流中，就直接传输残差的数据和当前4x4块的预测模式的标志位就行，这极大地节省了码流。
举例：计算源块与预测块的残差
帧间 如果是帧间预测的话，编码器会以当前块空域相邻的位置，在时域参考帧上的同为块，作为起始点进行规则搜索，直到搜索完找到能够节省码流最大的块作为帧间预测块，当前块到预测块的位移称为运动矢量，这样我们在码流中传输运动矢量、帧间预测模式标志位、残差就可以。
H.264 中我们把 16x16 大小的块称作宏块，宏块也是 H.264 中最大的块，做帧内/帧间预测的时候可以分成8x8、4*4 这样的子块，都是要把它们最能节省码流的预测模式都算出来，然后比较出最优秀的划分模式进行传输。
第三步:变换+量化 　整数离散余弦变换（DCT），将空间上的相关性变为频域上无关的数据然后进行量化。
大量统计表明，把经过预测后得到的残差经过DCT空频变换，直流和低频（相对平坦，图像或块中大部分占比）能量集中在左上，高频（细节，图像或块中少部分占比）能量集中在右下，DCT本身虽然没有压缩作用，却为以后压缩时的取舍，奠定了必不可少的基础。
变换后直流分量DC都集中在左上角，是整块像素的求和的均值。由于人眼对高频信号不敏感，我们可以定义这样一个变量QP=5，将变换块中所有的值都除以QP，这样做进一步节省传输码流位宽，同时主要去掉了高频分量的值，在解码端只需要将变换块中所有的值在乘QP就可以基本还原低频分量。
我们将QP运算的过程称为量化，可见量化值越大，丢掉的高频信息就越多，再加上编码器中都是用整形变量代表像素值，所以量化值最大还原的低频信息也会越不准确，即造成的失真就越大，块效应也会越大，视频编码的质量损失主要来源于此。
块效应
第四步:滤波 我们可以把滤波理解为一个在量化值波动特别大的时候的一个提升主观质量的操作。如果量化值波动特别大，有可能造成本不应该是真实边界的区域内有很明显的块效应。我们暂称为块效应边界。
真实边缘就比如说我们人脸和身后的背景，中间的这一条线。那假边界就是图中人脸区域的一个一个小块当中的这样的一个线。
为了优化这种情况我们需要对块效应边界两边的值进行补偿操作，让块效应边界两边的值差异不要过大，从而降低块效应，提升质量。
具体的操作，我们分三步。我会细致给大家梳理下。这部分很重要，有需要或者感兴趣的同学可以参考：
1、初步估算块效应边界强度。
2、区分真假边界。
3、计算差值。
第五步:熵编码 我们在真实网络传输的过程中肯定都是二进制码，所以我们需要将当前的像素值进一步压缩成二进制流
总结一下 到这里，走完一整个编码流程，生成的数据就是压缩后的结果，我们也可将它送到适应我们的网络中去。
先是我们计算过没有经过编码压缩的视频需要极大的带宽，所以我们必须进行编码。后来又说道编码的各个过程，输入的原始YUV进来，采用帧类型分析得到IDR、I、P、B类型，然后采用帧内/帧间预测+块划分得到残差，再采用变换+量化进行进一步压缩，接着采用滤波去除方块效应，然后采用熵编码将像素值转换为二进制流进一步压缩，输出压缩后可传输的码流。</description>
    </item>
    
    <item>
      <title>编译插桩和动态代理</title>
      <link>https://huanle19891345.github.io/en/android/aop/%E7%BC%96%E8%AF%91%E6%8F%92%E6%A1%A9%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/aop/%E7%BC%96%E8%AF%91%E6%8F%92%E6%A1%A9%E5%92%8C%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</guid>
      <description>编译插桩技术 Kotlin Symbol Processing (KSP) Alpha 版现已发布
ByteX https://github.com/bytedance/ByteX
ASM https://asm.ow2.io/
【Android】函数插桩（Gradle + ASM）
 ASM代码生成 在Android Studio中安装ASM Bytecode Viewer插件； 2、安装后，在编译器中，点击右键，选择Show Bytecode Viewer；  查看java字节码:
jclasslib插件，View-&amp;gt;Show ByteCode with jclasslib
极客时间&amp;ndash;android开发高手课07-sample项目
compile group: &amp;#39;org.ow2.asm&amp;#39;, name: &amp;#39;asm&amp;#39;, version: &amp;#39;5.1&amp;#39; compile group: &amp;#39;org.ow2.asm&amp;#39;, name: &amp;#39;asm-commons&amp;#39;, version: &amp;#39;5.1&amp;#39; 通过反射注入transform
project.getGradle().getTaskGraph().addTaskExecutionGraphListener(new TaskExecutionGraphListener() { @Override public void graphPopulated(TaskExecutionGraph taskGraph) { for (Task task : taskGraph.getAllTasks()) { if ((task.name.equalsIgnoreCase(hackTransformTaskName) || task.name.equalsIgnoreCase(hackTransformTaskNameForWrapper)) &amp;amp;&amp;amp; !(((TransformTask) task).getTransform() instanceof SystemTraceTransform)) { project.</description>
    </item>
    
    <item>
      <title>网络请求安全</title>
      <link>https://huanle19891345.github.io/en/android/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%AE%89%E5%85%A8/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%AE%89%E5%85%A8/</guid>
      <description>https://httpcanary.com/zh-hans/install.html
安装根证书（必须） 安装证书要求设备必须设置锁屏密码或者图案，请按照系统提示进行设置（此乃系统限制与HttpCanary无关）
HttpCanary使用Man-in-the-Middle(MITM)技术抓取和解析TLS/SSL协议数据包，比如常见的HTTPS、WSS等加密请求，所以使用之前必须先安装HttpCanary根证书。安装时，默认点击确定即可，请勿修改配置。
SSL/TLS安全之——中间人攻击（MITM）浅析
httpcanary是通过VPN抓取数据包，因此通过禁用代理无法关闭抓包
手机上的httpcanary或PC上的ss打开都会导致正常通过代理进行抓包抓不到
https加密时，通过代理进行charles抓包时看到的数据时密文，但httpcanary看到的是明文，因为httpcanary是在应用层看到的未加密的数据和已解密的数据，加密解密发生在应用层和传输层之间。因此只能在业务上对网络参数进行加解密
Android Okhttp/Retrofit网络请求加解密实现方案
Android平台HTTPS抓包解决方案及问题分析 Android平台HTTPS抓包解决方案及问题分析
1. 抓包原理 几乎所有网络数据的抓包都是采用中间人的方式（MITM），包括大家常用的Fiddler、Charles等知名抓包工具，HttpCanary同样是使用中间人的方式进行抓包。
从上面这个原理图，可以看出抓包的核心问题主要是两个：
 MITM Server如何伪装成真正的Server； MITM Client如何伪装成真正的Client。  第一个问题，MITM Server要成为真正的Server，必须能够给指定域名签发公钥证书，且公钥证书能够通过系统的安全校验。比如Client发送了一条https://www.baidu.com/的网络请求，MITM Server要伪装成百度的Server，必须持有www.baidu.com域名的公钥证书并发给Client，同时还要有与公钥相匹配的私钥。
MITM Server的处理方式是从第一个SSL/TLS握手包Client Hello中提取出域名www.baidu.com，利用应用内置的CA证书创建www.baidu.com域名的公钥证书和私钥。创建的公钥证书在SSL/TLS握手的过程中发给Client，Client收到公钥证书后会由系统会对此证书进行校验，判断是否是百度公司持有的证书，但很明显这个证书是抓包工具伪造的。为了能够让系统校验公钥证书时认为证书是真实有效的，我们需要将抓包应用内置的CA证书手动安装到系统中，作为真正的证书发行商（CA），即洗白。这就是为什么，HTTPS抓包一定要先安装CA证书。
第二个问题，MITM Client伪装成Client。由于服务器并不会校验Client（绝大部分情况），所以这个问题一般不会存在。比如Server一般不会关心Client到底是Chrome浏览器还是IE浏览器，是Android App还是iOS App。当然，Server也是可以校验Client的，这个后面分析。
2. 安装CA证书 抓包应用内置的CA证书要洗白，必须安装到系统中。而Android系统将CA证书又分为两种：用户CA证书和系统CA证书。顾明思议，用户CA证书是由用户自行安装的，系统CA证书是由系统内置的，很明显后者更加真实有效。
系统CA证书存放在/etc/security/cacerts/目录下，名称是CA证书subjectDN的Md5值前四位移位取或，后缀名是.0，比如00673b5b.0。考虑到安全原因，系统CA证书需要有Root权限才能进行添加和删除。
对于非Root的Android设备，用户只能安装用户CA证书。
无论是系统CA证书还是用户CA证书，都可以在设置-&amp;gt;系统安全-&amp;gt;加密与凭据-&amp;gt;信任的凭据中查看
3. Android 7.0的用户CA证书限制 Android从7.0开始系统不再信任用户CA证书（应用targetSdkVersion &amp;gt;= 24时生效，如果targetSdkVersion &amp;lt; 24即使系统是7.0+依然会信任）。也就是说即使安装了用户CA证书，在Android 7.0+的机器上，targetSdkVersion &amp;gt;= 24的应用的HTTPS包就抓不到了。
比如上面的例子，抓包工具用内置的CA证书，创建了www.baidu.com域名的公钥证书发给Client，系统校验此证书时发现是用户CA证书签发的，sorry。。。
那么，我们如果绕过这种限制呢？已知有以下四种方式（低于7.0的系统请忽略）：
3.1 AndroidManifest中配置networkSecurityConfig
&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;utf-8&amp;#34;?&amp;gt; &amp;lt;network-security-config&amp;gt; &amp;lt;base-config cleartextTrafficPermitted=&amp;#34;true&amp;#34;&amp;gt; &amp;lt;trust-anchors&amp;gt; &amp;lt;certificates src=&amp;#34;system&amp;#34; /&amp;gt; &amp;lt;certificates src=&amp;#34;user&amp;#34; /&amp;gt; &amp;lt;/trust-anchors&amp;gt; &amp;lt;/base-config&amp;gt; &amp;lt;/network-security-config&amp;gt; 这样即表示，App信任用户CA证书，让系统对用户CA证书的校验给予通过。更多相关信息，详见Network security configuration。</description>
    </item>
    
    <item>
      <title>解释执行7_0</title>
      <link>https://huanle19891345.github.io/en/android/art/jni/%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C7_0/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/art/jni/%E8%A7%A3%E9%87%8A%E6%89%A7%E8%A1%8C7_0/</guid>
      <description>quick_entrypoints_x86.S art_quick_invoke_stub /*这段注释来自于源码，它展示了调用art_quick_invoke_stub函数时，相关参数在栈中的布局 * Quick invocation stub (non-static). * On entry: * [sp] = return address 返回值地址，这是由函数调用指令自动压入栈的 * [sp + 4] = method pointer 代表方法C的ArtMethod对象 * [sp + 8] = argument array or null for no argument methods * [sp + 12] = size of argument array in bytes * [sp + 16] = (managed) thread pointer 这是代表调用线程的Thread对象 * [sp + 20] = JValue* result * [sp + 24] = shorty */ DEFINE_FUNCTION art_quick_invoke_stub #定义art_quick_invoke_stub函数  PUSH ebp // save ebp PUSH ebx // save ebx PUSH esi // save esi PUSH edi // save edi .</description>
    </item>
    
    <item>
      <title>路由</title>
      <link>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E8%B7%AF%E7%94%B1/%E8%B7%AF%E7%94%B1/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/%E8%B7%A8%E5%B9%B3%E5%8F%B0/flutter/%E8%B7%AF%E7%94%B1/%E8%B7%AF%E7%94%B1/</guid>
      <description>原理    可能你会比较好奇_Theatre中 offstage 是如何做到不绘制的。
你应该知道 Element 树的是通过其内部的mout方法将自己挂载到父 Element 上的。_Theatre的 mout方法不太一样， onstage走正常的挂载流程，加入到Element 树中； offstage集合中的 Widget 仅创建了对应的 Element，并没有挂载到 Element 树中。没有进入到Element中，也就不会进入到 RenderObject树中，也就不走到绘制流程了。
这样你应该能理解Overlay其实是Stack的扩展。Overlay预先进行过滤，从而避免了无用的绘制。
我们看下当路由中只有一个 Page 时的示意图：
我们再看下当路由中又被 push 进一个 Page时的情况：
因为通常 Page 的 opaque=true, maintainState=true,所以 Page2 进入 onstage， Page1 不在需要被绘制，但需要保持状态，进入了offstage。
因为通常 popupWindow（dialog） 的 opaque=false,我们再向路由中 push 一个 dialog:
类设计 Usage Navigator 1.0  **Navigator** — a widget that manages a stack of Route objects. **Route** — an object managed by a Navigator that represents a screen, typically implemented by classes like MaterialPageRoute.</description>
    </item>
    
    <item>
      <title>软件绘制</title>
      <link>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://huanle19891345.github.io/en/android/system/%E7%B3%BB%E7%BB%9F%E7%BB%98%E5%88%B6/%E8%BD%AF%E4%BB%B6%E7%BB%98%E5%88%B6/</guid>
      <description>软件绘制 深入理解Window
Android的UI显示原理之Surface的创建
Android的UI显示原理之Surface的渲染
https://github.com/SusionSuc/AdvancedAndroid/blob/master/AndroidFramework%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E8%A7%86%E5%9B%BE%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E7%9A%84UI%E6%98%BE%E7%A4%BA%E5%8E%9F%E7%90%86%E6%80%BB%E7%BB%93.md
https://github.com/SusionSuc/AdvancedAndroid/blob/master/framework/Android%E8%A7%86%E5%9B%BE%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/README.md
Android图形系统（九）-View、Canvas与Surface的关系
 整体流程 把整个流程再简单总结下，View、Canvas与Surface的关系也就一目了然了：
Surface通过dequeueBuffer流程（具体操作在此不多赘述）获取一块存放绘制数据的buffer。
View 在onDraw的时候，通过传入的Canvas进行绘制。（这里只是一个绘制的入口而已，本文是针对requestLayout 流程来讲述的，当然你单独用Canvas实现绘制也是一样的）。
调用java层的CanvasAPI，实际真正负责绘制工作的是底层的Skia引擎，这里核心类包括SKCanvas（画家）以及SKBitmap（画布），绘制好的内容放入Surface 通过dequeueBuffer获取到的GraphicBuffer。
绘制完毕后，Surface通过queueBuffer将存放好绘制数据的buffer投递到队列中，并通知SurfaceFlinger消费。
 SurfaceFlinger可以说是Android UI渲染体系的核心，在Android系统启动时会启动SurfaceFlinger服务,它的主要作用就是被Android应用程序调用，把绘制(测量，布局，绘制)后的窗口(Surface)渲染到手机屏幕上
SurfaceControl surface.lockCanvas(): //android_view_Surface.cpp static jlong nativeLockCanvas(JNIEnv* env, jclass clazz, jlong nativeObject, jobject canvasObj, jobject dirtyRectObj) { sp&amp;lt;Surface&amp;gt; surface(reinterpret_cast&amp;lt;Surface *&amp;gt;(nativeObject)); ... ANativeWindow_Buffer outBuffer; //调用了Surface的dequeueBuffer，从SurfaceFlinger中申请内存GraphicBuffer,这个buffer是用来传递绘制的元数据的  status_t err = surface-&amp;gt;lock(&amp;amp;outBuffer, dirtyRectPtr); ... SkImageInfo info = SkImageInfo::Make(outBuffer.width, outBuffer.height, convertPixelFormat(outBuffer.format), outBuffer.format == PIXEL_FORMAT_RGBX_8888 ? kOpaque_SkAlphaType : kPremul_SkAlphaType); //新建了一个SkBitmap，并进行了一系列设置  SkBitmap bitmap; ssize_t bpr = outBuffer.</description>
    </item>
    
  </channel>
</rss>
